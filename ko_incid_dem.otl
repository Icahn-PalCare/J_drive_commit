= V4 Outline MultiLine NoSorting TabWidth=30

H="Sample Derivations&Tables"
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress" 
use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear

*gets num of observations at wave where prob_dem first identified 
sort spid wave 
by spid: egen firstdem = min(cond(prob_dem ==1),wave,.)
label var firstdem "First Wave with Dementia"

*binary flag to flag wave only on waves that someone has 1st dem. 
by spid: gen flagwave= wave == firstdem

*sets flagwave to 0 when missing dementia status in previous obsv
by spid: replace flagwave = 0 if prob_dem[_n-1]==.
tab flagwave

*Flag ppl with pdem @ wave 1 & wave 5 (need to excl b/c not incid dementia)
gen pdem_w1_excl = 1 if firstdem == 1 & wave ==1 & yearsample ==2011
by spid: carryforward pdem_w1_excl, replace 
label var pdem_w1_excl "Dementia at Wave 1 (2011 cohort to exclude)"

gen pdem_w5_excl = 1 if firstdem == 5 & wave ==5 & yearsample ==2015
by spid: carryforward pdem_w5_excl, replace
label var pdem_w5_excl "Dementia at Wave 5(2015 cohort to exclude)"

*indicator variable, priorstat is 1 if wave prior is has completed sp_ivw & not missing & wave prior doesn't have probable dementia
sort spid wave 
by spid:gen priorstat = 1 if wave-1 == wave[_n-1] & prob_dem[_n-1]==0 & sp_ivw[_n-1]==1

*specific sample of incid dementia ppts 
gen subset_dem = 1 if priorstat == 1 & flagwave ==1

*get LFU counts
by spid: gen lfu = 1 if wave+1!=wave[_n+1] & subset ==1

*get nursing home in wave prior 
by spid: gen nhprior = nhres[_n-1]==1 if subset ==1

*exclude NH prior & LFU after from subset 
gen exclset = 1 if lfu!=1 & nhprior !=1 & subset ==1

*hb wave prior to incid dem
sort spid wave 
gen hbflag_prior= spid==spid[_n-1] & homebound_cat[_n-1]==1 & wave-1==wave[_n-1] if subset ==1 
label var hbflag_prior "HB Prior Wave"

*homebound at incid dementia wave 
sort spid wave 
gen hbflag_during=homebound_cat==1 if subset ==1 
label var hbflag_during "HB Same Wave"
 
*hb after incid dementia wave
sort spid wave
gen hbflag_after=spid==spid[_n+1] & homebound_cat[_n+1]==1 & wave+1==wave[_n+1] if subset ==1 
label var hbflag_after "HB After Wave"

*semi-hb at wave prior 
sort spid wave 
gen shbflag_prior = spid==spid[_n-1]  & wave-1==wave[_n-1] & homebound_cat[_n-1]==2 if subset ==1
replace shbflag_prior =1 if spid==spid[_n-1] & wave-1==wave[_n-1] & homebound_cat[_n-1]==3 & subset ==1
label var shbflag_prior "SHB Prior Wave"

*semi-hb during incid dementia wave 
gen shbflag_during = homebound_cat ==2 if subset ==1 
replace shbflag_during=1 if homebound_cat ==3 & subset ==1 
label var shbflag_during "SHB Same Wave"

*semihb after wave of incid dementia 
gen shbflag_after=spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==2 if subset ==1
replace shbflag_after = 1 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==3 & subset ==1 
label var shbflag_after "SHB After Wave"

label var age "Mean Age"
label define agecat 1 "Age 65-70" 2 "Age 70-75" 3 "Age 75-80" 4 "Age 80-85" 5 "Age 85-90" 6 "Age 90-95"
label values agecat agecat 

label define income_quart 1 "Income Bottom" 2 "Income Second" 3 "Income Third" 4 "Income Top", modify

label define livearrang 1 "Alone" 2 "Lives w. Spouse/Partner" 3 "Lives w. Spouse/Partner+Others" 4 "Lives w. Others", modify 

local catvars livearrang income_quart agecat wave
local cativars

foreach x of local catvars {
                local `x'
levelsof `x', local(levels)
                foreach l of local levels {                
                                gen `x'`l'=`x'==`l' if !missing(`x')
                                local lab : label `x' `l'
                                label var `x'`l' "`lab'"
                                local `x' ``x'' `x'`l'
}
              local cativars `cativars' ``x'' 
}

*Table: Incid Dementia at Wave (Including those LFU after wave & in NH in wave Prior)
local waves wave1 wave2 wave3 wave4 wave5 wave6 wave7 wave8 
local rn: word count `waves' 2
mat tabwave = J(`rn',4,.)

local r=1
foreach x of local waves {
tab `x' if `x'==1 & subset_dem == 1 & yearsample ==2011
mat tabwave [`r',1]=r(N)
tab `x' if `x'==1 & subset_dem == 1 & yearsample ==2015
mat tabwave [`r',2]=r(N)
sum `x' if `x'==1 & subset_dem == 1
mat tabwave [`r',3]= r(N)
sum `x' if subset_dem == 1
mat tabwave [`r',4]= r(mean)*100
local r = `r'+1
}

sum subset if subset_dem == 1 & yearsample ==2011
mat tabwave [`r',1]= r(N)
sum subset if subset_dem == 1 & yearsample ==2015
mat tabwave [`r',2]= r(N)
sum subset 
mat tabwave [`r',3]= r(N)
mat tabwave [`r',4]=r(mean)*100

mat rownames tabwave = `waves' "Total"
mat list tabwave

frmttable using incid_dementia_tables.rtf, replace statmat(tabwave) title("Wave at Incident Dementia by Cohort (incl. NH Prior & LFU After)") ctitles("" "2011 Only" "2015 Only" "Total" "% of Total" ) sdec(0,0,0,2) varlabels note ("Incident Dementia for both 2011 & 2015 cohort (excludes those who entered with dementia)")

*Table: Incid Dementia at Wave (Show Censoring w8 & LFU after wave & in NH in wave Prior)
local waves wave1 wave2 wave3 wave4 wave5 wave6 wave7 wave8 
local rn: word count `waves' 2
mat tabcensor = J(`rn',4,.)

local r=1
foreach x of local waves {
tab `x' if `x'==1 & subset == 1 & nhprior ==1 
mat tabcensor [`r',1]=r(N)
tab `x' if `x'==1 & subset_dem == 1 & lfu ==1 
mat tabcensor [`r',2]=r(N)
sum `x' if `x'==1 & subset_dem == 1 & lfu!=1 & nhprior !=1
mat tabcensor [`r',3]= r(N)
sum `x' if subset_dem == 1 & lfu!=1 & nhprior !=1
mat tabcensor [`r',4]= r(mean)*100
local r = `r'+1
}

sum subset if subset_dem == 1 & nhprior==1
mat tabcensor [`r',1]= r(N)
sum subset if subset_dem == 1 & lfu ==1 
mat tabcensor [`r',2]= r(N)
sum subset if lfu!=1 & nhprior !=1 
mat tabcensor [`r',3]= r(N)
mat tabcensor [`r',4]=r(mean)*100

mat rownames tabcensor = `waves' "Total"
mat list tabcensor

frmttable using incid_dementia_tables.rtf, addtable statmat(tabcensor) title("Wave at Incident Dementia by NH Prior & LFU After") ctitles(""  "NH in Prior Wave" "LFU/Censor in Next Wave" "Remaining Incid Dem Pop" "% of Remaining Incid Dem Pop" ) sdec(0,0,0,2) varlabels note ("**LFU & NH Prior is NOT mutually exclusive. (1 ppt is counted twice due to being in NH in prior Wave & LFU in next wave.)")

*Table: Homebound Status Before/During/After Incident Dementia Wave 
local hbvars hbflag_prior hbflag_during hbflag_after shbflag_prior shbflag_during shbflag_after 
local rn: word count `hbvars' 
mat tabhb = J(`rn',4,.)
local r=1

foreach x of local hbvars{
sum `x' if `x'==1 & subset_dem == 1
mat tabhb [`r',1]= r(N)
sum `x' if subset_dem == 1
mat tabhb [`r',2]= r(mean)*100

sum `x' if `x'==1 & exclset ==1
mat tabhb [`r',3]= r(N)
sum `x' if exclset ==1
mat tabhb [`r',4]= r(mean)*100
local r = `r'+1
}

mat rownames tabhb = `hbvars' 

frmttable using incid_dementia_tables.rtf, addtable statmat(tabhb) title("Homebound and Incident Dementia") ctitles("" "N(incl LFU&NH)" "%(incl LFU&NH)" "N(excl LFU&NH)" "%(excl LFU&NH)" ) sdec(0,2,0,2) varlabels


*Table: Demographics inclusive of LFU & NH 
local ivars income_quart1 income_quart2 income_quart3 income_quart4  agecat1 agecat2 agecat3 agecat4 agecat5 agecat6 female white black hisp other_race marital_nev married marital_wid marital_sd livealone resspouse livearrang4 community nhres nhats_died_12  
local cvars age 

local rn: word count `cvars' `ivars' 2

mat tab = J(`rn',4,.)
local r=1

foreach x of local cvars {
sum `x' if subset==1 
mat tab [`r',1]=r(N)
mat tab [`r',2]= r(mean)
sum `x' if exclset==1 
mat tab [`r',3]=r(N)
mat tab [`r',4]= r(mean)
local r = `r'+1
}

foreach x of local ivars{
sum `x' if `x'==1 & subset_dem == 1
mat tab [`r',1]= r(N)
sum `x' if subset_dem == 1
mat tab [`r',2]= r(mean)*100
sum `x' if `x'==1 & exclset == 1
mat tab [`r',3]= r(N)
sum `x' if exclset == 1
mat tab [`r',4]= r(mean)*100
local r = `r'+1
}

sum subset 
mat tab [`r',1]= r(N)
sum exclset 
mat tab [`r',3]= r(N)

mat rownames tab = `cvars' `ivars' "Total" 

frmttable using incid_dementia_tables.rtf, addtable statmat(tab) title("Demographics for Incident Dementia") ctitles("" "N(incl LFU&NH)" "%(incl LFU&NH)" "N(excl LFU&NH)" "%(excl LFU&NH)") sdec(0,2,0,2) varlabels note ("All variables, except Mean Age, are categorical.")

*********************UNWEIGHTED TABLE 1, MIGHT NOT RUN B/C OF VAR CHANGES**************

/*
**Table 1: 2011 Cohort Unweighted 
*incicat (t) 0: not hb, 1 hb in priorwave/concurrently
preserve
keep if incident & yearsample ==2011
local cvars1 age tot_hrswk_help_i
local ivars1 female married educ_hs_ind
local catvars1 race3
local cvars2 adl_index 
local ivars2 ind_paid_help  rcfres livealone metro_ind
local catvars2 comorbid 
local catvars3 income_quart
local catvars4 nhelpers3
local ivars5 hrs_help_2cat
local catvars5 hrs_help_3cat

gen n=1


forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows' 1 1 
local r=1
local c=1

mat tab=J(`rn',4,.)
mat stars=J(`rn',4,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}
tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: mean ltpov 
mat tab[`r',`c']= e(b_mi)*100
mi estimate: mean ltpov if incicat ==0 
mat tab[`r',`c'+1]= e(b_mi)*100
mi estimate: mean ltpov if incicat ==1
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate: reg ltpov incicat if inlist(incicat,1,0)
mat tab[`r',`c'+3]=e(p_mi)
mat stars[`r',`c'+3]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 
***********************
local r = 2
forvalues i=1/5 {
	foreach x of local cvars`i' {
	sum `x'   
		mat tab[`r',`c']=r(mean)
	
		local r=`r'+1		
}
	foreach x of local ivars`i' {
		sum `x' 
		 mat tab[`r',`c']=r(mean)*100
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x'  
		local r=`r'+1
		foreach z of local `x' {
			sum `z' 
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
			}
}

}
	svy: mean n
	mat tab[`r',`c']=e(N_psu)
	local r = `r'+1 
	mat tab[`r',`c']=e(N_pop)
		

local r = 2
local c = 2

foreach t in 0 1 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
	sum `x' if incicat==`t'  //gives same #s
		mat tab[`r',`c']=r(mean)
		if `t'==1 {
			reg `x' incicat if inlist(incicat,`t',0)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t' 
		 mat tab[`r',`c']=r(mean)*100

		if `t'==1 {
		tab `x' incicat if inlist(incicat,`t',0), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t' 
		if `t'==1 {
		tab `x' incicat if inlist(incicat,`t',0), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t' 
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
			}
}
}

	sum n if incicat==`t' [aw=anfinwgt]
	mat tab[`r',`c']==r(N)
	local r = `r'+1 
	mat tab[`r',`c']==r(sum_w)
	local r=2
	local c=`c'+1
	
}	

mat rownames tab= "Poverty Threshold" `rows'  N "Estimated N"

mat list tab

*frmttable using "inci_dem_tab1_2011only_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort-No Survey Weights") ctitles("" "Incident Dementia Full Sample" "Incidem & non-HB" "Incidem & HB(Prior-Concur)" "P-value") varlabels sdec(2,2,2,3) annotate(stars) asymbol(*,**,NR) addtable note("P-values for homebound, relative to non-homebound group") 

restore

*/

H="Archive Logit Models incl. ADL for HB & nonHB "
*logits 
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

*don't use ADL Outside (adl_out_help)
*adls: bath dres eat toil ins bed 
*adl counts: adl_same_count adl_incr_count adl_decr_count

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"

*below confirm that adl_index numbers are correct 
*egen testcounts = rowtotal(adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help ) if !missing(adl_eat_help) &!missing(adl_bath_help) &!missing(adl_toil_help) & !missing(adl_dres_help) & !missing(adl_ins_help )& !missing(adl_bed_help)  

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status 
keep if sp_ivw==1 & !missing(prob_dem)

sort spid wave
*get wave of first time probable dementia is indicated
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

*get wave of first nh resident 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
*possible dementia at prior wave 
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for those who are hb
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
*prob dementia score in prior wave 

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"
tab incicat if incid ==1

*create var of adl impairment in prior wave 
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
tab1 race race3
label define race3 1 "White & Other(Non-Hisp)" 2 "Black(Non-Hisp)" 3 "Hispanic"
label values race3 race3
label var race3 "Race (White&Other/Black/Hispanic)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

gen ind_help40hrs=tot_hrswk_help_i>40
label var ind_help40hrs "Indicator: Help >40+ hrs wk"

*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

gen sev_dem=0
replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

local cfullvars age income_adj tot_hrswk_help_i 
local ifullvars agecat income_quart bottomincome topincome female married educ_hs_ind race race3 srh_fp rcfres livearrang shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair home_disorder_insd home_disorder_outsd home_disorder_area home_disorder_clutter ind_help40hrs creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst n_helpers ind_no_helpers ind_paid_helper num_helpers_cat nhelpers3

foreach x of local ifullvars{
tab `x' if incident ==1 
} 

*check combinations of other race & white/black/hispanic categories 
/*
gen blackother = 1 if race==1 
replace blackother = 2 if race==3 
replace blackother = 2 if race ==2
replace blackother = 3 if race==4 
tab1 race blackother

gen hispother = 1 if race==1 
replace hispother = 3 if race==3 
replace hispother = 2 if race ==2
replace hispother = 3 if race==4 
tab1 race hispother

local catrace race race3 blackother hispother
foreach x of local catrace {
logit incicat `x' if incident==1
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x'  Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}
*confirms that white+others is best combo for recategorizing white 

*choose either livearrang or married, but not both b/c most married live w/ spouse/partner, + others, while not married lives alone or with others 

*model selection for demographic vars only
preserve
keep if incident 
local agevar age agecat 
local incomevar income_adj i.income_quart bottomincome topincome
local racevar i.race i.race3 
local demovars female educ_hs_ind srh_fp rcfres  
local marital_living married i.livearrang
local hbvars shb_n1 adl_imp_n1 adl_impair

foreach y of local incomevar{
foreach x of local agevar{
foreach z of local racevar {
foreach w of local marital_living{
qui logit incicat `x' `y' `z' `demovars' `hbvars' `marital_living', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x' & `y' & `z' & `w' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
}
}
}
}

*best model for demographics: age & bottomincome & i.race3 & i.livearrang Pseudo r:.23_ AIC:1074.76_ BIC:1155.79_LROC:.82

*add signif homedisorder vars & assistance vars & check models for num of helpers, indicator of no pd help & hrs of help 
preserve 
keep if incident 
local demovars age bottomincome i.race3 female educ_hs_ind srh_fp rcfres i.livearrang shb_n1 adl_imp_n1 adl_impair 
local signifvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars n_helpers i.num_help nhelpers3 n_family_helpers ind_family_help n_paid_helpers i.ind_paid_helper tot_hrswk_help_i ind_help40hrs //ind_gt20hrs_wk_inf tot_otherinformalhrs ind_gt20hrs_wk_paid tot_paidhrs    

foreach x of local helpvars{
qui logit incicat `x' `demovars' `signifvars', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' `num' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"

}
restore

*Helper Vars for Model based on AIC & BIC: n_helpers (as continuous), ind_paid_helper, ind_help40hrs 


*rename ind_gt40 ind_help40hrs
*Tables w/ all vars selected  & removed 4 vars 
preserve
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 
local finanvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars i.adl_change i.nhelpers3 ind_help40hrs i.adl_3cat_counts adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help adl_imp_n1 


*local title "`HB & Num Helper'" "`HB & Pd Help'" "`HB & 40+hs Help'"
outreg, clear 
logit incicat `modelvars' i.adl_change i.adl_3cat_counts i.nhelpers3 if incident, or 


foreach x of local helpvars{
qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'_allvars") varlabels 
local num = r(N)
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' popln:`num' r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"


*qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
*di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}


*outreg using modselect_selectvars_20200510v4.rtf, replay replace title("Incident Dementia & Concurrently HB Logit Model") note("OR is displayed. Semi-HB is considered Independent, not HB. Referent Race: White & Others. Referent Living Arrangment: Live Alone")

*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model 

restore

/*
Notes for margin effects: to get change in vars. useful for interaction terms. ie. look at full or interaction effect. or look at something over a value. ie. look at age at 65, 75, 85

logit incicat i.adl_change i.adl_3cat_counts i.nhelpers3 if incident, or

*get predictive margins of adl_3cat_count
margins adl_3cat_counts

*get average marginal effects of adl_3cat_count
margins, dydx(adl_3cat_counts)

*to get average from marginal effects. take category of interest - reference cat 
*in example: 4-6adl: 0.53, no adl: 0.13 >> avge ME: 0.53-0.13 = 0.40

*get predictive margins of adl_change
margins, dydx(adl_change)

*gets margins by categories. so in adl_change, what is the adl counts... 
margins, dydx(adl_change) over (adl_3cat_count)

*gets margins of all the vars from logit 
margins, dydx (*)


*/

H="Selection Process for Logit Models "
*clean this one up to just get current model 
cd "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

import excel "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) //nogen 

sort ivw_year hhm

levelsof spid if hhm>9 & hhm<.

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*gen poverty indicator for ppl income is less than poverty threshold 
gen poverty_ind= poverty_thresh >= aveincome & poverty_thresh!=.
replace poverty_ind =. if poverty_thres==.
tab poverty_ind
label var poverty_ind "Poverty Indicator"

*don't use ADL Outside (adl_out_help)
*adls: bath dres eat toil ins bed 
*adl counts: adl_same_count adl_incr_count adl_decr_count

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"

*below confirm that adl_index numbers are correct 
*egen testcounts = rowtotal(adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help ) if !missing(adl_eat_help) &!missing(adl_bath_help) &!missing(adl_toil_help) & !missing(adl_dres_help) & !missing(adl_ins_help )& !missing(adl_bed_help)  

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status 
keep if sp_ivw==1 & !missing(prob_dem)

sort spid wave
*get wave of first time probable dementia is indicated
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

*get wave of first nh resident 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 
drop if firstnh<=firstdem | missing(firstdem)

by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
*possible dementia at prior wave 
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1

*indicator var for those who are hb
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
*prob dementia score in prior wave 

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

*hb at prior wave 
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"
tab incicat if incid ==1

*create var of adl impairment in prior wave 
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
tab1 race race3
label define race3 1 "White & Other(Non-Hisp)" 2 "Black(Non-Hisp)" 3 "Hispanic"
label values race3 race3
label var race3 "Race (White&Other/Black/Hispanic)"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

gen ind_help40hrs=tot_hrswk_help_i>40
label var ind_help40hrs "Indicator: Help >40+ hrs wk"

*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

gen sev_dem=0
replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

local cfullvars age income_adj tot_hrswk_help_i 
local ifullvars agecat income_quart bottomincome topincome female married educ_hs_ind race race3 srh_fp rcfres livearrang shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair home_disorder_insd home_disorder_outsd home_disorder_area home_disorder_clutter ind_help40hrs creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst n_helpers ind_no_helpers ind_paid_helper num_helpers_cat nhelpers3

foreach x of local ifullvars{
tab `x' if incident ==1 
} 

*check combinations of other race & white/black/hispanic categories 
gen blackother = 1 if race==1 
replace blackother = 2 if race==3 
replace blackother = 2 if race ==2
replace blackother = 3 if race==4 
tab1 race blackother

gen hispother = 1 if race==1 
replace hispother = 3 if race==3 
replace hispother = 2 if race ==2
replace hispother = 3 if race==4 
tab1 race hispother

local catrace race race3 blackother hispother
foreach x of local catrace {
logit incicat `x' if incident==1
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x'  Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}
*confirms that white+others is best combo for recategorizing white 

*choose either livearrang or married, but not both b/c most married live w/ spouse/partner, + others, while not married lives alone or with others 

*model selection for demographic vars only
preserve
keep if incident 
local agevar age agecat 
local incomevar income_adj i.income_quart bottomincome topincome
local racevar i.race i.race3 
local demovars female educ_hs_ind srh_fp rcfres  
local marital_living married i.livearrang
local hbvars shb_n1 adl_imp_n1 adl_impair

foreach y of local incomevar{
foreach x of local agevar{
foreach z of local racevar {
foreach w of local marital_living{
qui logit incicat `x' `y' `z' `demovars' `hbvars' `marital_living', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
*local num = r(N)
local area = round(r(area)*100)/100
di "`x' & `y' & `z' & `w' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
}
}
}
}
restore 
*best model for demographics: age & bottomincome & i.race3 & i.livearrang Pseudo r:.23_ AIC:1074.76_ BIC:1155.79_LROC:.82

*add signif homedisorder vars & assistance vars & check models for num of helpers, indicator of no pd help & hrs of help 
preserve 
keep if incident 
local demovars age bottomincome i.race3 female educ_hs_ind srh_fp rcfres i.livearrang shb_n1 adl_imp_n1 adl_impair 
local signifvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars n_helpers i.num_help nhelpers3 n_family_helpers ind_family_help n_paid_helpers i.ind_paid_helper tot_hrswk_help_i ind_help40hrs //ind_gt20hrs_wk_inf tot_otherinformalhrs ind_gt20hrs_wk_paid tot_paidhrs    

foreach x of local helpvars{
qui logit incicat `x' `demovars' `signifvars', or 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' `num' Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"

}
restore
*Helper Vars for Model based on AIC & BIC: n_helpers (as continuous), ind_paid_helper, ind_help40hrs 


*Tables w/ all vars selected  & removed 4 vars 
preserve
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 adl_imp_n1 adl_impair 
local finanvars finhlpfam section8 govtasst home_disorder_clutter 
local helpvars n_helpers ind_paid_helper ind_help40hrs 
*local title "`HB & Num Helper'" "`HB & Pd Help'" "`HB & 40+hs Help'"
outreg, clear 
foreach x of local helpvars{
/*
qui logit incicat `modelvars' `finanvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'_allvars") varlabels 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' All Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/

qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
*di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}

*outreg using modselect_selectvars_20200510v4.rtf, replay replace title("Incident Dementia & Concurrently HB Logit Model") note("OR is displayed. Semi-HB is considered Independent, not HB. Referent Race: White & Others. Referent Living Arrangment: Live Alone")

*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model 

restore


***caregiving variables*** 
/*full list of vars:
age agecat income_adj i.income_quart bottomincome topincome female married educ_hs_ind race srh_fp rcfres livearrang shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair home_disorder_insd home_disorder_outsd home_disorder_area home_disorder_clutter ind_help40hrs creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst n_helpers ind_no_helpers ind_paid_helper tot_hrswk_help_i  
*/

*model selection for ADL variables & function*
preserve
outreg, clear 
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 
local helpvars i.adl_change i.nhelpers3 ind_help40hrs i.adl_3cat_counts adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_bed_help adl_ins_help adl_imp_n1 adl_index

foreach x of local helpvars{
qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'_allvars") varlabels 
local num = r(N)
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' popln:`num' r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"

*qui logit incicat `modelvars' `x', or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
/*
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
*di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*/
}

*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model 

*****check margin effects for models*****
*Notes for margin effects: to get change in vars. useful for interaction terms. ie. look at full or interaction effect. or look at something over a value. ie. look at age at 65, 75, 85

logit incicat i.adl_change i.adl_3cat_counts i.nhelpers3 if incident, or

*get predictive margins of adl_3cat_count
margins adl_3cat_counts

*get average marginal effects of adl_3cat_count
margins, dydx(adl_3cat_counts)

*to get average from marginal effects. take category of interest - reference cat 
*in example: 4-6adl: 0.53, no adl: 0.13 >> avge ME: 0.53-0.13 = 0.40

*get predictive margins of adl_change
margins, dydx(adl_change)

*gets margins by categories. so in adl_change, what is the adl counts... 
margins, dydx(adl_change) over (adl_3cat_count)

*gets margins of all the vars from logit 
margins, dydx (*)

restore

**Selected Model for ADL****
preserve
outreg, clear 
keep if incident 
local modelvars age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 
logit incicat `modelvars' i.adl_3cat_counts if incident, or
estat ic 
lroc 
*outreg using models_adl20200521v4.rtf, merge stats(e_b e_ci p) ctitles("" "ADL Categorical") varlabels title("Incident Dementia & Concurrently HB Logit Model") note("OR is displayed. Semi-HB is considered Independent, not HB. Referent Race: White & Others. Referent Living Arrangement: Live Alone. Referent ADL Category: No ADLs")

label var adl_index "ADL Counts (Continuous)"
logit incicat `modelvars' adl_index if incident, or 
estat ic 
lroc 
*outreg using models_adl20200521v4.rtf, merge stats(e_b e_ci p) ctitles("" "ADL Continuous") varlabels 

restore 

*selection model for financial help 
preserve 
keep if incident 
local modelvars age i.race3 married marital_wid marital_sd rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 paid_help_ind livealone
local finhelpvars finhlpfam section8 meals_wheels govtasst
foreach x of local finhelpvars{
qui logit incicat `modelvars' `x' adl_index, or 
*outreg, merge stats(e_b p) ctitles("" "`x'") varlabels 
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
}

*live arrang/married vars 
preserve
outreg, clear 
keep if incident 
local modelvars age i.race3 rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 paid_help_ind 
qui logit incicat `modelvars' adl_index married marital_wid marital_sd livealone if incident, or
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*Less Vars Pseudo r:.23_ AIC:1044.81_ BIC:1125.16_LROC:.82

*kept categorical live alone, added paid help, removed marital status 
qui logit incicat `modelvars' adl_index i.livearrang if incident, or
local pseudor2 = round(e(r2_p)*100)/100
qui estat ic
local aic = round(r(S)[1,5]*100)/100
local bic = round(r(S)[1,6]*100)/100
set graphics off
qui lroc 
local num = r(N)
local area = round(r(area)*100)/100
di "`x' Less Vars Pseudo r:`pseudor2'_ AIC:`aic'_ BIC:`bic'_LROC:`area'"
*Pseudo r:.23_ AIC:1048.7_ BIC:1124.04_LROC:.8100000000000001

restore 

H="table 1 and caregiving resources, 3 categories"
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

label var income_adj "Income, 2018$"
keep if sp_ivw==1 & !missing(prob_dem)
sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
by spid: egen firstnh=min(cond(nhres==1),wave,.)
drop if firstnh<=firstdem | missing(firstdem)
rename race_cat race
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2

label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"
gen incicat=hbcat_n1==1
replace incicat=2 if !incicat & hbcat==1
replace incicat=3 if !incicat & inlist(hbcat,2,3)
tab incicat
label define incicat 1 "Homebound at N1" 2 "Concurrently homebound" 3 "Not homebound"
label values incicat incicat
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"

drop if missing(hbcat) | missing(hbcat_n1)

local home 
foreach x of varlist home_di* {
	local home `home' `x'
}

preserve
keep if incident
local cvars1 age 
local ivars1 female married educ_hs_ind
local catvars1 race
local cvars2 income_adj
local ivars2 
local catvars2 income_quart
local ivars3 shb_n1 possdem_n1 adl_imp_n1 adl_impair srh_fp rcfres
local catvars3 livearrang
local ivars4
gen n=1


forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

foreach t in 1 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'<3 {
			reg `x' incicat if inlist(incicat,`t',3)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+2
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles("" "HB at N1" "P-value" "Concurrent HB" "P-value" "Non-HB") varlabels ///
sdec(2,3,2,3,2) annotate(stars) asymbol(*,**,NR) replace note("P-values relative to non-homebound group")

restore

keep if incident
local cvars1 n_helpers
local ivars1 ind_no_helpers ind_paid_helper
local catvars1
local cvars2 tot_hrswk_help_i
local ivars2 ind_gt40 `home' creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst
local catvars2
local ivars3 
local catvars3 
local ivars4
gen n=1
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)
gen ind_gt40=tot_hrswk_help_i>40
foreach x of local ivars2 {
replace `x'=0 if missing(`x')
}
label var tot_hrswk_help_i "Total hours of help/week, mean"

forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

foreach t in 1 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'<3 {
			reg `x' incicat if inlist(incicat,`t',3)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'<3 {
		tab `x' incicat if inlist(incicat,`t',3), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+2
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles("" "HB at N1" "P-value" "Concurrent HB" "P-value" "Non-HB") varlabels ///
sdec(2,3,2,3,2) annotate(stars) asymbol(*,**,NR) addtable note("P-values relative to non-homebound group")



H="table 1 and caregiving resources, 2 cats"
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear
merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

label var income_adj "Income, 2018$"
keep if sp_ivw==1 & !missing(prob_dem)
sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
by spid: egen firstnh=min(cond(nhres==1),wave,.)
drop if firstnh<=firstdem | missing(firstdem)
rename race_cat race
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2

label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 
by spid: gen hbcat_n1=hbcat[_n-1]
label copy hbcat hbcat_n1 
label values hbcat_n1 hbcat_n1
by spid: gen adl_imp_n1=adl_impair[_n-1]==1
label var adl_imp_n1 "ADL dependent at N1" 

by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen pr_ad8_score_n1=pr_ad8[_n-1]
by spid: gen possdem_n1=dem_3_cat[_n-1]==2
label var possdem "Possible Dementia at N1"
gen incicat=hbcat_n1==1
replace incicat=2 if !incicat & hbcat==1
replace incicat=3 if !incicat & inlist(hbcat,2,3)
tab incicat
label define incicat 1 "Homebound at N1" 2 "Concurrently homebound" 3 "Not homebound"
label values incicat incicat
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at N1"
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at N1"
drop if missing(hbcat) | missing(hbcat_n1)

local home 
foreach x of varlist home_di* {
	local home `home' `x'
}

replace incicat=2 if incicat==1

preserve
keep if incident
local cvars1 age 
local ivars1 female married educ_hs_ind
local catvars1 race
local cvars2 income_adj
local ivars2 
local catvars2 income_quart
local ivars3 shb_n1 hb_n1 possdem_n1 adl_imp_n1 adl_impair srh_fp rcfres
local catvars3 livearrang
local ivars4
gen n=1


forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

foreach t in 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'==3 {
			reg `x' incicat if inlist(incicat,`t',2)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+1
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles(""  "HB" "Non-HB" "P-value") varlabels ///
sdec(2,2,3) annotate(stars) asymbol(*,**,NR) replace note("P-values relative to non-homebound group")

restore

keep if incident
local cvars1 n_helpers
local ivars1 ind_no_helpers ind_paid_helper
local catvars1
local cvars2 tot_hrswk_help_i
local ivars2 ind_gt40 `home' creditdebt medcreditdebt medbillsovertime medpaynotcash finhlpfam section8 meals_wheels govtasst
local catvars2
local ivars3 
local catvars3 
local ivars4
gen n=1
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)
gen ind_gt40=tot_hrswk_help_i>40
foreach x of local ivars2 {
replace `x'=0 if missing(`x')
}
label var tot_hrswk_help_i "Total hours of help/week, mean"

forvalues i=1/5 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`catvars1'"
di "`cativars1'"

local rows
forvalues i=1/5 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1
local r=1
local c=1

mat tab=J(`rn',3,.)
mat stars=J(`rn',3,0)

foreach t in 2 3 {
forvalues i=1/5 {
	foreach x of local cvars`i' {
		sum `x' if incicat==`t', d
		mat tab[`r',`c']=r(mean)
		*mat tab [`r'+1,`c']=r(sd)
		*mat tab[`r'+2,`c']=r(p50)
		if `t'==3 {
			reg `x' incicat if inlist(incicat,`t',2)
			test incicat 
			mat tab[`r',`c'+1]=r(p)
			mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		}
		local r=`r'+1
		
}
	foreach x of local ivars`i' {
		sum `x' if incicat==`t'
		 mat tab[`r',`c']=r(mean)*100

		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		sum `x' if incicat==`t'
		if `t'==3 {
		tab `x' incicat if inlist(incicat,`t',2), chi2 
		mat tab[`r',`c'+1]=r(p)
		mat stars[`r',`c'+1]=(r(p)<.05) + (r(p)<.01)
		*if `n'-r(N)>=11 | `n'==r(N) mat tab[`r',`c'+1]=`n'-r(N)
		*else mat stars[`r',`c'+1]=3
}		
		local r=`r'+1
		foreach z of local `x' {
			sum `z' if incicat==`t'
			mat tab[`r',`c']=r(mean)*100
			local r=`r'+1
}
}
}
	sum n if incicat==`t'
	mat tab[`r',`c']==r(N)
	local r=1
	local c=`c'+1
}	

mat rownames tab=`rows'  N

frmttable using "inci_dem_sample_chars_`c(current_date)'.rtf", ///
statmat(tab) title("Characteristics of Sample") ///
ctitles("" "HB" "Non-HB" "P-value") varlabels ///
sdec(2,2,3) annotate(stars) asymbol(*,**,NR) addtable note("P-values relative to non-homebound group")



H="Tab 1: Incidem & HB Only- Old Var Order - Reference "
*Table 1, Full Sample & Incid Homebound (no NSOC) excl Small Cells -REFERENCE ONLY 
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_no_nsoc.dta", clear
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

*tab moved_last_5 res_care if incid ==1
*Figure 1 
graph pie if incid ==1 [pw=anfinwgt], over(hbchart) plabel(_all percent)
	
set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 

label var sr_numcondit "# Med Conditions (excl Dementia) - Mean"
*label var length_in_res "Years at Residence - Mean"
label var adl_index "ADL Counts (Continuous)-Mean"
*label var ind_paid_helper "Paid Help Indicator"
label var indep_hb "HB Status: Independent "
label var nhelpers3 "# of Helpers (3 Categories)"

local cvars1 age adl_index iadl_index n_children
local ivars1 female married educ_hs_ind hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1 medicaid sr_phq2_depressed
local catvars1 race3
local ivars2 ind_paid_helper  rcfres livealone metro_ind fin_strain moved_last_5 moved_count proxy_ivw
local catvars2 income_quart 
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 tot_hrswk_help_i
local catvars4  hrs_help_3cat 
local cvars5 sr_numcondit
local catvars5 comorbid 
*local cvars6 length_in_res
*local catvars6 length_in_res_3cat

/*
*New Order of Vars for Table 
local cvars1 age
local ivars1 female married educ_hs_ind 
local catvars1 race3 
local cvars2
local ivars2 medicaid fin_strain
local catvars2 income_quart 
*insert poverty thresh variable 
local cvars3 
local ivars3 metro_ind livealone rcfres moved_last_5 moved_count cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3
local cvars4 
local ivars4 hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1  sr_phq2_depressed proxy_ivw ind_paid_helper  
local cvars5 adl_index tot_hrswk_help_i
local ivars5 
local catvars5 hrs_help_3cat nhelpers3
local cvars6  tot_hrswk_help_i
local ivars6 sr_numcondit
local catvars6 comorbid 
*/

/*Categories
Demographics: age female married educ_hs_ind race3 medicaid fin_strain income_quart 
Community/Cohesion:metro_ind livealone rcfres  moved_last_5 moved_count cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
Clinical Function:hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1 proxy_ivw  adl_index ind_paid_helper nhelpers3 tot_hrswk_help_i   hrs_help_3cat sr_phq2_depressed  sr_numcondit comorbid 
*/


gen n=1

forvalues i=1/6 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/6 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows' 1 1 
local r=1
local c=1
local denom = 941

*****insert incid dem full sample here 
mat tab=J(`rn',5,.)
mat stars=J(`rn',5,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy, subpop(if incid ==1): mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==0): mean ltpov
mat tab[`r',`c'+1]= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==1): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate: svy: reg ltpov hb
mat tab[`r',`c'+3]=e(p_mi)
mat stars[`r',`c'+3]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

***********************
local r = 2

forvalues i=1/6 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	misstable sum `x' if incid ==1
	if r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot)) > 11/`denom'{
	mat tab [`r',`c'+4]=r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot))*100
	}
	if r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot)) <= 11/`denom'{
	mat stars [`r',`c'+4]=3
	}
	*mat tab [`r',`c'+5]=r(N_lt_dot)+r(N_eq_dot)
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
		misstable sum `x'
		if r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot)) > 11/`denom'{
		mat tab [`r',`c'+4]=r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot))*100
		}
		if r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot)) <= 11/`denom'{
		mat stars [`r',`c'+4]=3
		}
		*mat tab [`r',`c'+5]=r(N_lt_dot)+r(N_eq_dot)													 
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if hb==`t'): mean `x'
		misstable sum `x'
		if r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot)) > 11/`denom'{
		mat tab [`r',`c'+4]=r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot))*100
		}
		if r(N_eq_dot)/(r(N_lt_dot)+r(N_eq_dot)) <= 11/`denom'{
		mat stars [`r',`c'+4]=3
		}
		*mat tab [`r',`c'+5]=r(N_lt_dot)+r(N_eq_dot)	
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}
}

	*svy : mean n
	mat tab[`r',`c']=e(N_psu)
	local r = `r'+1 
	mat tab[`r',`c']=e(N_pop)

	local r=2

local c = `c'+1

foreach t in 0 1 {
forvalues i=1/6 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c']=e(p)
			mat stars[`r',`c']=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',4]= e(p_Pear)
		mat stars[`r',4]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+1]=e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
}
	svy, subpop(if incid ==1 & hb==`t'): mean n
	mat tab[`r',`c']==e(N_sub)
	local r = `r'+1 
	mat tab[`r',`c']==e(N_subpop)
	local r=2
	
	local c=`c'+1
}	

mat rownames tab= "Poverty Threshold"  `rows'  N "Estimated N"

mat list tab
frmttable using "tab1_incidem_hb_nosmallcell_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort w/ Survey Weights") ctitles("" "Incid Dem Full Sample" "InciDem & non-HB" "InciDem & HB" "P-value" "% Missing from Sample") varlabels sdec(2,2,2,2) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group" "% Missing is of the Unweighted Sample") replace

restore

*Table for wave at incident dementia 
preserve
keep if incident ==1
svyset spid [pw=anfinwgt], strata(varstrat)
mat tab = J(8,4,.)
local r = 1

forvalues i =2/8 {
tab wave`i'_incid if wave`i'_incid ==1
mat tab [`r',1]= r(N)
sum wave`i'_incid
mat tab [`r',2] =r(mean)*100
svy, subpop (if incident ==1 & wave`i'_incid==1) : mean wave`i'_incid
mat tab [`r', 3]= e(N_pop)
svy, subpop (if incident ==1): mean wave`i'_incid
mat tab[`r',4]==e(b)*100
local r = `r'+1
}
gen n = 1
svy, subpop (if incident ==1): mean n
mat tab[`r',1]= e(N)
mat tab [`r', 3]= e(N_pop)

mat list tab 

mat rownames tab = "Wave 2" "Wave 3" "Wave 4" "Wave 5" "Wave 6" "Wave 7" "Wave 8" "Total"
frmttable using "tab1_incidem_hb_nosmallcell_`c(current_date)'.rtf", statmat(tab) title("Wave at Incident Dementia") ctitles("" "# of Incident Dementia" "Unweighted %" "Weighted # of Incident Dementia" "Weighted %") varlabels sdec(2,2,2,2) addtable

restore


H="Bivariate Stratified by Race (No NSOC)"
*bivariate regressions, stratified by race w/o Merging NSOC 

cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_no_nsoc.dta", clear

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

****Current Logit Model**********
preserve
outreg, clear 


keep if incident ==1
*local allvars age i.race3 female educ_hs_ind adl_index rcfres i.comorbid metro_ind ind_paid_help ltpov
local tabvars female married educ_hs_ind rcfres metro_ind  adl_index comorbid5 medicaid sr_phq2_depressed fin_strain  moved_last_5 moved_count n_helpers cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd 

foreach x of local tabvars {
tab `x' race3 if incident ==1
svy, subpop(incident): tab `x' race3
}


local stratvars age female married educ_hs_ind rcfres metro_ind  adl_index iadl_index comorbid5 medicaid sr_phq2_depressed fin_strain  moved_last_5 moved_count tot_hrswk_help_i  n_helpers cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd proxy_ivw



local mi_var ltpov 
local rn : word count `stratvars' `mi_var' 1 1 

mat tab = J(`rn',4,.)
mat stars = J(`rn',4,0)
local r=1
local c=1

foreach x of local stratvars {
svy, subpop(incident): logit hb `x', or  
mat tab[`r',`c']=r(table)[1,1]
mat stars[`r',`c']=(e(p)<.05) + (e(p)<.01)
svy, subpop(if incident==1 & race3==0): logit hb `x', or  
mat tab[`r',`c'+1]=r(table)[1,1]
mat stars[`r',`c'+1]=(e(p)<.05) + (e(p)<.01)
svy, subpop(if incident==1 & race3==1): logit hb `x', or  
mat tab[`r',`c'+2]=r(table)[1,1]
mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
svy, subpop(if incident==1 & race3==2): logit hb `x', or  
mat tab[`r',`c'+3]=r(table)[1,1]
mat stars[`r',`c'+3]=(e(p)<.05) + (e(p)<.01)
local r = `r'+1
}

*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate, or:svy, subpop(incident): logit hb ltpov
mat tab[`r',`c']=r(table)[1,1]
mat stars[`r',`c']=(e(p_mi)<.05) + (e(p_mi)<.01)
mi estimate, or :svy, subpop(if incident==1 & race3==0): logit hb ltpov 
mat tab[`r',`c'+1]=exp(e(b_mi)[1,1])
mat stars[`r',`c'+1]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi estimate, or :svy, subpop(if incident==1 & race3==1): logit hb ltpov  
mat tab[`r',`c'+2]=exp(e(b_mi)[1,1])
mat stars[`r',`c'+2]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi estimate, or :svy, subpop(if incident==1 & race3==2): logit hb ltpov  
mat tab[`r',`c'+3]=exp(e(b_mi)[1,1])
mat stars[`r',`c'+3]=(e(p_mi)<.05) + (e(p_mi)<.01)
local r = `r'+1
mi extract 0 

gen n = 1
svy, subpop (incident): mean n
mat tab[`r',`c']==e(N_sub)
local r = `r'+1 
mat tab[`r',`c']==e(N_subpop)
local r=`r'-1

svy, subpop (if incident==1 & race3==0): mean n
mat tab[`r',`c'+1]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+1]==e(N_subpop)
local r=`r'-1

svy, subpop (if incident==1 & race3==1): mean n
mat tab[`r',`c'+2]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+2]==e(N_subpop)
local r=`r'-1

svy, subpop (if incident==1 & race3==2): mean n
mat tab[`r',`c'+3]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+3]==e(N_subpop)
local r=`r'-1

mat rownames tab= `stratvars' "Poverty Threshold"  "N" "Estimated N"

mat list tab
frmttable using "bivariate race_inci_dem_`c(current_date)'.rtf", statmat(tab) title("Bivariate Analysis of Being Homebound, Stratified by Race") ctitles("" "Incid Dem Full Sample" "White/Other" "Black(Non-Hispanic)" "Hispanic") varlabels sdec(2,2,2,2) replace annotate(stars) asymbol(*,**) note( "Odds Ratios are displayed." "Association of being homebound and each independent variable" "9 are missing race variable ")

restore


H="Tab 1: incidem & HB Only, No Std Dev. "
*Table 1 OUTDATED, LOOK AT TABLE THAT INCLS SD FOR UPDATED TABLE 
*Full Sample & Incid Homebound (no NSOC) excl Small Cells REORGANIZED TO DRAFT no SDs
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_no_nsoc.dta", clear
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

*tab moved_last_5 res_care if incid ==1
*Figure 1 
*graph pie if incid ==1 [pw=anfinwgt], over(hbchart) plabel(_all percent)
*graph bar [aweight = anfinwgt] if incident==1, over(hbcat_n1) over(hbcat) asyvars stack blabel(bar, position(center)) ytitle(% Homebound @ Incident Dementia) title(% HB Prior & HB Concurrent to Incident Dementia)
	
set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 

/* 
*Old Table Order 
local cvars1 age adl_index iadl_index n_children
local ivars1 female married educ_hs_ind hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1 medicaid sr_phq2_depressed
local catvars1 race3
local ivars2 ind_paid_helper  rcfres livealone metro_ind fin_strain moved_last_5 moved_count proxy_ivw
local catvars2 income_quart 
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 tot_hrswk_help_i
local catvars4  hrs_help_3cat 
local cvars5 sr_numcondit
local catvars5 comorbid 
*local cvars6 length_in_res
*local catvars6 length_in_res_3cat
*/

*New Order of Vars for Table 
local cvars1 age
local ivars1 educ_hs_ind medicaid fin_strain 
local catvars1 income_quart 
***insert poverty thresh variable 
local cvars2
local ivars2 female married 
local catvars2  race3
local cvars3 adl_index iadl_index
local ivars3 sr_phq2_depressed  proxy_ivw
local catvars3 
local cvars4 sr_numcondit
local ivars4  
local catvars4 comorbid 
local cvars5 
local ivars5 ind_paid_helper livealone
local catvars5
local cvars6 n_children n_helpers
local ivars6 
local catvars6  nhelpers3 
local cvars7 tot_hrswk_help_i
local ivars7 
local catvars7 hrs_help_3cat
local cvars8 
local ivars8 rcfres metro_ind moved_last_5 moved_count cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars8 
*hb vars: hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1    

gen n=1

forvalues i=1/8 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/8 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local part1 `cvars1' `ivars1' `catvars1' `cativars1'
local part2 
forvalues i = 2/8 {
local part2 `part2' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local ncount :  word count 1 1 
local pt1 : word count 1 1 `part1'
di `pt1'

local pt2: word count 1 1 `part2' `part1' 1 
di `pt2'

local rn : word count 1 `rows' 1 1 
di `rn'

local r=1
local c=1
local denom = 941

*****insert incid dem full sample here 
mat tab=J(`rn',4,.)
mat stars=J(`rn',4,0)

**********************
*Sample Population 
svy, subpop(if incid ==1): mean n
mat tab[`r',`c']==e(N_sub)
local r = `r'+1 
mat tab[`r',`c']==e(N_subpop)
local r = `r'-1
svy, subpop(if incid ==1 & hb==0): mean n
mat tab[`r',`c'+1]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+1]==e(N_subpop)
local r = `r'-1
svy, subpop(if incid ==1 & hb==1): mean n
mat tab[`r',`c'+2]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+2]==e(N_subpop)
local r = `r'+1

	foreach x of local cvars1 {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	local r=`r'+1		
}
	foreach x of local ivars1 {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars1 {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}


local r =`ncount'+1
local c = `c'+1

foreach t in 0 1 {
	foreach x of local cvars1 {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+1]=e(p)
			mat stars[`r',`c'+1]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars1 {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+1]= e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars1 {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+1]=e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
	local r=`ncount'+1
	local c=`c'+1
}

local r = `pt1'+1
local c = 1
***
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy, subpop(if incid ==1): mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==0): mean ltpov
mat tab[`r',`c'+1]= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==1): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate: svy: reg ltpov hb
mat tab[`r',`c'+3]=e(p_mi)
mat stars[`r',`c'+3]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

***********************
local r = `pt1'+2
local c = 1 

forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}
}

local r=`pt1'+2
local c = `c'+1

foreach t in 0 1 {
forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+1]=e(p)
			mat stars[`r',`c'+1]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+1]= e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+1]=e(p_Pear)
		mat stars[`r',`c'+1]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
}

	local r=`pt1'+2
	local c=`c'+1
}	

mat rownames tab=  N "Estimated N" `part1' "Poverty Threshold" `part2'   

frmttable using "tab1_incidem_hb_nosd_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort w/ Survey Weights") ctitles("" "Incid Dem Full Sample(%)" "InciDem & non-HB(%)" "InciDem & HB (%)" "P-value") varlabels sdec(2,2,2,2) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group") replace

restore

*Table for wave at incident dementia 
preserve
keep if incident ==1
svyset spid [pw=anfinwgt], strata(varstrat)
mat tab = J(8,4,.)
local r = 1

forvalues i =2/8 {
tab wave`i'_incid if wave`i'_incid ==1
mat tab [`r',1]= r(N)
sum wave`i'_incid
mat tab [`r',2] =r(mean)*100
svy, subpop (if incident ==1 & wave`i'_incid==1) : mean wave`i'_incid
mat tab [`r', 3]= e(N_pop)
svy, subpop (if incident ==1): mean wave`i'_incid
mat tab[`r',4]==e(b)*100
local r = `r'+1
}
gen n = 1
svy, subpop (if incident ==1): mean n
mat tab[`r',1]= e(N)
mat tab [`r', 3]= e(N_pop)

mat rownames tab = "Wave 2" "Wave 3" "Wave 4" "Wave 5" "Wave 6" "Wave 7" "Wave 8" "Total"
frmttable using "tab1_incidem_hb_nosd_`c(current_date)'.rtf", statmat(tab) title("Wave at Incident Dementia") ctitles("" "# of Incident Dementia" "Unweighted %" "Weighted # of Incident Dementia" "Weighted %") varlabels sdec(2,2,2,2) addtable

restore


H="Tab1: Caregivers of SP & Corresponding SP's Tab 1"
*NSOC Caregivers Table 1 & Their SPs Table 1, No Small Cell Sizes
cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

**********************
/* if including CG ivws of  recently deceased SPs of round 7, uncomment this
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\raw\NSOC7.dta", clear
gen wave = 7 
keep spid opid w7cglmlfinwgt* fl7spdied wave 
tempfile nsoc7
save "`nsoc7'", replace

merge 1:1 spid opid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\nsoc_round_1_7.dta", nogen keep(match using) 
replace cgfinwgt= w7cglmlfinwgt0 if fl7spdied==1 & wave==7

merge 1:1 spid opid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_with_nsoc.dta", nogen keep(match using)
*/
************************************
*Exclude CG ivws of recently deceased SPs: 
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\incid_dementia_with_nsoc.dta", clear 
drop if cgfinwgt == 0 

*update flowchart to reflect exclusion of recently deceased 
************************************

svyset opid [pw=cgfinwgt], strata(cgvarstrat)

**Table 1: CG Vars 

preserve
*drop the categorical help variables 
drop help_personal_care  help_get_around  help_shopping  help_chores  
local help 
foreach x of varlist help_*{
local help `help' `x'
}

local cvars1 cg_age
local ivars1 cg_female cg_spouse cg_child cg_gt_hs cg_married cg_living_children cg_lives_with_sp cg_medicare cg_medicaid cg_primary_nsoc cg_phq2_depressed  cg_drive_sp cg_2_hh op_sn  ever_pain ever_high_bp trb_back_sleep_di work_4_pay neg_exhausted_di neg_no_time_di  cg_strain_ind cg_respite
*local catvars1 cg_dist_cat
local cvars2  total_hours total_hours_week //took out total hours b/c no hispanics for cgrace 
local ivars2 `help'

foreach x of local ivars1{
tab `x' cgrace3 if cgconcur ==1
}
foreach x of local ivars2{
tab `x' cgrace3 if cgconcur ==1
}

gen n=1

forvalues i=1/2 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/2 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count `rows' 1 1 
local r=1
local c=1

mat tab=J(`rn',1,.)
mat stars = J(`rn',1,0)

forvalues i=1/2 {
	foreach x of local cvars`i' {
	svy, subpop(if cgconcur==1) : mean `x'
	mat tab[`r',`c']=e(b)
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if cgconcur==1)  : mean `x'
		local out e(b)[1,1]*100 
		sum `x' if cgconcur ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=1
		}
		local r=`r'+1
		
}
	foreach x of local catvars`i' {
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if cgconcur==1)  : mean `z'
		local out e(b)[1,1]*100 
		sum `z' if cgconcur ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=1
		}
			local r=`r'+1
			}
}
}

	svy, subpop(if cgconcur==1): mean n
	mat tab[`r',`c']=e(N_sub)
	mat tab[`r'+1,`c']=e(N_subpop)
	local `r'= `r'+1

mat rownames tab= `rows' "N" "Estimated N"

mat list tab
frmttable using "Caregiver_table1_nsoc_merged_`c(current_date)'.rtf", statmat(tab) title("Table 1: Caregivers (Concurrent with SP's Incident Dementia)") ctitles("" "Incid Dem Full Sample") sdec(2,2) replace varlabels note("Binary Help Variables are Help everyday, most days or some days.") annotate(stars) asymbol(NR)

restore 

*Corresponding SP Table 1 for OPs with NSOC Interviews 
preserve 
set seed 100 
sort spid wave 
*get individ spids for those w/ NSOC ivws 
by spid: egen n =seq() if cgconcur ==1

replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

label var sr_numcondit "# Med Conditions (excl Dementia) - Mean"
*label var length_in_res "Years at Residence - Mean"
label var adl_index "ADL Counts (Continuous)-Mean"
*label var ind_paid_helper "Paid Help Indicator"
label var indep_hb "HB Status: Independent "
label var nhelpers3 "# of Helpers (3 Categories)"

local cvars1 age adl_index
local ivars1 female married educ_hs_ind hb hb_p1 shb indep_hb medicaid sr_phq2_depressed
local catvars1 race3
local ivars2 ind_paid_helper  rcfres livealone metro_ind fin_strain moved_last_5 moved_count proxy_ivw
local catvars2 income_quart 
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 tot_hrswk_help_i
local catvars4  hrs_help_3cat 
local cvars5 sr_numcondit
local catvars5 comorbid 
*local cvars6 length_in_res
*local catvars6 length_in_res_3cat

gen count=1

forvalues i=1/6 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

di "`cativars5'"

local rows
forvalues i=1/6 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows' 1 1 
local r=1
local c=1
*****insert incid dem full sample here 
mat tab=J(`rn',1,.)
mat stars = J(`rn',1,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy, subpop (if n ==1): mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi extract 0 

***********************
local r = 2

forvalues i=1/6 {
	foreach x of local cvars`i' {
	svy, subpop(if n ==1) : mean `x'
	mat tab[`r',`c']=e(b)
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if n ==1) : mean `x'
		local out e(b)[1,1]*100 
		sum `x' if n ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=1
		}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if n ==1): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if n ==1): mean `z'
		local out e(b)[1,1]*100 
		sum `z' if n ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=1
		}
			local r=`r'+1
			}
}
}

	svy, subpop(if n ==1): mean count
	mat tab[`r',`c']= e(N_sub) 
	local r = `r'+1 
	mat tab[`r',`c']=e(N_subpop)

mat rownames tab= "Poverty Threshold"  `rows'  N "Estimated N"

frmttable using "Caregiver_table1_nsoc_merged_`c(current_date)'.rtf", statmat(tab) title("Table 1: SPs with Caregiver Ivws (NSOC)") ctitles("" "Incid Dem Full Sample") sdec(2,2,) addtable varlabels annotate(stars) asymbol(NR)
restore 





H="Full Incid Dem Dataset Set Up ( No NSOC) "
*This runs and produces original 941 incident sample. Use as reference when troubleshooting the temp dataset 
*original table to see differences as setting up 2018 data 
*Incident Dementia Variable Set Up, No NSOC Merge, start with dropping 2015 year sample 
cd "${output}"

import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "${nhats}\sp_round_1_8_public_sens_only.dta", clear
*merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) nogen 

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status
drop if yearsample ==2015
keep if sp_ivw==1 & !missing(prob_dem) 

sort spid wave
*get wave of first time probable dementia is indicated
sort spid 
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 

by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

merge m:1 spid using "${rawdata}\round_1\round_1\NHATS_Round_1_SP_File.dta", keepusing (ht1mthslived ht1yrslived) keep (master match) nogen

forvalues i = 2/8{
merge m:1 spid using "${rawdata}\round_`i'\round_`i'\NHATS_Round_`i'_SP_File.dta", keepusing (fl`i'spdied re`i'spadrsnew   re`i'mthmove re`i'yearmove) keep (master match) nogen
}

*only for 2011 cohort, didn't bring in 2015 residential variable
forvalues i = 2/8{
replace re`i'spadrsnew = 1 if re`i'spadrsnew==3
tab re`i'spadrsnew
}

forvalues i = 2/8{
gen moved`i'_ind = `i' if re`i'spadrsnew==2
}

gen moved_tot = wave if ht1yrslived==-1 & wave ==1 
forvalues i = 2/8{
replace moved_tot= wave if moved`i'_ind ==`i' & wave ==`i'
}
tab moved_tot wave

sort spid wave
by spid: carryforward moved_tot, gen (moved_total)

*get moved in last 5 yrs prior to incident dementia, including yr of dementia 
by spid: gen moved_5yr = wave if firstdem-moved_tot >=0  &  firstdem-moved_tot <=5 & firstdem!=. & moved_tot !=.
gen moved_last_5 = moved_5yr>0 & moved_5yr<.
label var moved_last_5 "Moved in last 5 Years before Incident Dementia"

*dups indicate moving more than once in last 5 yrs 
duplicates report spid if  moved_5yr!=. & firstdem!=.
duplicates tag spid if  moved_5yr!=. & firstdem!=. , gen (moved_dups)

gen moved_count = moved_dups >= 1 & moved_dups < .
tab moved_count
label var moved_count "Moved >1 Time in last 5 Yrs from Incident Dementia" 

/*
*code is for how long 1 lived at address, don't need if using moved var instead 

replace moved_tot = 0 if moved_tot !=. 

gen length_in_res = ht1yrslived if moved_total ==. 
replace length_in_res =. if ht1yrslived==-1
forvalues i = 2/8{
replace length_in_res = ht1yrslived+`i'-1 if wave ==`i' & moved_total ==. & length_in_res != -1 
}

*capture duplicates where there is 1 spid but several opid for same wave 
replace length_in_res = moved_tot if length_in_res ==. 
******
forvalues i = 2/8{
by spid: replace length_in_res = length_in_res[_n-1]+1 if length_in_res ==. & wave==wave[_n-1]+1 & wave==`i'
*by spid: replace length_in_res = length_in_res[_n-1] if length_in_res ==. & wave==wave[_n-1]& wave==`i'
}
******
replace length_in_res = . if ht1yrslived==.
tab length_in_res

gen length_in_res_3cat = 0 if length_in_res>=0 & length_in_res <=10
replace length_in_res_3cat=1 if length_in_res>=11 & length_in_res <=30
replace length_in_res_3cat=2 if length_in_res>=31 & length_in_res <.
tab length_in_res_3cat

label var length_in_res "Years at Residence"
label define length_in_res_3cat 0 "0 - 10 Years" 1 "11-30 Years" 2 "31+ Years "
label val length_in_res_3cat length_in_res_3cat
label var length_in_res_3cat "Years at Residence (3cat)"

*check 

forvalues i = 2/8 {
*tab length_in_res if re`i'spadrsnew==2
tab moved_total length_in_res if re`i'spadrsnew==2
duplicates report if re`i'spadrsnew==2
}
*/

*get wave of first nh resident 
sort spid wave 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
sort spid wave
by spid: gen hbcat_n1=hbcat[_n-1]
*label copy hbcat hbcat_n1 
label define labhbcat_n1 1 "HB@n1" 2 "SHB@n1" 3 "Independent@n1"
label values hbcat_n1 hbcat_n1

*indicator var for separate homebound categories 
sort spid wave
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen shb=hbcat ==2 if !missing(hbcat)
by spid: gen indep_hb =hbcat==3 if !missing(hbcat)
label var hb "Homebound"
label var shb "Semi Homebound"
label var indep_hb "Independent"

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at Prior Wave"

*hb at prior wave
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at Prior Wave"

*indep at prior wave 
gen indep_n1 = hbcat_n1 ==3
label var indep_n1 "Indep at Prior Wave"

*spids in which their incident dementia wave is dropped b/c they are missing hbcat & hbcat_n1
list spid wave incident firstdem  yearsample if spid==10003459 |spid == 10006546 |spid ==10007621  | spid ==10011112 

*drop if missing(hbcat)
*drop if missing(hbcat_n1) & wave > 1
by spid: gen restr_incid= incident==1 & !missing(hbcat) & !missing(hbcat_n1) & wave > 1 //use after dropping those that missed hbcat
by spid: egen obs_incid=max(restr_incid)
*only keeping SP observations who are incident dementia 
*keep if obs_incid==1

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"

*hb at next wave 
by spid: gen hbcat_p1= hbcat[_n+1]
label values hbcat_p1 hbcat

by spid: gen hb_p1 = hbcat_p1 ==1
by spid: gen shb_p1 = hbcat_p1 ==2 
by spid: gen indep_p1 = hbcat_p1 ==3
label define hb_p1 0 "Not Homebound" 1 "HB at P1"
label values hb_p1 hb_p1
label var hb_p1 "HB at Next Wave"
label var shb_p1 "SHB at Next Wave"
label var indep_p1 "Indep at Next Wave"

*comorbidities variable <2, 2-4, 5+
gen sr_numcondit=sr_numconditions1
replace sr_numcondit= sr_numcondit-1 if sr_dementia_ever ==1
replace sr_numcondit= sr_numcondit-1 if sr_phq2_depressed==1
label var sr_numcondit "# of Comorbidities (excl Dementia & Depression), Mean "

gen comorbid = 0 if sr_numcondit <2
replace comorbid = 1 if sr_numcondit >=2 & sr_numcondit<=4
replace comorbid = 2 if sr_numcondit> 4 & sr_numcondit<.
label define comorbid 0 "<2" 1 "2-4" 2 "5+"
label values comorbid comorbid 
label var comorbid "Range of Med Conditions (excl Dementia & Depression)"

gen comorbid5 = comorbid==2
label var comorbid5 "5+ Comorbidities"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
replace race3 = race3-1
tab1 race race3
label define race3 0 "White & Other(Non-Hisp)" 1 "Black(Non-Hisp)" 2"Hispanic"
label values race3 race3
label var race3 "Race"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

label var adl_diff_ind "1 or more ADL difficulty reported"
label var iadl_diff_ind "1 or more IADL difficulty reported"

*total hrs of help  
label var tot_hrswk_help_i "Total hours of help/week, Mean"
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)

/*can break down as <10; 11-40; more than 40 depending on distribution
gen hrs_help_3cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=10
replace hrs_help_3cat = 1 if tot_hrswk_help_i >10 & tot_hrswk_help_i <=40 
replace hrs_help_3cat = 2 if tot_hrswk_help_i >40 & tot_hrswk_help_i<.
label define hrs_help_3cat 0 "0-10 Hrs" 1 ">10 -40 Hrs" 2 ">40 Hrs"
label values hrs_help_3cat hrs_help_3cat
label var  hrs_help_3cat "Total Hrs of Help (3cat)"
tab hrs_help_3cat
*/
*total hrs of help 2cat
gen hrs_help_2cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=40
replace hrs_help_2cat = 1 if tot_hrswk_help_i >40 & tot_hrswk_help_i <.

label define hrs_help_2cat 0 "0-40 Hrs" 1 ">40" 
label values hrs_help_2cat hrs_help_2cat
label var  hrs_help_2cat "Total Hrs of Help (>40 Hrs)"

*financial strain
foreach x in nopayhous nopayutil nopaymed mealskip  {
replace `x'=. if `x'==2
}
replace mealskipnum=. if mealskipnum==5

gen fin_strain=.
replace fin_strain=0 if nopayhous==0 & nopayutil==0 & nopaymed==0 & mealskip==0 
replace fin_strain=1 if nopayhous==1 | nopayutil==1 | nopaymed==1 | mealskip==1
label var fin_strain "Any Financial Strain"

gen any_asst= govtasst
replace any_asst=1 if section8==1
label var any_asst "Reci. any Public Assist. (incl. Gov't assist./Section 8)"

forvalues i = 1/8 {
gen wave`i'_incid=wave ==`i' & incident ==1
tab wave`i'_incid
}

label define yesno_agree 0 "Agree(Little)/Do Not Agree" 1 "Agree(A lot)"

foreach x of varlist cohesion_knowwell cohesion_willing cohesion_peop{
replace `x'=0 if `x'==3 
replace `x'=0 if `x'==2
label values `x' yesno_agree
}

*get follow up time after incident dementia 
*this accounts for skipped waves since they aren't counted. max of (wave-firstdem) will incl. any skipped ivws
by spid: egen followup_dem = total (cond (wave-firstdem > 0), 1, .)
label var followup_dem "# of Waves after Incident Dementia "
sum followup_dem if incid ==1
hist followup_dem if incid ==1, freq

*Num of waves to nursing home, after incident dementia 

gen dem_to_nh = firstnh-firstdem
tab dem_to_nh if incid ==1

/*
*old pie chart that incls hb prior & hb concur to incidem 
gen hbchart = hbcat 
replace hbchart = 0 if hbcat==1 & hb_n1 ==1
tab hbchart if incid ==1

label def hbchart 0 "HB @ Prior Incid & Concur" 1 "Newly HB @ Incid Dem" 2 "SHB" 3 "Indep"
label values hbchart hbchart
label var hbchart "HB Status for Pie Chart"
*/

label var age "Age, Mean"
label var educ_hs ">= High School Education"
label var sr_phq2_depressed "Depression (PHQ-2 positive screen)"
label var proxy_ivw "Interview via Proxy"
label var indep_hb "HB Status: Independent "
label var soc_iso "Socially Isolated"
label var nhelpers3 "# of Helpers (3 Categories)"
label var rcfres "Assisted Living"
label var n_children "Number of Living Children, Mean"
label var n_helpers "Number of Helpers reported by SP, Mean"

/*
*other vars that need to correct labels for. confirm with KO & JR first 
local catvars4 comorbid 
local ivars5 ind_paid_helper livealone
local cvars6 n_children n_helpers
local catvars6  nhelpers3 
local cvars7 tot_hrswk_help_i
local catvars7 hrs_help_3cat
local ivars8  metro_ind cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
*/

*missing obsvn: 
* educ_hs_ind adl_index race3 iadl_index
*check education for these spids before limiting the sample 

*save as diff datasets. (full & incid data set)
save "${intpath}\full_nhats_dem_no_nsoc.dta", replace 

preserve
*create incident dementia dataset 
drop if firstnh<=firstdem | missing(firstdem)
drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
*only keeping SP observations who are incident dementia 
keep if obs_incid==1
save "${intpath}\incid_dementia_no_nsoc.dta", replace 
restore 

*2018 temp data. troubleshoot above first to figure this out & make sure correct. include the 2015 sample in this dataset.
preserve
keep if sp_ivw==1 & !missing(prob_dem) 
*drop if firstnh<=firstdem | missing(firstdem)
*do not drop firstnh<firstdem b/c most in 2015 sample will drop 
drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
codebook spid 
tab wave 
keep if wave ==8 & community_dwelling ==1
tab hbcat 
codebook spid
save "${intpath}\temp_commun_dwell_2018_no_nsoc.dta", replace 
restore


H="Incid Dementia Dataset Set Up (NSOC Merged)"

*Incident Dementia Variable Set Up, No NSOC Merge, start with dropping 2015 year sample 
cd "${output}"

import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "${nhats}\sp_round_1_8_public_sens_only.dta", clear
*merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) nogen 

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status
*drop if yearsample ==2015
*keep if sp_ivw==1 & !missing(prob_dem) 

sort spid wave
*get wave of first time probable dementia is indicated
sort spid 
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 

by spid: gen incident=wave==firstd & wave[_n-1]==wave-1 
label var incident "Incident Dementia"

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\ltss_scorecard_quartiles.dta", keep(master matched) nogen

merge 1:m spid wave using "${nhats}\nsoc_round_1_7.dta", keep (master match) 
*use  C5 D CG RACE AND HISPANIC ETHNICITY variable (cgracehisp) instead of primarace & yourrace vars 
*dropping yourrace vars to avoid confusion 
*CG race is only avail for waves 5 & 7, cg race is not avail for wave 1!!
drop source yourrace1 yourrace2 yourrace3 yourrace4 primarace

merge m:1 spid using "${nhats}\raw\NSOC_Round_5_SP_Tracker_File_V3.dta", keepusing(fl5dnsoc fl5dnsoccomp) keep (master match) nogen 

merge m:1 spid using "${nhats}\raw\NSOC_R7_Crss_SP_Tracker_File.dta", keepusing (fl7dnsoc fl7dnsoccomp)  keep (master match) nogen

merge m:1 spid using "${rawdata}\round_1\round_1\NHATS_Round_1_SP_File.dta", keepusing (ht1mthslived ht1yrslived) keep (master match) nogen

forvalues i = 2/8{
merge m:1 spid using "${rawdata}\round_`i'\round_`i'\NHATS_Round_`i'_SP_File.dta", keepusing (fl`i'spdied re`i'spadrsnew   re`i'mthmove re`i'yearmove) keep (master match) nogen
}

*only for 2011 cohort, didn't bring in 2015 residential variable
forvalues i = 2/8{
replace re`i'spadrsnew = 1 if re`i'spadrsnew==3
tab re`i'spadrsnew
}

forvalues i = 2/8{
gen moved`i'_ind = `i' if re`i'spadrsnew==2
}

gen moved_tot = wave if ht1yrslived==-1 & wave ==1 
forvalues i = 2/8{
replace moved_tot= wave if moved`i'_ind ==`i' & wave ==`i'
}
tab moved_tot wave

sort spid wave
by spid: carryforward moved_tot, gen (moved_total)

*get moved in last 5 yrs prior to incident dementia, including yr of dementia 
by spid: gen moved_5yr = wave if firstdem-moved_tot >=0  &  firstdem-moved_tot <=5 & firstdem!=. & moved_tot !=.
gen moved_last_5 = moved_5yr>0 & moved_5yr<.
label var moved_last_5 "Moved in last 5 Years before Incident Dementia"

*dups indicate moving more than once in last 5 yrs 
duplicates report spid if  moved_5yr!=. & firstdem!=.
duplicates tag spid if  moved_5yr!=. & firstdem!=. , gen (moved_dups)

gen moved_count = moved_dups >= 1 & moved_dups < .
tab moved_count
label var moved_count "Moved >1 Time in last 5 Yrs from Incident Dementia" 

/*
*code is for how long 1 lived at address, don't need if using moved var instead 

replace moved_tot = 0 if moved_tot !=. 

gen length_in_res = ht1yrslived if moved_total ==. 
replace length_in_res =. if ht1yrslived==-1
forvalues i = 2/8{
replace length_in_res = ht1yrslived+`i'-1 if wave ==`i' & moved_total ==. & length_in_res != -1 
}

*capture duplicates where there is 1 spid but several opid for same wave 
replace length_in_res = moved_tot if length_in_res ==. 
******
forvalues i = 2/8{
by spid: replace length_in_res = length_in_res[_n-1]+1 if length_in_res ==. & wave==wave[_n-1]+1 & wave==`i'
*by spid: replace length_in_res = length_in_res[_n-1] if length_in_res ==. & wave==wave[_n-1]& wave==`i'
}
******
replace length_in_res = . if ht1yrslived==.
tab length_in_res

gen length_in_res_3cat = 0 if length_in_res>=0 & length_in_res <=10
replace length_in_res_3cat=1 if length_in_res>=11 & length_in_res <=30
replace length_in_res_3cat=2 if length_in_res>=31 & length_in_res <.
tab length_in_res_3cat

label var length_in_res "Years at Residence"
label define length_in_res_3cat 0 "0 - 10 Years" 1 "11-30 Years" 2 "31+ Years "
label val length_in_res_3cat length_in_res_3cat
label var length_in_res_3cat "Years at Residence (3cat)"

*check 

forvalues i = 2/8 {
*tab length_in_res if re`i'spadrsnew==2
tab moved_total length_in_res if re`i'spadrsnew==2
duplicates report if re`i'spadrsnew==2
}
*/

*get wave of first nh resident 
sort spid wave 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
sort spid wave
by spid: gen hbcat_n1=hbcat[_n-1]
*label copy hbcat hbcat_n1 
label define labhbcat_n1 1 "HB@n1" 2 "SHB@n1" 3 "Independent@n1"
label values hbcat_n1 hbcat_n1

*indicator var for separate homebound categories 
sort spid wave
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen shb=hbcat ==2 if !missing(hbcat)
by spid: gen indep_hb =hbcat==3 if !missing(hbcat)
label var hb "Homebound"
label var shb "Semi Homebound"
label var indep_hb "Independent"

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at Prior Wave"

*hb at prior wave
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at Prior Wave"

*indep at prior wave 
gen indep_n1 = hbcat_n1 ==3
label var indep_n1 "Indep at Prior Wave"

*spids in which their incident dementia wave is dropped b/c they are missing hbcat & hbcat_n1
list spid wave incident firstdem  yearsample if spid==10003459 |spid == 10006546 |spid ==10007621  | spid ==10011112 

*drop if missing(hbcat)
*drop if missing(hbcat_n1) & wave > 1
drop incident 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1 
label var incident "Incident Dementia"

tab incident

by spid: gen restr_incid= incident==1 & !missing(hbcat) & !missing(hbcat_n1) & wave > 1 & yearsample !=2015 & sp_ivw==1 & !missing(prob_dem) //& firstdem > firstnh
//use after dropping those that missed hbcat
by spid: egen obs_incid=max(restr_incid)
 
tab firstdem firstnh if restr_incid==1

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"

*hb at next wave 
by spid: gen hbcat_p1= hbcat[_n+1]
label values hbcat_p1 hbcat

by spid: gen hb_p1 = hbcat_p1 ==1 & lml[_n+1]==0
by spid: gen shb_p1 = hbcat_p1 ==2 & lml[_n+1]==0
by spid: gen indep_p1 = hbcat_p1 ==3 & lml[_n+1]==0
label define hb_p1 0 "Not Homebound" 1 "HB at P1"
label values hb_p1 hb_p1
label var hb_p1 "HB at Next Wave (excl LML)"
label var shb_p1 "SHB at Next Wave (excl LML)"
label var indep_p1 "Indep at Next Wave (excl LML)"

***********


*create next wave status for everyone 
sort spid wave
by spid: gen nwstatus = 1 if indep_p1 ==1
by spid: replace nwstatus = 2 if shb_p1==1 
by spid: replace nwstatus = 3 if hb_p1==1 
by spid: replace nwstatus = 4 if nhres[_n+1]==1
by spid: replace nwstatus = 5 if nhats_died_12==1
by spid: replace nwstatus = 5 if lml_ivw_yes[_n+1]==1 
by spid: replace nwstatus= 6 if missing(nwstatus)

label def nwstatus 1 "Independent" 2 "SHB" 3 "HB" 4 "NH" 5 "Died" 6 "LFU"
label val nwstatus nwstatus
label var nwstatus "Next Wave Status"

*******
*get years to first homebound status after incident dementia 
sort spid wave
gen postincidem = 1 if incident ==1
by spid: carryforward postincidem, replace
tab postincidem, m


*hb waves only after incident dementia & not at lml 
by spid: gen hbwave = wave if hb ==1 & postincidem ==1 & lml ==0 
by spid: egen postdemhb = min(hbwave)
drop hbwave

tab firstnh postdemhb, m
*get the later wave at death, in case some have 2 waves with nhats_died_12 ==1 
by spid: gen dwave = wave if nhats_died_12 & nhats_died_12 !=.
by spid: egen diedwave = max(dwave)

*get last non lml wave for lfu/censored popln 
by spid: egen seq = seq() if lml ==0
by spid: egen nmax = max(seq) 


*years to homebound 
*homebound 
gen yrs_to_hb = postdemhb-firstdem 

**years from incident dementia to failures**
*if  hb/nh/died all in the same wave, died > nh > hb 
*homebound 
gen yrs_to_fail = postdemhb-firstdem
*nursing home
replace yrs_to_fail = firstnh-firstdem if yrs_to_fail ==. //negative yrs will be dropped later 
*died 
replace yrs_to_fail = diedwave-firstdem if yrs_to_fail ==.
*lfu/censored 
replace yrs_to_fail = nmax-firstdem if yrs_to_fail ==. 

*set fails if  hb/nh/died all in the same wave, died > nh > hb (for failures that happen after incident dementia)
gen fail = 0 
replace fail = 1 if postdemhb !=.
replace fail = 2 if firstnh > firstdem & firstnh !=. & firstnh < postdemhb 
replace fail = 3 if diedwave !=. & (diedwave <= firstnh|diedwave<=postdemhb)
tab fail 

*drop vars used to create yrs_to_fail & fail variable 
drop seq nmax postincidem postdemhb dwave diedwave  

*********
*comorbidities variable <2, 2-4, 5+
gen sr_numcondit=sr_numconditions1
replace sr_numcondit= sr_numcondit-1 if sr_dementia_ever ==1
replace sr_numcondit= sr_numcondit-1 if sr_phq2_depressed==1
label var sr_numcondit "# of Comorbidities (excl Dementia & Depression), Mean "

gen comorbid = 0 if sr_numcondit <2
replace comorbid = 1 if sr_numcondit >=2 & sr_numcondit<=4
replace comorbid = 2 if sr_numcondit> 4 & sr_numcondit<.
label define comorbid 0 "<2" 1 "2-4" 2 "5+"
label values comorbid comorbid 
label var comorbid "Range of Med Conditions (excl Dementia & Depression)"

gen comorbid5 = comorbid==2
label var comorbid5 "5+ Comorbidities"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
replace race3 = race3-1
tab1 race race3
label define race3 0 "White & Other(Non-Hisp)" 1 "Black(Non-Hisp)" 2"Hispanic"
label values race3 race3
label var race3 "Race"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

label var adl_diff_ind "1 or more ADL difficulty reported"
label var iadl_diff_ind "1 or more IADL difficulty reported"

gen adl_dep =0 if adl_independent==1|adl_independent ==. 
replace adl_dep = 1 if adl_independent ==0
label var adl_dep "ADL Help Dependent (1 or more ADL help reported)"

gen iadl_dep =0 if iadl_independent==1|iadl_independent ==.
replace iadl_dep = 1 if iadl_independent ==0
label var iadl_dep "IADL Help Dependent (1 or more IADL help reported)"


*total hrs of help  
label var tot_hrswk_help_i "Total hours of help/week, Mean"
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)

/*can break down as <10; 11-40; more than 40 depending on distribution
gen hrs_help_3cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=10
replace hrs_help_3cat = 1 if tot_hrswk_help_i >10 & tot_hrswk_help_i <=40 
replace hrs_help_3cat = 2 if tot_hrswk_help_i >40 & tot_hrswk_help_i<.
label define hrs_help_3cat 0 "0-10 Hrs" 1 ">10 -40 Hrs" 2 ">40 Hrs"
label values hrs_help_3cat hrs_help_3cat
label var  hrs_help_3cat "Total Hrs of Help (3cat)"
tab hrs_help_3cat
*/
*total hrs of help 2cat
gen hrs_help_2cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<40
replace hrs_help_2cat = 1 if tot_hrswk_help_i >=40 & tot_hrswk_help_i <.

label define hrs_help_2cat 0 "0-40 Hrs" 1 ">=40 Hrs" 
label values hrs_help_2cat hrs_help_2cat
label var  hrs_help_2cat "Total Hrs of Help (>=40 Hrs)"

*financial strain
foreach x in nopayhous nopayutil nopaymed mealskip  {
replace `x'=. if `x'==2
}
replace mealskipnum=. if mealskipnum==5

gen fin_strain=.
replace fin_strain=0 if nopayhous==0 & nopayutil==0 & nopaymed==0 & mealskip==0 
replace fin_strain=1 if nopayhous==1 | nopayutil==1 | nopaymed==1 | mealskip==1
label var fin_strain "Any Financial Strain"

gen any_asst= govtasst
replace any_asst=1 if section8==1
label var any_asst "Reci. any Public Assist. (incl. Gov't assist./Section 8)"

forvalues i = 1/8 {
gen wave`i'_incid=wave ==`i' & incident ==1
tab wave`i'_incid
}

label define yesno_agree 0 "Agree(Little)/Do Not Agree" 1 "Agree(A lot)"

foreach x of varlist cohesion_knowwell cohesion_willing cohesion_peop{
replace `x'=0 if `x'==3 
replace `x'=0 if `x'==2
label values `x' yesno_agree
}

*get follow up time after incident dementia 
*this accounts for skipped waves since they aren't counted. max of (wave-firstdem) will incl. any skipped ivws
by spid: egen followup_dem = total (cond (wave-firstdem > 0), 1, .)
label var followup_dem "# of Waves after Incident Dementia "
sum followup_dem if incid ==1
hist followup_dem if incid ==1, freq

*Num of waves to nursing home, after incident dementia 

gen dem_to_nh = firstnh-firstdem
tab dem_to_nh if incid ==1

*ltss overall rank var - get lowest & highest 
tab overallrankquart, gen(overallrankquart_ltss) 
rename overallrankquart_ltss1 low_quart_overall_ltss
label var low_quart_overall_ltss "Lowest Quart of overallrankquart_ltss"
rename overallrankquart_ltss4 high_quart_overall_ltss
label var high_quart_overall_ltss "Highest Quart of overallrankquart_ltss"

label def overallrankquart 1 "Bottom" 2 "Second" 3 "Third" 4 "Top"
label val overallrankquart overallrankquart 
label var overallrankquart "4 quantiles of overall rank ltss scorecard"


/*
*ltss variables - getting those in highest & lowest quartile of each ltss variable 
**cannot print/share on table 1 bc of complimentary disclosure 

local ltss affordabilityandaccessquart choiceofsettingandproviderquart qualityoflifeandqualityofcquart supportforfamilycaregiversquart effectivetransitionsquart overallrankquart 

foreach x of local ltss{
tab `x', gen(`x')
}

foreach x of local ltss{
rename `x'1 l`x'
label var l`x' "Lowest Quart of `x'"
rename `x'4 h`x'
label var h`x' "Highest Quart of `x'"
}
*/

/*
*old pie chart that incls hb prior & hb concur to incidem 
gen hbchart = hbcat 
replace hbchart = 0 if hbcat==1 & hb_n1 ==1
tab hbchart if incid ==1

label def hbchart 0 "HB @ Prior Incid & Concur" 1 "Newly HB @ Incid Dem" 2 "SHB" 3 "Indep"
label values hbchart hbchart
label var hbchart "HB Status for Pie Chart"
*/

label var age "Age, Mean"
label var educ_hs ">= High School Education"
label var sr_phq2_depressed "Depression (PHQ-2 positive screen)"
label var proxy_ivw "Interview via Proxy"
label var indep_hb "HB Status: Independent "
label var soc_iso "Socially Isolated"
label var nhelpers3 "# of Helpers (3 Categories)"
label var rcfres "Assisted Living"
label var n_children "Number of Living Children, Mean"
label var n_helpers "Number of Helpers reported by SP, Mean"
label var adl_diff_ind "1 or more ADL difficulty reported"
label var iadl_diff_ind "1 or more IADL difficulty reported"


egen cg_strain=rowtotal(*_lv* neg*)
gen cg_strain_ind=inrange(cg_strain,5,9)
label var cg_strain_ind "Caregiver strain 5+"
label var cg_strain "Caregiver strain"

gen cg_married = 1 if cg_marital_status==1
replace cg_married =0 if cg_marital_status!=1 & !missing(cg_marital_status)
label var cg_married "Caregiver Married"

sum cg_total_in_hh, d 
gen cg_2_hh = 1 if cg_total_in_hh>=0 & cg_total_in_hh <=2
replace cg_2_hh =0 if !missing(cg_total_in_hh) & cg_total_in_hh> 2
*tab cg_2_hh cgconcur
label var cg_2_hh "0-2 People in Caregiver Household"

gen cg_child =1 if cg_relationship_cat==2 
replace cg_child =0 if cg_relationship_cat!=2 & !missing(cg_relationship_cat)
label var cg_child "Caregiver is Child/In-law Child/Step Child"

label var cg_primary_nsoc "Primary caregiver, based off most hours"

******UPDATE: CAREGIVING variables************
*get unique num of cgs*
tostring spid, gen (spid_str)
egen spopid_str = concat(spid_str opid) if opid !=""
duplicates report spopid
bysort spopid: gen spopcount = _n if opid !=""
gen cg_count = spopcount==1

rename eligible_nsoc elig_r1_nsoc 
gen elig_r5_nsoc=fl5dnsoc==1
gen elig_r7_nsoc =fl7dnsoc ==1

gen comp_r1_nsoc = completed_nsoc
gen comp_r5_nsoc = fl5dnsoccomp>0 if fl5dnsoccomp!=.
gen comp_r7_nsoc = fl7dnsoccomp>0 if fl7dnsoccomp!=.

*see # of ppl with eligible & completed nsoc among incident dementia 
tab elig_r1 comp_r1 if incid ==1 & wave ==1 
tab elig_r5 comp_r5 if incid ==1 & wave ==5 
tab elig_r7 comp_r7 if incid ==1 & wave ==7 

gen informal_cg_help =n_helpers-n_paid_helpers
tab informal_cg_help
codebook spid if informal_cg_hel>0

gen cg_around=1 if firstdem==wave|wave ==firstdem-1|wave==firstdem+1

*******CG: Informal Care Eligible ****
*Informal Care: NSOC before incident dementia
sort spid wave
by spid: gen cg_pre_informal = informal_cg_help if firstdem ==wave+1 
codebook spid if cg_pre_informal > 0 & cg_pre_informal <. 

*Informal Care: Concurrent NSOC and incident dementia
by spid: gen cg_same_informal =informal_cg_help if firstdem==wave
codebook spid if cg_same_informal!=. & cg_same_informal >0

*Informal Care: NSOC after Incident Dementia 
by spid: gen cg_aft_informal = informal_cg_help if firstdem==wave-1 
codebook spid if cg_aft_informal!=. & cg_aft_informal >0

codebook spid if cg_around ==1 & informal_cg_help!=.& informal_cg_help >0
*/
*****CG: NSOC Eligible ****
sort spid wave
*NSOC Interview Before Incident Dementia
codebook spid if wave ==2 & elig_r1 ==1 & incident==1
codebook spid if wave ==6 & elig_r5 ==1 & incident ==1
codebook spid if wave == 8 & elig_r7 ==1 & incident ==1 

*NSOC Interview is Concurrent with Incident Dementia 
codebook spid if wave==5 & elig_r5==1 & incident ==1
codebook spid if wave==7 & elig_r7==1 & incident ==1
*gen eligsamewave5 = 1 if wave==5 & elig_r5==1 & incident ==1
*codebook spid if eligsamewave5==1
*gen eligsamewave7 = 1 if wave==7 & elig_r7==1 & incident ==1

*NSOC Interview is After Incident Dementia (incident dementia at wave 4 & nsoc is wave 5)
codebook spid if wave ==4 & elig_r5 ==1 & incident ==1 
codebook spid if wave ==6 & elig_r7 ==1 & incident ==1 


*NSOC Eligible: Prior/Concur/After Incident Dementia 
codebook spid if wave ==2 & elig_r1 ==1 & incident==1
codebook spid if wave ==6 & elig_r5 ==1 & incident ==1|wave==5 & elig_r5==1 & incident ==1|wave ==4 & elig_r5 ==1 & incident ==1 
codebook spid if wave == 8 & elig_r7 ==1 & incident ==1 |wave==7 & elig_r7==1 & incident ==1|wave ==6 & elig_r7 ==1 & incident ==1 

*****CG: NSOC Complete****
*get observations OPIDS that are concurrent with incident dementia 
gen cgconcur = 1 if (wave ==5 & comp_r5 ==1 & incident ==1) |( wave == 7 & comp_r7 ==1 & incident ==1)
label var cgconcur "CG's NSOC Concurrent w/ Incid Dem Wave"
tab opid cgconcur

*NSOC Completed Prior to Incident Dementia 
codebook spid if wave ==2 & comp_r1 ==1 & incident ==1 
codebook spid if wave ==6 & comp_r5 ==1 & incident ==1 
codebook spid if wave == 8 & comp_r7 ==1 & incident ==1
**total unique spids in "nsoc prior to ID"
codebook spid if wave ==2 & comp_r1 ==1 & incident ==1 |wave ==6 & comp_r5 ==1 & incident ==1 | wave == 8 & comp_r7 ==1 & incident ==1

*NSOC Completed Concurrent to Incident Dementia 
codebook spid if wave ==5 & comp_r5 ==1 & incident ==1 
codebook spid if wave == 7 & comp_r7 ==1 & incident ==1
**total unique spids in nsoc completed concur to incid dem 
codebook spid if wave ==5 & comp_r5 ==1 & incident ==1 | wave == 7 & comp_r7 ==1 & incident ==1

*NSOC Completed After to Incident Dementia 
codebook spid if wave ==4 & comp_r5 ==1 & incident ==1 
codebook spid if wave ==6 & comp_r7 ==1 & incident ==1
**total unique spids in nsoc completed after incid dem 
codebook spid if wave ==4 & comp_r5 ==1 & incident ==1 | wave ==6 & comp_r7 ==1 & incident ==1

*NSOC Completed: Prior/Concur/After Incident Dementia 
codebook spid if wave ==2 & comp_r1 ==1 & incident ==1 
codebook spid if wave ==6 & comp_r5 ==1 & incident ==1 | wave ==5 & comp_r5 ==1 & incident ==1 | wave ==4 & comp_r5 ==1 & incident ==1 
codebook spid if wave == 8 & comp_r7 ==1 & incident ==1| wave == 7 & comp_r7 ==1 & incident ==1|wave ==6 & comp_r7 ==1 & incident ==1


******CG:Num of NSOC Ivws*******
*Num of NSOC Completed Prior to Incident Dementia 
gen nsoc_pre = 1 if firstdem == wave+1
tab wave nsoc_pre if opid !=""
*Num of NSOC concurrent to Incident Dementia 
tab opid if firstdem ==wave 

*Num of NOSC after incident Dementia 
gen nsoc_aft =1 if firstdem ==wave-1
tab wave nsoc_aft if opid !=""

tab opid if nsoc_pre==1&opid !=""|firstdem ==wave|nsoc_aft==1 & opid!=""


***type of caregiver at incid dementia
tab cg_relationship_cat wave if firstdem ==wave
*num of spid w/ cg_relationship 
codebook spid if cg_relationship_cat==1 & firstdem==wave
codebook spid if cg_relationship_cat==2 & firstdem==wave
codebook spid if cg_relationship_cat==3 & firstdem==wave

*as a check to make sure incid dementia sample remains the same 

preserve
*create incident dementia dataset 
*codebook commands are used to get sample derivations 
drop if yearsample ==2015
*codebook spid if community_dwelling ==1
keep if sp_ivw==1 & !missing(prob_dem) 
*codebook spid if community_dwelling ==1
*codebook spid if incid ==1
drop if firstnh<=firstdem | missing(firstdem)
*codebook spid if incid ==1
drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
*only keeping SP observations who are incident dementia 
*codebook spid if incid ==1
keep if obs_incid==1
codebook spid if incid ==1
restore 





*********************Below for NSOC Is MISC.******
*checks the pre, same, and afterdem 
tab firstdem wave if _merge ==3

**FIGURE OUT CG LIVING W/ SP VAR. PERCENTS INCLUDE ALL OBSVNS 
replace cg_lives_with_sp=cg_dist_cat==1 
*replace cg_lives_with_sp
tab cg_lives_with_sp
tab cg_dist_cat 

*missing obsvn: 
* educ_hs_ind adl_index race3
*check education for these spids before limiting the sample 

save "${intpath}\incid_dementia_with_nsoc.dta", replace 


H="Tab 1:Incid Dementia & HB, Incls Std Dev "
*Incident Dementia Table 1, Full Sample & Incid Homebound: including standard deviations 
use "${intpath}\incid_dementia_no_nsoc.dta", clear
cd "${output}"

*tab moved_last_5 res_care if incid ==1
*Figure 1 
*graph pie if incid ==1 [pw=anfinwgt], over(hbchart) plabel(_all percent)
graph bar [aweight = anfinwgt] if incident==1, over(homebound) asyvars blabel(bar, position(center)) ytitle(%) title(% HB Status at Incident Dementia)
	
set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 

/* 
*Old Table Order 
local cvars1 age adl_index iadl_index n_children
local ivars1 female married educ_hs_ind hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1 medicaid sr_phq2_depressed
local catvars1 race3
local ivars2 ind_paid_helper  rcfres livealone metro_ind fin_strain moved_last_5 moved_count proxy_ivw
local catvars2 income_quart 
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 tot_hrswk_help_i
local catvars4  hrs_help_3cat 
local cvars5 sr_numcondit
local catvars5 comorbid 
*local cvars6 length_in_res
*local catvars6 length_in_res_3cat
*/

*New Order of Vars for Table 
local cvars1 age
local ivars1 educ_hs_ind medicaid fin_strain 
local catvars1 income_quart 
***insert poverty thresh variable 
local cvars2
local ivars2 female married 
local catvars2  race3
local cvars3 
local ivars3 adl_diff_ind iadl_diff_ind sr_phq2_depressed  proxy_ivw
local catvars3 
local cvars4 sr_numcondit
local ivars4  
local catvars4 
local cvars5 
local ivars5 ind_paid_helper soc_iso livealone
local catvars5
local cvars6 n_children n_helpers
local ivars6 
local catvars6  
local cvars7 tot_hrswk_help_i
local ivars7 hrs_help_2cat
local catvars7 
local cvars8 
local ivars8 rcfres metro_ind moved_last_5 moved_count cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars8 
*hb vars: hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1    

gen n=1

forvalues i=1/8 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/8 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local part1 `cvars1' `ivars1' `catvars1' `cativars1'
local part2 
forvalues i = 2/8 {
local part2 `part2' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local ncount :  word count 1 1 
local pt1 : word count 1 1 `part1'
di `pt1'

local pt2: word count 1 1 `part2' `part1' 1 
di `pt2'

local rn : word count 1 `rows' 1 1 
di `rn'

local r=1
local c=1
local denom = 941

*****insert incid dem full sample here 
mat tab=J(`rn',7,.)
mat stars=J(`rn',7,0)

**********************
*Sample Population 
svy, subpop(if incid ==1): mean n
mat tab[`r',`c']==e(N_sub)
local r = `r'+1 
mat tab[`r',`c']==e(N_subpop)
local r = `r'-1
svy, subpop(if incid ==1 & hb==0): mean n
mat tab[`r',`c'+2]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+2]==e(N_subpop)
local r = `r'-1
svy, subpop(if incid ==1 & hb==1): mean n
mat tab[`r',`c'+4]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+4]==e(N_subpop)
local r = `r'+1

	foreach x of local cvars1 {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars1 {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars1 {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}


local r =`ncount'+1
local c = `c'+2

foreach t in 0 1 {
	foreach x of local cvars1 {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars1 {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars1 {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
	local r=`ncount'+1
	local c=`c'+2
}

local r = `pt1'+1
local c = 1
***
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy, subpop(if incid ==1): mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==0): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==1): mean ltpov
mat tab[`r',`c'+4]= e(b_mi)*100
mi estimate: svy: reg ltpov hb
mat tab[`r',`c'+6]=e(p_mi)
mat stars[`r',`c'+6]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

***********************
local r = `pt1'+2
local c = 1 

forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}
}

local r=`pt1'+2
local c = `c'+2

foreach t in 0 1 {
forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
}

	local r=`pt1'+2
	local c=`c'+2
}	

mat rownames tab=  N "Estimated N" `part1' "Poverty Threshold" `part2'   

frmttable using "tab1_incidem_hb_sd_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort w/ Survey Weights") ctitles("" "Incid Dem Full Sample" "SD" "InciDem & non-HB" "SD" "InciDem & HB" "SD" "P-value") varlabels sdec(2,2,2,2) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group" "Missing ADL & IADL is categorized as No ADL/IADL") replace

restore

*Table for wave at incident dementia 
preserve
keep if incident ==1
svyset spid [pw=anfinwgt], strata(varstrat)
mat tab = J(8,4,.)
local r = 1


forvalues i =2/8 {
tab wave`i'_incid if wave`i'_incid ==1
mat tab [`r',1]= r(N)
sum wave`i'_incid
mat tab [`r',2] =r(mean)*100
svy, subpop (if incident ==1 & wave`i'_incid==1) : mean wave`i'_incid
mat tab [`r', 3]= e(N_pop)
svy, subpop (if incident ==1): mean wave`i'_incid
mat tab[`r',4]==e(b)*100
local r = `r'+1
}
gen n = 1
svy, subpop (if incident ==1): mean n
mat tab[`r',1]= e(N)
mat tab [`r', 3]= e(N_pop)

mat rownames tab = "Wave 2" "Wave 3" "Wave 4" "Wave 5" "Wave 6" "Wave 7" "Wave 8" "Total"
frmttable using "tab1_incidem_hb_sd_`c(current_date)'.rtf", statmat(tab) title("Wave at Incident Dementia") ctitles("" "# of Incident Dementia" "Unweighted %" "Weighted # of Incident Dementia" "Weighted %") varlabels sdec(2,2,2,2) addtable

restore


H="Incid Dementia Logit Models (by SPID, No NSOC Merge)"
*Incid Dementia Logit Tables w/o Merging NSOC 

cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
set seed 100 
sort spid wave

/*get num in missing vars: how N went from 939 incid to 929 in this logit model 
gen miss_hs_race_ind = 1 if race3==. & educ_hs==.
tab miss_hs_race miss_adl_ind if incid ==1, m
tab race3 educ_hs_ind if incid ==1,m
*/
*Missing from logit: 6 SPs missing both race & hs educ indicator, 3 SPs missing race, 1 SP missing educ_hs

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)
label var ltpov "Poverty Threshold"
forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

****Current Logit Model**********
preserve
outreg, clear 
keep if incident ==1
local origvars age i.race3 female educ_hs_ind adl_diff_ind iadl_diff_ind rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss

mi estimate, or:svy, subpop(if incident==1): logit hb `origvars' 
mi estimate, post 
*mi estimate, or post

outreg using "Incidem Logit_weight_mi_`c(current_date)'.rtf", stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") note("OR is displayed. Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers. 10 Observations dropped due to missing variables. Missing ADL & IADL is categorized as No ADL/IADL") replace

restore

*Among those with incident dementia, people who are Hispanic have ## times the odds of being homebound compared to those who are not Hispanic 
*Among those who are incident dementia and Black, people with 5+ comorbidities have ## times the odds of being homebound compared to those with less than 2 comorbidities  




H="2018 Commun Dwelling Data Set Up (Back Up)"
**2018 Community Dwelling Comparison Sample 
*Variable Set Up, No NSOC Merge, start with dropping 2015 year sample 
cd "${output}"

import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "${nhats}\sp_round_1_8_public_sens_only.dta", clear

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) nogen 

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status
drop if yearsample ==2015
keep if sp_ivw==1 & !missing(prob_dem) 

sort spid wave
*get wave of first time probable dementia is indicated
sort spid 
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 

by spid: gen incident=wave==firstd & wave[_n-1]==wave-1
label var incident "Incident Dementia"

merge m:1 spid using "${rawdata}\round_1\round_1\NHATS_Round_1_SP_File.dta", keepusing (ht1mthslived ht1yrslived) keep (master match) nogen

forvalues i = 2/8{
merge m:1 spid using "${rawdata}\round_`i'\round_`i'\NHATS_Round_`i'_SP_File.dta", keepusing (fl`i'spdied re`i'spadrsnew   re`i'mthmove re`i'yearmove) keep (master match) nogen
}

*only for 2011 cohort, didn't bring in 2015 residential variable
forvalues i = 2/8{
replace re`i'spadrsnew = 1 if re`i'spadrsnew==3
tab re`i'spadrsnew
}

forvalues i = 2/8{
gen moved`i'_ind = `i' if re`i'spadrsnew==2
}

gen moved_tot = wave if ht1yrslived==-1 & wave ==1 
forvalues i = 2/8{
replace moved_tot= wave if moved`i'_ind ==`i' & wave ==`i'
}
tab moved_tot wave

sort spid wave
by spid: carryforward moved_tot, gen (moved_total)

*get moved in last 5 yrs prior to incident dementia, including yr of dementia 
by spid: gen moved_5yr = wave if firstdem-moved_tot >=0  &  firstdem-moved_tot <=5 & firstdem!=. & moved_tot !=.
gen moved_last_5 = moved_5yr>0 & moved_5yr<.
label var moved_last_5 "Moved in last 5 Years before Incident Dementia"

*dups indicate moving more than once in last 5 yrs 
duplicates report spid if  moved_5yr!=. & firstdem!=.
duplicates tag spid if  moved_5yr!=. & firstdem!=. , gen (moved_dups)

gen moved_count = moved_dups >= 1 & moved_dups < .
tab moved_count
label var moved_count "Moved >1 Time in last 5 Yrs from Incident Dementia" 

*get wave of first nh resident 
sort spid wave 
by spid: egen firstnh=min(cond(nhres==1),wave,.)

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
sort spid wave
by spid: gen hbcat_n1=hbcat[_n-1]
*label copy hbcat hbcat_n1 
label define labhbcat_n1 1 "HB@n1" 2 "SHB@n1" 3 "Independent@n1"
label values hbcat_n1 hbcat_n1

*indicator var for separate homebound categories 
sort spid wave
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen shb=hbcat ==2 if !missing(hbcat)
by spid: gen indep_hb =hbcat==3 if !missing(hbcat)
label var hb "Homebound"
label var shb "Semi Homebound"
label var indep_hb "Independent"

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at Prior Wave"

*hb at prior wave
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at Prior Wave"

*indep at prior wave 
gen indep_n1 = hbcat_n1 ==3
label var indep_n1 "Indep at Prior Wave"

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"

*hb at next wave 
by spid: gen hbcat_p1= hbcat[_n+1]
label values hbcat_p1 hbcat

by spid: gen hb_p1 = hbcat_p1 ==1
by spid: gen shb_p1 = hbcat_p1 ==2 
by spid: gen indep_p1 = hbcat_p1 ==3
label define hb_p1 0 "Not Homebound" 1 "HB at P1"
label values hb_p1 hb_p1
label var hb_p1 "HB at Next Wave"
label var shb_p1 "SHB at Next Wave"
label var indep_p1 "Indep at Next Wave"

*comorbidities variable <2, 2-4, 5+
gen sr_numcondit=sr_numconditions1
replace sr_numcondit= sr_numcondit-1 if sr_dementia_ever ==1
replace sr_numcondit= sr_numcondit-1 if sr_phq2_depressed==1
label var sr_numcondit "# of Comorbidities (excl Dementia & Depression), Mean "

gen comorbid = 0 if sr_numcondit <2
replace comorbid = 1 if sr_numcondit >=2 & sr_numcondit<=4
replace comorbid = 2 if sr_numcondit> 4 & sr_numcondit<.
label define comorbid 0 "<2" 1 "2-4" 2 "5+"
label values comorbid comorbid 
label var comorbid "Range of Med Conditions (excl Dementia & Depression)"

gen comorbid5 = comorbid==2
label var comorbid5 "5+ Comorbidities"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
replace race3 = race3-1
tab1 race race3
label define race3 0 "White & Other(Non-Hisp)" 1 "Black(Non-Hisp)" 2"Hispanic"
label values race3 race3
label var race3 "Race"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

label var adl_diff_ind "1 or more ADL difficulty reported"
label var iadl_diff_ind "1 or more IADL difficulty reported"

*total hrs of help  
label var tot_hrswk_help_i "Total hours of help/week, Mean"
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)

gen hrs_help_2cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=40
replace hrs_help_2cat = 1 if tot_hrswk_help_i >40 & tot_hrswk_help_i <.

label define hrs_help_2cat 0 "0-40 Hrs" 1 ">40" 
label values hrs_help_2cat hrs_help_2cat
label var  hrs_help_2cat "Total Hrs of Help (>40 Hrs)"

*financial strain
foreach x in nopayhous nopayutil nopaymed mealskip  {
replace `x'=. if `x'==2
}
replace mealskipnum=. if mealskipnum==5

gen fin_strain=.
replace fin_strain=0 if nopayhous==0 & nopayutil==0 & nopaymed==0 & mealskip==0 
replace fin_strain=1 if nopayhous==1 | nopayutil==1 | nopaymed==1 | mealskip==1
label var fin_strain "Any Financial Strain"

gen any_asst= govtasst
replace any_asst=1 if section8==1
label var any_asst "Reci. any Public Assist. (incl. Gov't assist./Section 8)"

forvalues i = 1/8 {
gen wave`i'_incid=wave ==`i' & incident ==1
tab wave`i'_incid
}

label define yesno_agree 0 "Agree(Little)/Do Not Agree" 1 "Agree(A lot)"

foreach x of varlist cohesion_knowwell cohesion_willing cohesion_peop{
replace `x'=0 if `x'==3 
replace `x'=0 if `x'==2
label values `x' yesno_agree
}

*get follow up time after incident dementia 
*this accounts for skipped waves since they aren't counted. max of (wave-firstdem) will incl. any skipped ivws
by spid: egen followup_dem = total (cond (wave-firstdem > 0), 1, .)
label var followup_dem "# of Waves after Incident Dementia "
sum followup_dem if incid ==1
hist followup_dem if incid ==1, freq

*Num of waves to nursing home, after incident dementia 

gen dem_to_nh = firstnh-firstdem
tab dem_to_nh if incid ==1

label var age "Age, Mean"
label var educ_hs ">= High School Education"
label var sr_phq2_depressed "Depression (PHQ-2 positive screen)"
label var proxy_ivw "Interview via Proxy"
label var indep_hb "HB Status: Independent "
label var soc_iso "Socially Isolated"
label var nhelpers3 "# of Helpers (3 Categories)"
label var rcfres "Assisted Living"
label var n_children "Number of Living Children, Mean"
label var n_helpers "Number of Helpers reported by SP, Mean"

gen sample = wave ==8 & community_dwelling ==1
codebook spid if sample ==1

save "${intpath}\commun_dwell_2018_no_nsoc.dta", replace 


H="Old KM & Competing Risk Versions for Troubleshooting"
*old versions of competing risks, unwgtd/wgtd 

cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear

outreg, clear
gen lowincquart= income_quart==1

keep if incident ==1

local origvars age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss

*using unweighted numbers 
stset yrs_to_fail, failure(fail==1) 

*sts graph, lost
sts graph,  title("Survival Time (Unweighted)")

sts test yrs_to_fail
sts list 
*sts list, by (fail)


*signif vars when on their own: depression iadl_dep, adl_dep, hispanic 

*demographic vars + signif vars 
stcrreg age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep, compete (fail = 2 3)
outreg using "incidem_compet_risks_`c(current_date)'.rtf", replace varlabels stats(e_b e_ci p) title("Unweighted Competing Risk Models")
estat ic

*income & povery variables 
local demovars1 age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss
local demovars2 age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep lowincquart

*demographic vars, and then with depression & ltss variable 
forvalues i = 1/2{
stcrreg `demovars`i'', compete(fail==2 3) 
outreg using "incidem_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci p) 
estat ic
}

outreg, clear 


***using weighted numbers 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

stset  yrs_to_fail  [pw=anfinwgt], failure(fail==1) 

sts graph, title ("Survival Time (Weighted)") 
sts test yrs_to_fail
sts list

*demographic vars + signif vars 
stcrreg age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep, compete (fail = 2 3)
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", replace varlabels stats(e_b e_ci p) title("Weighted Competing Risk Models")

*income & povery variables 
local demovars1 age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss
local demovars2 age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss lowincquart

*demographic vars, and then with depression & ltss variable 
forvalues i = 1/2{
stcrreg `demovars`i'', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci p) 
estat ic
}


*outreg for missing imputation below messes all of the outreg from above.


cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
outreg, clear
***below is KM & Competing Risk Models that use multiple imputation for Poverty Variable***
set seed 100 
sort spid wave


*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty & income imputation set up 
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen test = income_quart==1 

gen incquart = income_quart if imputed_inc1==aveincome 

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh if !missing(poverty_thresh)
}

tempfile t1 
save `t1'

//bring in the imputations
mi import wide, imputed(incquart = income_quart1 income_quart2 income_quart3 income_quart4 income_quart5 ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

mi xeq: gen lowest_incquart = incquart==1
mi register regular lowest_incquart 

mi estimate: proportion ltpov
tab ltpov, m
****Current Logit Model**********
preserve

keep if incident ==1

local demovars1  age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss ltpov 

local demovars2  age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss lowest_incquart 

*using unweighted numbers 
mi stset yrs_to_fail, failure(fail==1) 

*sts graph, lost
*sts graph

sts test yrs_to_fail
sts list 
sts list, by (fail)


mi estimate, hr post:  stcrreg `demovars1', compete(fail==2 3) 
*outreg using "incidem_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

*mi estimate, hr: stcrreg ltpov, compete(fail ==2 3 )


*using weighted numbers 
mi stset  yrs_to_fail  [pw=anfinwgt], failure(fail==1) 
mi estimate, hr post:  stcrreg `demovars1', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", replace varlabels stats(e_b e_ci) 

mi estimate, hr post:  stcrreg `demovars2', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

stcrreg `demovars2', compete(fail==2 3)
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

*stcrreg `origvars', compete(fail==2 3) 

*probability of not being having failure at year 1 is 0.9
*have 2.5 times hazards of having the event 
************************************************************************/

*****************************************************************************
*hb & income code for reference
cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear

*replace anfinwgt = an2011wgt if wave >=5 & wave <.
*svyset spid [pw=anfinwgt], strata(varstrat)
tab obs_inci

*In the year after new dementia onset, how many non-homebound individuals become homebound?
*a.	proportion who become homebound (may need to limit sample since we may not have follow up data on group for 1 and 2 above), die, NH by N+1 year
tab nwstatus if hb ==0 & incid ==1 


* confirm died num ppl who die within 12 mos of incid dem 
tab nhats_died_12 if incid ==1 & hb ==0
*confirm w/ Evan if nhats_died_12 is ok to use (used in hb_income paper) 

**discrepancy with nhats died (nhats_died_12 is indicated at two waves for same person)
list spid wave firstnh firstdem incid nhats_died_12 if spid ==10000024 | spid ==10009489


*b.	model factors associated with becoming homebound N+1 year
*run table 1 on these 
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
keep if incid ==1 
gen hbnwstat= nwstatus==3
logit hbnwstat age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss




*4)	Examining time to homebound status
**need to confirm: is time to homebound status from incident dementia? 
*get time between dementia to homebound, after incident dementia is identified. 

*competing risk regression:  stcrreg [indepvars] [if] [in], compete(crvar[==numlist]) [options]




*a.	Kaplan meier-  median time to homebound status (censor death, LFU, NH)
keep if incident ==1 

stset yrs_to_fail, failure(fail==1)
sts test yrs_to_fail
sts list 
sts list, by (fail)


stset yrs_to_fail [pw=anfinwgt], failure(fail==1)
sts test yrs_to_fail
sts list 
sts list, by (fail)


*create yrs_to_hb
tab yrs_to_hb if incid==1
stset yrs_to_hb, failure(fail==1)

sts test yrs_to_hb
*sts graph
sts graph, by(fail) lost
sts list 
sts list, by (fail)





*b.	Competing regressions 
stset yrs_to_fail, failure(fail==1) 
local origvars age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss //ltpov

stcrreg `origvars', compete(fail==2 3) 

*stset yrs_to_fail, failure(fail==2 3) id(spid)

/*
*years to hb has lots of missing years. Does yrs to hb need to be replaced to yrs to their last wave so that they are included? 
stset yrs_to_hb, failure(fail==1) //id(spid)
local origvars age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss //ltpov

stcrreg `origvars', compete(fail==2 3) 

*/

*Cleaned KM & Competing Risk Models 

cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
set seed 100 
sort spid wave

/*get num in missing vars: how N went from 939 incid to 929 in this logit model 
gen miss_hs_race_ind = 1 if race3==. & educ_hs==.
tab miss_hs_race miss_adl_ind if incid ==1, m
tab race3 educ_hs_ind if incid ==1,m
*/
*Missing from logit: 6 SPs missing both race & hs educ indicator, 3 SPs missing race, 1 SP missing educ_hs

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)
label var ltpov "Poverty Threshold"
forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

****Current Logit Model**********
preserve

outreg, clear 

keep if incident ==1
local origvars age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss

*using weighted numbers 
*mi stset  yrs_to_fail  [pw=anfinwgt], failure(fail==1) 

*using unweighted numbers 
mi stset yrs_to_fail, failure(fail==1) 

sts test yrs_to_fail
sts list 
sts list, by (fail)

mi estimate, post: stcrreg `origvars', compete(fail==2 3) 
*stcrreg `origvars', compete(fail==2 3) 




H="troubleshoot: wrong subsample in tables: 2018 dataset"
*troubleshoot the two missing spids 
use "${intpath}\incid_dementia_no_nsoc.dta", clear
merge 1:1 spid wave using "${intpath}\temp_incid_dementia_no_nsoc.dta"
merge m:1 spid wave using "${nhats}\sp_round_1_8_public_sens_only.dta", gen(match) 

*12 that don't match 
sort spid wave
br spid wave sp_ivw prob_dem firstdem incident obs_incid hbcat hbcat_n1 homebound _merge  match if spid ==10000873 |spid ==10002123 |spid ==10002816 |spid ==10005811 |spid ==10006453 |spid ==10007341 |spid ==10007831 |spid ==10008271 |spid ==10010346 |spid ==10010395 |spid ==10010675 |spid ==10012227

 
 
 
 duplicates list spid  if _merge ==1
br spid wave sp_ivw prob_dem firstdem incident obs_incid hbcat hbcat_n1 homebound _merge  match if spid ==10007831|spid ==10010346|spid ==10000873|spid ==10007341

*_merge ==1 are those that did not match to original 941 dataset, from temporary dataset 
*match shows all those from core 


*Table 1, 2018 Community Dwelling & Homebound: including standard deviations 
use "${intpath}\temp_commun_dwell_2018_no_nsoc.dta", clear
cd "${output}"

*Figure 1 
*graph pie if incid ==1 [pw=anfinwgt], over(hbchart) plabel(_all percent)
*graph bar [aweight = anfinwgt] if incident==1, over(homebound) asyvars blabel(bar, position(center)) ytitle(%) title(% HB Status at Incident Dementia)
	
set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve

*New Order of Vars for Table 
local cvars1 age
local ivars1 educ_hs_ind medicaid fin_strain 
local catvars1 income_quart 
***insert poverty thresh variable 
local cvars2
local ivars2 female married 
local catvars2  race3
local cvars3 
local ivars3 adl_diff_ind iadl_diff_ind sr_phq2_depressed  proxy_ivw
local catvars3 
local cvars4 sr_numcondit
local ivars4  
local catvars4 
local cvars5 
local ivars5 ind_paid_helper soc_iso livealone
local catvars5
local cvars6 n_children n_helpers
local ivars6 
local catvars6  
local cvars7 tot_hrswk_help_i
local ivars7 hrs_help_2cat
local catvars7 
local cvars8 
local ivars8 rcfres metro_ind moved_last_5 moved_count cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars8 
*hb vars: hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1    

gen n=1

forvalues i=1/8 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/8 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local part1 `cvars1' `ivars1' `catvars1' `cativars1'
local part2 
forvalues i = 2/8 {
local part2 `part2' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local ncount :  word count 1 1 
local pt1 : word count 1 1 `part1'
di `pt1'

local pt2: word count 1 1 `part2' `part1' 1 
di `pt2'

local rn : word count 1 `rows' 1 1 
di `rn'

local r=1
local c=1

*****insert incid dem full sample here 
mat tab=J(`rn',7,.)
mat stars=J(`rn',7,0)

**********************
*Sample Population 
svy: mean n
mat tab[`r',`c']==e(N_psu) 
local r = `r'+1 
mat tab[`r',`c']==e(N_pop)
local r = `r'-1
svy, subpop(if hb==0): mean n
mat tab[`r',`c'+2]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+2]==e(N_subpop)
local r = `r'-1
svy, subpop(if hb==1): mean n
mat tab[`r',`c'+4]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+4]==e(N_subpop)
local r = `r'+1

	foreach x of local cvars1 {
	svy: mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars1 {
		svy : mean `x'
		local out = e(b)[1,1]*100
		sum `x'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars1 {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy: mean `z'
		local out = e(b)[1,1]*100
		sum `z' 
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}

local r =`ncount'+1
local c = `c'+2

foreach t in 0 1 {
	foreach x of local cvars1 {
	svy, subpop(if hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars1 {
	svy, subpop(if hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy: tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars1 {
		svy, subpop(if hb==`t'): mean `x'
		if `t'==1 {
		svy: tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
	local r=`ncount'+1
	local c=`c'+2
}

local r = `pt1'+1
local c = 1
***
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy: mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if hb ==0): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate:svy, subpop(if hb ==1): mean ltpov
mat tab[`r',`c'+4]= e(b_mi)*100
mi estimate: svy: reg ltpov hb
mat tab[`r',`c'+6]=e(p_mi)
mat stars[`r',`c'+6]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

***********************
local r = `pt1'+2
local c = 1 

forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy: mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy: mean `x'
		local out = e(b)[1,1]*100
		sum `x'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy : mean `z'
		local out = e(b)[1,1]*100
		sum `z' 
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}
}

local r=`pt1'+2
local c = `c'+2

foreach t in 0 1 {
forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars`i' {
	svy, subpop(if hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy: tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if hb==`t'): mean `x'
		if `t'==1 {
		svy: tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if  hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
}

	local r=`pt1'+2
	local c=`c'+2
}	

mat rownames tab=  N "Estimated N" `part1' "Poverty Threshold" `part2'   

frmttable using "temp_tab1_commun2018_`c(current_date)'.rtf", statmat(tab) title("Community Dwelling 2018 Cohort w/ Survey Weights") ctitles("" "Full Sample" "SD" "non-HB Sample" "SD" "HB Sample" "SD" "P-value") varlabels sdec(2,2,2,2) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group" "Missing ADL & IADL is categorized as No ADL/IADL") replace

restore


H="troubleshoot: income variables "
****new way of getting imputed income quartiles***
*Mo's method* 

cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
outreg, clear
***below is KM & Competing Risk Models that use multiple imputation for Poverty Variable***
set seed 100 
sort spid wave


*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty & income imputation set up 
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen newinc = aveincome if aveincome==imputed_inc1 & aveincome==imputed_inc2 & aveincome==imputed_inc3 & aveincome==imputed_inc4 & aveincome==imputed_inc5

tempfile t1 
save `t1'

*getting an imputed average income for those with imputed income 
//bring in the imputations
mi import wide, imputed(newinc = imputed_inc1 imputed_inc2 imputed_inc3 imputed_inc4 imputed_inc5 )

mi xeq:gen ltpov=(newinc/poverty_thresh)<=1 

sum ltpov
mi estimate: mean ltpov

*not sure what this piece does 
*mi convert flong, clear
mi xeq: xtile b = newinc, nq(4)
****

mi passive: gen a = newinc
mi xeq: xtile b = a, nq(4)
mi estimate: mean a 
sum a 
mi estimate: mean newinc
sum newinc 
tab b 
mi estimate: proportion b


mi estimate: mean a 
mi estimate: mean b

gen c = . 
mi xeq: replace c = newinc
mi register regular c

mi estimate: mean c

mi register regular a

sum a

 mi xeq: gen z = newinc


mi xeq: gen lowest_incquart = incquart==1
mi register regular lowest_incquart 






/*

               xtile a=imputed_inc`I if wave==`j, nq(4)



forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh if !missing(poverty_thresh)
}

tempfile t1 
save `t1'

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

//bring in the imputations
mi import wide, imputed(incquart = income_quart1 income_quart2 income_quart3 income_quart4 income_quart5 ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

mi xeq: gen lowest_incquart = incquart==1
mi register regular lowest_incquart 

mi estimate: proportion ltpov
tab ltpov, m
****Current Logit Model**********
preserve

keep if incident ==1

local demovars1  age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss ltpov 

local demovars2  age i.race3 female educ_hs_ind sr_phq2_depressed iadl_dep adl_dep low_quart_overall_ltss lowest_incquart 

*using unweighted numbers 
mi stset yrs_to_fail, failure(fail==1) 

*sts graph, lost
*sts graph

sts test yrs_to_fail
sts list 
sts list, by (fail)


mi estimate, hr post:  stcrreg `demovars1', compete(fail==2 3) 
*outreg using "incidem_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

*mi estimate, hr: stcrreg ltpov, compete(fail ==2 3 )


*using weighted numbers 
mi stset  yrs_to_fail  [pw=anfinwgt], failure(fail==1) 
mi estimate, hr post:  stcrreg `demovars1', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", replace varlabels stats(e_b e_ci) 

mi estimate, hr post:  stcrreg `demovars2', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

*stcrreg `origvars', compete(fail==2 3) 

*probability of not being having failure at year 1 is 0.9
*have 2.5 times hazards of having the event 
************************************************************************/







*redo income variable..


cd "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear

/*
//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
*/

*gen newinc = aveincome if aveincome == imputed_inc1

forvalues i = 1/5 {
gen newinc`i'= imputed_inc`i' if aveincome ==imputed_inc1 & aveincome ==imputed_inc2 & aveincome ==imputed_inc3 & aveincome ==imputed_inc4 & aveincome ==imputed_inc5
}




gen newinc=  aveincome ==imputed_inc1 & aveincome ==imputed_inc2 & aveincome ==imputed_inc3 & aveincome ==imputed_inc4 & aveincome ==imputed_inc5


mi import wide, imputed ()

*mi import wide, imputed (newinc = imputed_inc1 imputed_inc2 imputed_inc3 imputed_inc4 imputed_inc5) clear

mi import wide, imputed (newinc = aveincome) clear

help mi 

*review nhats income imputation 


 

impute newinc = ave



gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)
label var ltpov "Poverty Threshold"
forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)



//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015




H="Survival & Competing Risks Cleaned"
*Competing Risks Per KO email on 2/8/21 
*Cleaned KM & Competing Risk Models Variable Selection Process 
**in progress for competing risk models 

cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
outreg, clear
***below is KM & Competing Risk Models that use multiple imputation for Poverty Variable***
set seed 100 
sort spid wave


*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty & income imputation set up 
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen incquart = income_quart if imputed_inc1==aveincome 

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh if !missing(poverty_thresh)
}

gen lowincquart = .
forvalues i = 1/5 {
	gen low_inc`i'=income_quart`i'==1 
}

tempfile t1 
save `t1'

//bring in the imputations
mi import wide, imputed(incquart = income_quart1 income_quart2 income_quart3 income_quart4 income_quart5 ltpov=imppov1 imppov2 imppov3 imppov4 imppov5 lowincquart = low_inc1 low_inc2 low_inc3 low_inc4 low_inc5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

mi estimate: proportion ltpov

****Current Logit Model**********
preserve

keep if incident ==1

local demovars1 age i.race3 female educ_hs_ind lowincquart rcfres comorbid sr_phq2_depressed adl_dep 

local demovars2 age  i.race3 female lowincquart rcfres comorbid sr_phq2_depressed adl_dep 

local demovars3 age i.race3 female educ_hs_ind lowincquart rcfres comorbid sr_phq2_depressed adl_dep hrs_help_2cat 

*using weighted numbers 
mi stset  yrs_to_fail  [pw=anfinwgt], failure(fail==1) 

sts graph

sts test yrs_to_fail
sts list 

mi estimate, hr post:  stcrreg `demovars1', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", replace varlabels stats(e_b e_ci) 

mi estimate, hr post:  stcrreg `demovars2', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

mi estimate, hr post:  stcrreg `demovars3', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 
*stcrreg `origvars', compete(fail==2 3) 

*probability of not being having failure at year 1 is 0.9
*have 2.5 times hazards of having the event 
************************************************************************/
/*using unweighted numbers 
mi stset yrs_to_fail, failure(fail==1) 

*sts graph, lost
*sts graph

sts test yrs_to_fail
sts list 
sts list, by (fail)


*mi estimate, hr post:  stcrreg `demovars1', compete(fail==2 3) 
*outreg using "incidem_compet_risks_`c(current_date)'.rtf", merge varlabels stats(e_b e_ci) 

*mi estimate, hr: stcrreg ltpov, compete(fail ==2 3 )
*/


H="*******************************"


H="**Hold Off On**"


H="Tab1: SPs HB incl Prior by Race (No NSOC)"
***Holding off on Race Stratification: mention in discussion: need larger HISP sample***
*Table 1, Stratify by Race 
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
cd "${output}"

set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 

local cvars1 age adl_index
local ivars1 female married educ_hs_ind hb shb indep_hb hb_n1 shb_n1 indep_n1  hb_p1 shb_p1 indep_p1 medicaid sr_phq2_depressed
*local catvars1 race3
local ivars2 ind_paid_helper  rcfres livealone metro_ind fin_strain moved_last_5 moved_count proxy_ivw
local catvars2 income_quart 
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 tot_hrswk_help_i
local catvars4  //hrs_help_3cat 
local cvars5 sr_numcondit
local catvars5 comorbid 
*local cvars6 length_in_res
*local catvars6 length_in_res_3cat

gen n=1

forvalues i=1/6 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/6 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows'  
local r=1
local c=1
*****insert incid dem full sample here 
mat tab=J(`rn',3,.)
mat stars=J(`rn',3,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)
label var ltpov "Below Poverty Threshold Ind"

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate: svy: mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if race3==0):mean ltpov
mat tab[`r',`c'+1]= e(b_mi)*100
mi estimate:svy, subpop(if race3==1):mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate:svy, subpop(if race3==2):mean ltpov
mat tab[`r',`c'+2]=e(b_mi)*100
mi extract 0 


***********************
local r = 2

forvalues i=1/6 {
	foreach x of local cvars`i' {
	svy, subpop(if race3==0):mean `x'
	mat tab[`r',`c']=e(b)
	svy, subpop(if race3==1):mean `x'
	mat tab[`r',`c'+1]=e(b)
	svy, subpop(if race3==2):mean `x'
	mat tab[`r',`c'+2]=e(b)

	local r=`r'+1		
}

foreach x of local ivars`i' {
		svy, subpop(if race3==0):mean `x'
		local out = e(b)[1,1]*100
		sum `x' if race3==0
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
		svy, subpop(if race3==1):mean `x'
		local out = e(b)[1,1]*100
		sum `x' if race3==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'+1] = `out'
		}
		else{
		mat stars[`r',`c'+1]=3
		}
		svy, subpop(if race3==2):mean `x'
		local out = e(b)[1,1]*100
		sum `x' if race3==2
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'+2] = `out'
		}
		else{
		mat stars[`r',`c'+2]=3
		}
		local r=`r'+1
}


	foreach x of local catvars`i' {
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if race3==0):mean `z'
		local out = e(b)[1,1]*100
		sum `z' if race3==0
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
		svy, subpop(if race3==1):mean `z'
		local out = e(b)[1,1]*100
		sum `z' if race3 ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'+1] = `out'
		}
		else{
		mat stars[`r',`c'+1]=3
		}
		svy, subpop(if race3==2):mean `z'
		local out = e(b)[1,1]*100
		sum `z' if race3 ==2
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'+2] = `out'
		}
		else{
		mat stars[`r',`c'+2]=3
		}
			local r=`r'+1
			}
}
}


mat rownames tab= "Poverty Threshold"  `rows'  

frmttable using "Tab1 Strat Race_Incid_Dem_`c(current_date)'.rtf", statmat(tab) title("Incident Dementia Table 1 By Race") ctitles("" "White(& Others)" "Black (non-Hispanic)" "Hispanic") varlabels sdec(2,2,2,2) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree") replace annotate(stars) asymbol(*,*,NR)

restore

*Table 1, Stratify by Race 
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
cd "${output}"

set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 

label var sr_numcondit "# Med Conditions (excl Dementia) - Mean"
*label var length_in_res "Years at Residence - Mean"
label var adl_index "ADL Counts (Continuous)-Mean"
*label var ind_paid_helper "Paid Help Indicator"
label var indep_hb "HB Status: Independent "
label var nhelpers3 "# of Helpers (3 Categories)"

local cvars1 age adl_index
local ivars1 female married educ_hs_ind hb shb indep_hb hb_n1 shb_n1 indep_n1  hb_p1 shb_p1 indep_p1 medicaid sr_phq2_depressed
*local catvars1 race3
local ivars2 ind_paid_helper  rcfres livealone metro_ind fin_strain moved_last_5 moved_count proxy_ivw
local catvars2 income_quart 
local ivars3 cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
local catvars3  nhelpers3
local cvars4 tot_hrswk_help_i
local catvars4  //hrs_help_3cat 
local cvars5 sr_numcondit
local catvars5 comorbid 
*local cvars6 length_in_res
*local catvars6 length_in_res_3cat

gen n=1

forvalues i=1/6 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}


local rows
forvalues i=1/6 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local rn : word count 1 `rows' 
local r=1
local c=1
*****insert incid dem full sample here 
mat tab=J(`rn',2,.)
mat stars=J(`rn',2,0)

**********************
*insert mi poverty here (under preserve/restore cmd so mi won't run outside of do file). 
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)
label var ltpov "Below Poverty Threshold Ind"

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
mi estimate:svy, subpop(if race3==0):mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if race3==1):mean ltpov
mat tab[`r',`c'+1]= e(b_mi)*100
mi extract 0 


***********************
local r = 2

forvalues i=1/6 {
	foreach x of local cvars`i' {
	svy, subpop(if white==0):mean `x'
	mat tab[`r',`c']=e(b)
	svy, subpop(if white==1):mean `x'
	mat tab[`r',`c'+1]=e(b)
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if white==0):mean `x'
		local out = e(b)[1,1]*100
		sum `x' if white ==0 
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
		svy, subpop(if white==1):mean `x'
		local out = e(b)[1,1]*100
		sum `x' if white ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'+1] = `out'
		}
		else{
		mat stars[`r',`c'+1]=3
		}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if white==0):mean `z'	
		local out = e(b)[1,1]*100
		sum `z' if white ==0 
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
		svy, subpop(if white==1):mean `z'
		local out = e(b)[1,1]*100
		sum `z' if white ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'+1] = `out'
		}
		else{
		mat stars[`r',`c'+1]=3
		}
		local r=`r'+1
		}
}
}

mat rownames tab= "Poverty Threshold"  `rows' 

mat list tab
frmttable using "Tab1 Strat Race_Incid_Dem_`c(current_date)'.rtf", statmat(tab) title("Incident Dementia Table 1 By Race") ctitles("" "non-White" "White") varlabels sdec(2,2,2) note("non-White includes Black (non-Hispanic), Hisanic, Other (Am Indian/Asian/Nat.Hawaii). Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree") addtable annotate(stars) asymbol(*,**,NR)

restore



H="************"


H="First Heading"
/* 
********************HEADING******************** 

Project Name: NHATS Incident Dementia & HB 

Date Started: 4/3/20   

Primary Investigator: KO
Funding Source: 	

Created by:CY

Primary Analyst: CY
Secondary Analyst: EBL

Datasets Used: NHATS


*/
 
//STATA
// Global Macros use $ symbol to be called. 

//Clean NHATS
global nhats "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data"

global rawdata "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data"

global geog_nhats "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data"

//Intermediate Data Path
global intpath "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data"

// Final Data Path

//Output files path
global output "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\output\in_progress"

*comparison: start with everyone hb, & compare those w/ & w/o dementia? 



H="Data Set Up -Incid Dem & 2018 Commun Dwell No NSOC (939 hb dementia) "
/*
Updated by CY 
Date Updated: 3/2021 
*Incident Dementia Variable Set Up, No NSOC Merge, start with dropping 2015 year sample & removing wave 9 
*/
****************



cd "${output}"

import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow clear
rename year ivw_year
drop if hhm ==.|ivw_year ==. 
tempfile poverty
save "`poverty'", replace

use "${nhats}\sp_round_1_9_public_sens_only.dta", clear
*merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\Reference data and docs\NHATS - geog & other reference docs\NHATS cleaned data\sp_round_1_6_public_sens_only.dta", keep(match master) nogen keepusing(pr_ad8_score)

merge m:1 hhm ivw_year using "`poverty'", keep(master matched) nogen 

sort ivw_year hhm
by ivw_year:carryforward poverty_thres if hhm > 9 & hhm<., replace

*restrict sample to obsvn w/ sp_ivw and not missing prob_dem status
*drop if yearsample ==2015
*keep if sp_ivw==1 & !missing(prob_dem) 

sort spid wave
*get wave of first time probable dementia is indicated
sort spid 
by spid: egen firstdem=min(cond(prob_dem==1),wave,.)
*indicator for wave of first dementia wave & ensure wave is continuous 

by spid: gen incident=wave==firstd & wave[_n-1]==wave-1 
label var incident "Incident Dementia"

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\incident_dem_and_hb\data\ltss_scorecard_quartiles.dta", keep(master matched) nogen

merge m:1 spid using "${rawdata}\round_1\round_1\NHATS_Round_1_SP_File.dta", keepusing (ht1mthslived ht1yrslived) keep (master match) nogen

forvalues i = 2/8{
merge m:1 spid using "${rawdata}\round_`i'\round_`i'\NHATS_Round_`i'_SP_File.dta", keepusing (fl`i'spdied re`i'spadrsnew   re`i'mthmove re`i'yearmove) keep (master match) nogen
}

*only for 2011 cohort, didn't bring in 2015 residential variable
forvalues i = 2/8{
replace re`i'spadrsnew = 1 if re`i'spadrsnew==3
tab re`i'spadrsnew
}

forvalues i = 2/8{
gen moved`i'_ind = `i' if re`i'spadrsnew==2
}

gen moved_tot = wave if ht1yrslived==-1 & wave ==1 
forvalues i = 2/8{
replace moved_tot= wave if moved`i'_ind ==`i' & wave ==`i'
}
tab moved_tot wave

sort spid wave
by spid: carryforward moved_tot, gen (moved_total)

*get moved in last 5 yrs prior to incident dementia, including yr of dementia 
by spid: gen moved_5yr = wave if firstdem-moved_tot >=0  &  firstdem-moved_tot <=5 & firstdem!=. & moved_tot !=.
gen moved_last_5 = moved_5yr>0 & moved_5yr<.
label var moved_last_5 "Moved in last 5 Years before Incident Dementia"

*dups indicate moving more than once in last 5 yrs 
duplicates report spid if  moved_5yr!=. & firstdem!=.
duplicates tag spid if  moved_5yr!=. & firstdem!=. , gen (moved_dups)

gen moved_count = moved_dups >= 1 & moved_dups < .
tab moved_count
label var moved_count "Moved >1 Time in last 5 Yrs from Incident Dementia" 

/*
*code is for how long 1 lived at address, don't need if using moved var instead 

replace moved_tot = 0 if moved_tot !=. 

gen length_in_res = ht1yrslived if moved_total ==. 
replace length_in_res =. if ht1yrslived==-1
forvalues i = 2/8{
replace length_in_res = ht1yrslived+`i'-1 if wave ==`i' & moved_total ==. & length_in_res != -1 
}

*capture duplicates where there is 1 spid but several opid for same wave 
replace length_in_res = moved_tot if length_in_res ==. 
******
forvalues i = 2/8{
by spid: replace length_in_res = length_in_res[_n-1]+1 if length_in_res ==. & wave==wave[_n-1]+1 & wave==`i'
*by spid: replace length_in_res = length_in_res[_n-1] if length_in_res ==. & wave==wave[_n-1]& wave==`i'
}
******
replace length_in_res = . if ht1yrslived==.
tab length_in_res

gen length_in_res_3cat = 0 if length_in_res>=0 & length_in_res <=10
replace length_in_res_3cat=1 if length_in_res>=11 & length_in_res <=30
replace length_in_res_3cat=2 if length_in_res>=31 & length_in_res <.
tab length_in_res_3cat

label var length_in_res "Years at Residence"
label define length_in_res_3cat 0 "0 - 10 Years" 1 "11-30 Years" 2 "31+ Years "
label val length_in_res_3cat length_in_res_3cat
label var length_in_res_3cat "Years at Residence (3cat)"

*check 

forvalues i = 2/8 {
*tab length_in_res if re`i'spadrsnew==2
tab moved_total length_in_res if re`i'spadrsnew==2
duplicates report if re`i'spadrsnew==2
}
*/

*get wave of first nh resident 
sort spid wave 
by spid: egen firstnh=min(cond(nhres==1),wave,.)
*restrict sample to remove those in nursing home before incid dementia wave and remove those without firstdem response 

*create var hbcat, hbstat in  3 categories instead of 4
gen hbcat=homebound_cat
replace hbcat=hbcat-1 if hbcat>2
label define hbcat 1 "HB" 2 "SHB" 3 "Independent"
label values hbcat hbcat 

*create var of hb status in prior wave
sort spid wave
by spid: gen hbcat_n1=hbcat[_n-1]
*label copy hbcat hbcat_n1 
label define labhbcat_n1 1 "HB@n1" 2 "SHB@n1" 3 "Independent@n1"
label values hbcat_n1 hbcat_n1

*indicator var for separate homebound categories 
sort spid wave
by spid: gen hb=homebound_cat==1 if !missing(homebound_cat)
by spid: gen shb=hbcat ==2 if !missing(hbcat)
by spid: gen indep_hb =hbcat==3 if !missing(hbcat)
label var hb "Homebound"
label var shb "Semi Homebound"
label var indep_hb "Independent"

*shb at prior wave 
gen shb_n1=hbcat_n1==2
label var shb_n1 "Semi-HB at Prior Wave"

*hb at prior wave
gen hb_n1=hbcat_n1==1
label var hb_n1 "HB at Prior Wave"

*indep at prior wave 
gen indep_n1 = hbcat_n1 ==3
label var indep_n1 "Indep at Prior Wave"

*spids in which their incident dementia wave is dropped b/c they are missing hbcat & hbcat_n1
list spid wave incident firstdem  yearsample if spid==10003459 |spid == 10006546 |spid ==10007621  | spid ==10011112 

*drop if missing(hbcat)
*drop if missing(hbcat_n1) & wave > 1
drop incident 
by spid: gen incident=wave==firstd & wave[_n-1]==wave-1 
label var incident "Incident Dementia"

tab incident

by spid: gen restr_incid= incident==1 & !missing(hbcat) & !missing(hbcat_n1) & wave > 1 & yearsample !=2015 & sp_ivw==1 & !missing(prob_dem) //& firstdem > firstnh
//use after dropping those that missed hbcat
by spid: egen obs_incid=max(restr_incid)
 
tab firstdem firstnh if restr_incid==1

*hb at prior wave 
gen incicat2=hbcat_n1==1
*add incicat=1(concur hb) if not hb at prior wave & hb at index wave 
replace incicat=1 if !incicat & hbcat==1
*incicat=2 (not hb) if not hb at prior wave & is SHB or Indep 
replace incicat=0 if !incicat & inlist(hbcat,2,3)
label define incicat 0 "Not homebound" 1 "HB@N1 or Concur HB"
label values incicat incicat
label var incicat "HB in PriorWave or Concurrent HB"

*hb at next wave 
by spid: gen hbcat_p1= hbcat[_n+1]
label values hbcat_p1 hbcat

by spid: gen hb_p1 = hbcat_p1 ==1 & lml[_n+1]==0
by spid: gen shb_p1 = hbcat_p1 ==2 & lml[_n+1]==0
by spid: gen indep_p1 = hbcat_p1 ==3 & lml[_n+1]==0
label define hb_p1 0 "Not Homebound" 1 "HB at P1"
label values hb_p1 hb_p1
label var hb_p1 "HB at Next Wave (excl LML)"
label var shb_p1 "SHB at Next Wave (excl LML)"
label var indep_p1 "Indep at Next Wave (excl LML)"

***********


*create next wave status for everyone 
sort spid wave
by spid: gen nwstatus = 1 if indep_p1 ==1
by spid: replace nwstatus = 2 if shb_p1==1 
by spid: replace nwstatus = 3 if hb_p1==1 
by spid: replace nwstatus = 4 if nhres[_n+1]==1
by spid: replace nwstatus = 5 if nhats_died_12==1
by spid: replace nwstatus = 5 if lml_ivw_yes[_n+1]==1 
by spid: replace nwstatus= 6 if missing(nwstatus)

label def nwstatus 1 "Independent" 2 "SHB" 3 "HB" 4 "NH" 5 "Died" 6 "LFU"
label val nwstatus nwstatus
label var nwstatus "Next Wave Status"

*******
*get years to first homebound status after incident dementia 
sort spid wave
gen postincidem = 1 if incident ==1
by spid: carryforward postincidem, replace
tab postincidem, m


*hb waves only after incident dementia & not at lml 
by spid: gen hbwave = wave if hb ==1 & postincidem ==1 & lml ==0 
by spid: egen postdemhb = min(hbwave)
drop hbwave

tab firstnh postdemhb, m
*get the later wave at death, in case some have 2 waves with nhats_died_12 ==1 
by spid: gen dwave = wave if nhats_died_12 & nhats_died_12 !=.
by spid: egen diedwave = max(dwave)

*get last non lml wave for lfu/censored popln 
by spid: egen seq = seq() if lml ==0
by spid: egen nmax = max(seq) 


**years from incident dementia to failures**
*if  hb/nh/died all in the same wave, died > nh > hb 
*homebound 
gen yrs_to_fail = postdemhb-firstdem
*nursing home
replace yrs_to_fail = firstnh-firstdem if yrs_to_fail ==. //negative yrs will be dropped later 
*died 
replace yrs_to_fail = diedwave-firstdem if yrs_to_fail ==.
*lfu/censored 
replace yrs_to_fail = nmax-firstdem if yrs_to_fail ==. 

*set fails if  hb/nh/died all in the same wave, died > nh > hb (for failures that happen after incident dementia)
gen fail = 0 
replace fail = 1 if postdemhb !=.
replace fail = 2 if firstnh > firstdem & firstnh !=. & firstnh < postdemhb 
replace fail = 3 if diedwave !=. & (diedwave <= firstnh|diedwave<=postdemhb)
label def fail 0 "no fail" 1 "hb" 2 "nh" 3 "die"
label val fail fail
tab fail 

*drop vars used to create yrs_to_fail & fail variable 
drop seq nmax postincidem postdemhb dwave diedwave  

*********
*comorbidities variable <2, 2-4, 5+
gen sr_numcondit=sr_numconditions1
replace sr_numcondit= sr_numcondit-1 if sr_dementia_ever ==1
replace sr_numcondit= sr_numcondit-1 if sr_phq2_depressed==1
label var sr_numcondit "# of Comorbidities (excl Dementia & Depression), Mean "

gen comorbid = 0 if sr_numcondit <2
replace comorbid = 1 if sr_numcondit >=2 & sr_numcondit<=4
replace comorbid = 2 if sr_numcondit> 4 & sr_numcondit<.
label define comorbid 0 "<2 Comorbidities" 1 "2-4 Comorbidities" 2 "5+ Comorbidities"
label values comorbid comorbid 
label var comorbid "Count of Med Conditions, grouped by <2,2-4,5+ (excl Dementia & Depression)"

gen comorbid5 = comorbid==2
label var comorbid5 "5+ Comorbidities"

rename race_cat race
*recategorize race to 3 cats instead of 4
gen race3 = 1 if race==1 
replace race3 = 1 if race==3 
replace race3 = 2 if race ==2
replace race3 = 3 if race==4 
replace race3 = race3-1
tab1 race race3
label define race3 0 "White & Other(Non-Hisp)" 1 "Black(Non-Hisp)" 2"Hispanic"
label values race3 race3
label var race3 "Race"

*categorize number of helpers 
gen nhelpers3 = num_helpers_cat
replace nhelpers3= 2 if nhelpers3==3
label define nhelpers3 0 "No Helpers" 1 "1-3 Helpers" 2 "4+ Helpers"
label values nhelpers3 nhelpers3 
label var nhelpers3 "3 Cat Num of Helpers"
tab nhelpers3 if incid ==1

label var adl_diff_ind "1 or more ADL difficulty reported"
label var iadl_diff_ind "1 or more IADL difficulty reported"

gen adl_dep =0 if adl_independent==1|adl_independent ==. 
replace adl_dep = 1 if adl_independent ==0
label var adl_dep "ADL Help Dependent (1 or more ADL help reported)"

gen iadl_dep =0 if iadl_independent==1|iadl_independent ==.
replace iadl_dep = 1 if iadl_independent ==0
label var iadl_dep "IADL Help Dependent (1 or more IADL help reported)"


*total hrs of help  
label var tot_hrswk_help_i "Total hours of help/week, Mean"
replace tot_hrswk_help_i=0 if missing(tot_hrswk_help_i)

/*can break down as <10; 11-40; more than 40 depending on distribution
gen hrs_help_3cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<=10
replace hrs_help_3cat = 1 if tot_hrswk_help_i >10 & tot_hrswk_help_i <=40 
replace hrs_help_3cat = 2 if tot_hrswk_help_i >40 & tot_hrswk_help_i<.
label define hrs_help_3cat 0 "0-10 Hrs" 1 ">10 -40 Hrs" 2 ">40 Hrs"
label values hrs_help_3cat hrs_help_3cat
label var  hrs_help_3cat "Total Hrs of Help (3cat)"
tab hrs_help_3cat
*/
*total hrs of help 2cat
gen hrs_help_2cat = 0 if tot_hrswk_help_i>=0 & tot_hrswk_help_i<40
replace hrs_help_2cat = 1 if tot_hrswk_help_i >=40 & tot_hrswk_help_i <.

label define hrs_help_2cat 0 "0-40 Hrs" 1 ">=40 Hrs" 
label values hrs_help_2cat hrs_help_2cat
label var  hrs_help_2cat "Total Hrs of Help (>=40 Hrs)"

*financial strain
foreach x in nopayhous nopayutil nopaymed mealskip  {
replace `x'=. if `x'==2
}
replace mealskipnum=. if mealskipnum==5

gen fin_strain=.
replace fin_strain=0 if nopayhous==0 & nopayutil==0 & nopaymed==0 & mealskip==0 
replace fin_strain=1 if nopayhous==1 | nopayutil==1 | nopaymed==1 | mealskip==1
label var fin_strain "Any Financial Strain"

gen any_asst= govtasst
replace any_asst=1 if section8==1
label var any_asst "Reci. any Public Assist. (incl. Gov't assist./Section 8)"

forvalues i = 1/8 {
gen wave`i'_incid=wave ==`i' & incident ==1
tab wave`i'_incid
}

label define yesno_agree 0 "Agree(Little)/Do Not Agree" 1 "Agree(A lot)"

foreach x of varlist cohesion_knowwell cohesion_willing cohesion_peop{
replace `x'=0 if `x'==3 
replace `x'=0 if `x'==2
label values `x' yesno_agree
}

*get follow up time after incident dementia 
*this accounts for skipped waves since they aren't counted. max of (wave-firstdem) will incl. any skipped ivws
by spid: egen followup_dem = total (cond (wave-firstdem > 0), 1, .)
label var followup_dem "# of Waves after Incident Dementia "
sum followup_dem if incid ==1
hist followup_dem if incid ==1, freq

*Num of waves to nursing home, after incident dementia 

gen dem_to_nh = firstnh-firstdem
tab dem_to_nh if incid ==1

*ltss overall rank var - get lowest & highest 
tab overallrankquart, gen(overallrankquart_ltss) 
rename overallrankquart_ltss1 low_quart_overall_ltss
label var low_quart_overall_ltss "Lowest Quart of overallrankquart_ltss"
rename overallrankquart_ltss4 high_quart_overall_ltss
label var high_quart_overall_ltss "Highest Quart of overallrankquart_ltss"

label def overallrankquart 1 "Bottom" 2 "Second" 3 "Third" 4 "Top"
label val overallrankquart overallrankquart 
label var overallrankquart "4 quantiles of overall rank ltss scorecard"


/*
*ltss variables - getting those in highest & lowest quartile of each ltss variable 
**cannot print/share on table 1 bc of complimentary disclosure 

local ltss affordabilityandaccessquart choiceofsettingandproviderquart qualityoflifeandqualityofcquart supportforfamilycaregiversquart effectivetransitionsquart overallrankquart 

foreach x of local ltss{
tab `x', gen(`x')
}

foreach x of local ltss{
rename `x'1 l`x'
label var l`x' "Lowest Quart of `x'"
rename `x'4 h`x'
label var h`x' "Highest Quart of `x'"
}
*/

/*
*old pie chart that incls hb prior & hb concur to incidem 
gen hbchart = hbcat 
replace hbchart = 0 if hbcat==1 & hb_n1 ==1
tab hbchart if incid ==1

label def hbchart 0 "HB @ Prior Incid & Concur" 1 "Newly HB @ Incid Dem" 2 "SHB" 3 "Indep"
label values hbchart hbchart
label var hbchart "HB Status for Pie Chart"
*/

label var age "Age, Mean"
label var educ_hs ">= High School Education"
label var sr_phq2_depressed "Depression (PHQ-2 positive screen)"
label var proxy_ivw "Interview via Proxy"
label var indep_hb "HB Status: Independent "
label var soc_iso "Socially Isolated"
label var nhelpers3 "# of Helpers (3 Categories)"
label var rcfres "Assisted Living"
label var n_children "Number of Living Children, Mean"
label var n_helpers "Number of Helpers reported by SP, Mean"
label var adl_diff_ind "1 or more ADL difficulty reported"
label var iadl_diff_ind "1 or more IADL difficulty reported"

/*
*other vars that need to correct labels for. confirm with KO & JR first 
local catvars4 comorbid 
local ivars5 ind_paid_helper livealone
local cvars6 n_children n_helpers
local catvars6  nhelpers3 
local cvars7 tot_hrswk_help_i
local catvars7 hrs_help_3cat
local ivars8  metro_ind cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd
*/

*missing obsvn: 
* educ_hs_ind adl_index race3 iadl_index
*check education for these spids before limiting the sample 

*save as diff datasets. (full & incid data set)
save "${intpath}\temp_full_nhats_dem_no_nsoc.dta", replace 


*keep if obs_incid==1
preserve
*create incident dementia dataset 
*codebook commands are used to get sample derivations 
drop if yearsample ==2015
*codebook spid if community_dwelling ==1
keep if sp_ivw==1 & !missing(prob_dem) 
*codebook spid if community_dwelling ==1
*codebook spid if incid ==1
drop if firstnh<=firstdem | missing(firstdem)
*codebook spid if incid ==1
drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
*only keeping SP observations who are incident dementia 
drop if wave ==9 
*only keeping cohort from waves 1-8
*codebook spid if incid ==1
keep if obs_incid==1
*codebook spid if incid ==1
save "${intpath}\temp_incid_dementia_no_nsoc.dta", replace 
restore 


*2018 temp data. troubleshoot above first to figure this out & make sure correct. include the 2015 sample in this dataset.
preserve
keep if sp_ivw==1 & !missing(prob_dem) 
*drop if firstnh<=firstdem | missing(firstdem)
*do not drop firstnh<firstdem b/c most in 2015 sample will drop 
drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1
codebook spid 
tab wave 
keep if wave ==8 & community_dwelling ==1
tab hbcat 
codebook spid
save "${intpath}\temp_commun_dwell_2018_no_nsoc.dta", replace 
restore

H="Sample Derivation"

use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
preserve
drop if yearsample ==2015
codebook spid if community_dwelling ==1 
codebook spid if !missing(prob_dem) & community_dwelling ==1 & yearsample ==2011 & wave > 1

keep if sp_ivw==1 & !missing(prob_dem) 
codebook spid if incident ==1
drop if missing(firstdem)
codebook spid if incident ==1
codebook spid if firstnh<=firstdem 
drop if firstnh<=firstdem 
codebook spid if incident ==1
drop if missing(hbcat)
drop if missing(hbcat_n1) & wave > 1

codebook spid if incident ==1

restore


H="LTSS & 939 Popln Table 1 (using temp_incid_dem)"
*Incident Dementia Table 1, Full Sample & Incid Homebound: including standard deviations 


use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
cd "${output}"

*sum imputed_inc1-aveincome if income_quart ==3 & hhm <=2 & hhm!=. & incid ==1

*tab moved_last_5 res_care if incid ==1
*Figure 1 
graph bar [aweight = anfinwgt] if incident==1, over(homebound) asyvars blabel(bar, position(center)) ytitle(%) title(% HB Status at Incident Dementia)
	
set seed 100 
sort spid wave 

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2011 Cohort Weighted 
preserve
keep if incident==1 & wave !=9
 
local cvars1 age
local ivars1 educ_hs_ind medicaid fin_strain 
local catvars1 
***insert poverty thresh & income vars variable 
local cvars2
local ivars2 female married 
local catvars2  race3
local cvars3 
local ivars3 adl_dep iadl_dep sr_phq2_depressed  proxy_ivw
local catvars3 
local cvars4 sr_numcondit
local ivars4  
local catvars4 
local cvars5 
local ivars5 ind_paid_helper soc_iso livealone
local catvars5
local cvars6 n_children n_helpers
local ivars6 
local catvars6  
local cvars7 tot_hrswk_help_i
local ivars7 hrs_help_2cat
local catvars7 
local cvars8 
local ivars8 rcfres metro_ind moved_last_5 moved_count cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd 
local catvars8 overallrankquart
*hb vars: hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1    

gen n=1

forvalues i=1/8 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/8 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local part1 `cvars1' `ivars1' `catvars1' `cativars1'
local part2 
forvalues i = 2/8 {
local part2 `part2' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local ncount :  word count 1 1 
local pt1 : word count 1 1 `part1'
di `pt1'

local pt2: word count 1 1 `part2' `part1' 1 
di `pt2'

local rn : word count 1 `rows' 1 1 1 1 1 1 1 
di `rn'

local r=1
local c=1
local denom = 941

*****insert incid dem full sample here 
mat tab=J(`rn',7,.)
mat stars=J(`rn',7,0)

**********************
*Sample Population 
svy, subpop(if incid ==1): mean n
mat tab[`r',`c']==e(N_sub)
local r = `r'+1 
mat tab[`r',`c']==e(N_subpop)
local r = `r'-1
svy, subpop(if incid ==1 & hb==0): mean n
mat tab[`r',`c'+2]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+2]==e(N_subpop)
local r = `r'-1
svy, subpop(if incid ==1 & hb==1): mean n
mat tab[`r',`c'+4]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+4]==e(N_subpop)
local r = `r'+1

	foreach x of local cvars1 {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars1 {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars1 {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}

local r =`ncount'+1
local c = `c'+2

foreach t in 0 1 {
	foreach x of local cvars1 {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars1 {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars1 {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
	local r=`ncount'+1
	local c=`c'+2
}

local r = `pt1'+1
local c = 1

***********************

*insert mi poverty & income quartile here (under preserve/restore cmd so mi won't run outside of do file). 

*svydescribe //command to identify the strata with singleton PSUs 
*doing this to get p-value for imputed income variable, undo after mi, doesn't change any of the numbers other than get a p value 
replace varstrat = 2 if varstrat ==46

gen incquart = income_quart if imputed_inc1==aveincome 

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh if !missing(poverty_thresh)
}

tempfile t1 
save `t1'

//bring in the imputations

mi import wide, imputed (incquart = income_quart1 income_quart2 income_quart3 income_quart4 income_quart5 ltpov=imppov1 imppov2 imppov3 imppov4 imppov5) 

*need to change the stratum unit only for incquart to get regression.

mi estimate: svy, subpop(if incid ==1): regress hb incquart 
mi estimate, post 
*insert pvalue here 
mat tab[`r',`c'+6]= e(p_mi)
mat stars[`r',`c'+6]=(e(p_mi)<.05) + (e(p_mi)<.01)
local r = `r'+1 



mi estimate: svy, subpop(if incid ==1): proportion incquart 
mat tab[`r',`c']= e(b_mi)[1,1]*100
mat tab[`r'+1,`c']= e(b_mi)[1,2]*100
mat tab[`r'+2,`c']= e(b_mi)[1,3]*100
mat tab[`r'+3,`c']= e(b_mi)[1,4]*100
mi estimate:svy, subpop(if incid ==1 & hb ==0): proportion incquart
mat tab[`r',`c'+2]= e(b_mi)[1,1]*100
mat tab[`r'+1,`c'+2]= e(b_mi)[1,2]*100
mat tab[`r'+2,`c'+2]= e(b_mi)[1,3]*100
mat tab[`r'+3,`c'+2]= e(b_mi)[1,4]*100
mi estimate:svy, subpop(if incid ==1 & hb ==1): proportion incquart
mat tab[`r',`c'+4]= e(b_mi)[1,1]*100
mat tab[`r'+1,`c'+4]= e(b_mi)[1,2]*100
mat tab[`r'+2,`c'+4]= e(b_mi)[1,3]*100
mat tab[`r'+3,`c'+4]= e(b_mi)[1,4]*100

local r = `r'+4

*poverty imputation* 
mi estimate: svy, subpop(if incid ==1): mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==0): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate:svy, subpop(if incid ==1 & hb ==1): mean ltpov
mat tab[`r',`c'+4]= e(b_mi)*100
mi estimate: svy: reg ltpov hb
mat tab[`r',`c'+6]=e(p_mi)
mat stars[`r',`c'+6]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

*change weights back to what the original weights
replace varstrat = 1 if varstrat ==46
***********************
local r = `pt1'+7
local c = 1 

forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy, subpop(if incid ==1) : mean `x'
		local out = e(b)[1,1]*100
		sum `x' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1) : mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}
}

local r=`pt1'+7
local c = `c'+2

foreach t in 0 1 {
forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars`i' {
	svy, subpop(if incid ==1 & hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if incid ==1 & hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy, subpop(if incid ==1): tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if incid ==1 & hb==`t'): mean `x'
		if `t'==1 {
		svy, subpop(if incid ==1): tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if incid ==1 & hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if incid ==1 & hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
}

	local r=`pt1'+7
	local c=`c'+2
}	

mat rownames tab=  N "Estimated N" `part1' "Income Quartile" "Bottom Income Quart" "2nd Income Quart" "3rd Income Quart" "Top Income Quart"  "Poverty Threshold" `part2'   

frmttable using "tab1_incidem_hb_sd_`c(current_date)'.rtf", statmat(tab) title("Incid Dem 2011 Cohort w/ Survey Weights") ctitles("" "Incid Dem Full Sample" "SD" "InciDem & non-HB" "SD" "InciDem & HB" "SD" "P-value") varlabels sdec(2,2,2,2) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group" "Missing ADL & IADL is categorized as No ADL/IADL" "Added adl/iadl dependent for ADL help") replace

restore

*Table for wave at incident dementia 
preserve
keep if incident ==1 & wave !=9
svyset spid [pw=anfinwgt], strata(varstrat)
mat tab = J(8,4,.)
local r = 1


forvalues i =2/8 {
tab wave`i'_incid if wave`i'_incid ==1
mat tab [`r',1]= r(N)
sum wave`i'_incid
mat tab [`r',2] =r(mean)*100
svy, subpop (if incident ==1 & wave`i'_incid==1) : mean wave`i'_incid
mat tab [`r', 3]= e(N_pop)
svy, subpop (if incident ==1): mean wave`i'_incid
mat tab[`r',4]==e(b)*100
local r = `r'+1
}
gen n = 1
svy, subpop (if incident ==1): mean n
mat tab[`r',1]= e(N)
mat tab [`r', 3]= e(N_pop)

mat rownames tab = "Wave 2" "Wave 3" "Wave 4" "Wave 5" "Wave 6" "Wave 7" "Wave 8" "Total"
frmttable using "tab1_incidem_hb_sd_`c(current_date)'.rtf", statmat(tab) title("Wave at Incident Dementia") ctitles("" "# of Incident Dementia" "Unweighted %" "Weighted # of Incident Dementia" "Weighted %") varlabels sdec(2,2,2,2) addtable

restore


H="LTSS & 939 popln Logit Models"
*Incid Dementia Logit Tables w/o Merging NSOC 

cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
set seed 100 
sort spid wave
keep if wave !=9 

/*get num in missing vars: how N went from 939 incid to 929 in this logit model 
gen miss_hs_race_ind = 1 if race3==. & educ_hs==.
tab miss_hs_race miss_adl_ind if incid ==1, m
tab race3 educ_hs_ind if incid ==1,m
*/
*Missing from logit: 6 SPs missing both race & hs educ indicator, 3 SPs missing race, 1 SP missing educ_hs

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

***poverty
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1) 
label var ltpov "Poverty Threshold"
forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh  if !missing(poverty_thresh)
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

****Current Logit Model**********
preserve

outreg, clear 

keep if incident ==1 & wave !=9 
local origvars age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss

mi estimate, or:svy, subpop(if incident==1): logit hb `origvars' 
mi estimate, post 
*mi estimate, or post

outreg using "Incidem Logit_weight_mi_`c(current_date)'.rtf", stats(e_b e_ci p) varlabels title("Incident Dementia & Concurrently HB Logit Model of 2011 cohort") note("OR is displayed. Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers. 10 Observations dropped due to missing variables. Missing ADL & IADL is categorized as No ADL/IADL") replace

/*
*for the non homebound 
local origvars age i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss

gen hbnwstat= nwstatus==3

mi estimate, or:svy, subpop(if incid ==1 & hb ==0): logit hbnwstat `origvars' 
mi estimate, post 
*mi estimate, or post

outreg using "Incidem Logit_weight_mi_`c(current_date)'.rtf", stats(e_b e_ci p) varlabels title("Incident Dementia") merge 
*/

H="Tab1: 2018 Commun Dwelling"
*Table 1, 2018 Community Dwelling & Homebound: including standard deviations 
use "${intpath}\temp_commun_dwell_2018_no_nsoc.dta", clear
cd "${output}"

set seed 100 
sort spid wave 

svyset spid [pw=anfinwgt], strata(varstrat)

**Table 1: 2018 Cohort Weighted 
preserve

local cvars1 age
local ivars1 prob_dem educ_hs_ind medicaid fin_strain 
local catvars1 
***insert income & poverty thresh variable 
local cvars2
local ivars2 female married hb shb indep_hb
local catvars2  race3
local cvars3 
local ivars3 adl_dep iadl_dep sr_phq2_depressed  proxy_ivw
local catvars3 
local cvars4 sr_numcondit
local ivars4  
local catvars4 
local cvars5 
local ivars5 ind_paid_helper soc_iso livealone
local catvars5
local cvars6 n_children n_helpers
local ivars6 
local catvars6  
local cvars7 tot_hrswk_help_i
local ivars7 hrs_help_2cat
local catvars7 
local cvars8 
local ivars8 rcfres metro_ind cohesion_knowwell cohesion_willing cohesion_peop cohesion home_disorder_area home_disorder_clutter home_disorder_insd home_disorder_outsd //moved_last_5 moved_count //leave out moved* bc NR 
local catvars8 overallrankquart
*hb vars: hb shb indep_hb hb_n1 shb_n1 indep_n1 hb_p1 shb_p1 indep_p1    

gen n=1

forvalues i=1/8 {
	local cativars`i'
	foreach x of local catvars`i' {
		gen l`x'=.
		local lab : var label `x'
		label var l`x' "`lab'"
		di "`x'"
		local `x'
		levelsof `x', local(levels)
		foreach l of local levels {
			gen `x'`l'=`x'==`l' if !missing(`x')
			local lab : label `x' `l'
			label var `x'`l' "`lab'"
			local `x' ``x'' `x'`l'
}
		di "``x''"
		local cativars`i' `cativars`i'' ``x''
}
}

local rows
forvalues i=1/8 {
local rows `rows' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local part1 `cvars1' `ivars1' `catvars1' `cativars1'
local part2 
forvalues i = 2/8 {
local part2 `part2' `cvars`i'' `ivars`i'' `catvars`i'' `cativars`i''
}

local ncount :  word count 1 1 
local pt1 : word count 1 1 `part1'
di `pt1'

local pt2: word count 1 1 `part2' `part1' 1 
di `pt2'

local rn : word count 1 `rows' 1 1 1 1 1 1 1 
di `rn'

local r=1
local c=1

*****insert incid dem full sample here 
mat tab=J(`rn',7,.)
mat stars=J(`rn',7,0)

**********************
*Sample Population 
svy: mean n
mat tab[`r',`c']==e(N_psu)
local r = `r'+1 
mat tab[`r',`c']==e(N_pop) 
local r = `r'-1
svy, subpop(if hb==0): mean n
mat tab[`r',`c'+2]==e(N_sub) 
local r = `r'+1 
mat tab[`r',`c'+2]==e(N_pop) 
local r = `r'-1
svy, subpop(if hb==1): mean n
mat tab[`r',`c'+4]==e(N_sub)
local r = `r'+1 
mat tab[`r',`c'+4]==e(N_pop) 
local r = `r'+1

	foreach x of local cvars1 {
	svy: mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars1 {
		svy: mean `x'
		local out = e(b)[1,1]*100
		sum `x' 
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars1 {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy : mean `z'
		local out = e(b)[1,1]*100
		sum `z'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}

local r =`ncount'+1
local c = `c'+2

foreach t in 0 1 {
	foreach x of local cvars1 {
	svy, subpop(if hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars1 {
	svy, subpop(if hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy: tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars1 {
		svy, subpop(if hb==`t'): mean `x'
		if `t'==1 {
		svy: tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
	local r=`ncount'+1
	local c=`c'+2
}

local r = `pt1'+1
local c = 1

***
*insert mi poverty & income quartile here (under preserve/restore cmd so mi won't run outside of do file). 
gen incquart = income_quart if imputed_inc1==aveincome 

gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh if !missing(poverty_thresh)
}

tempfile t1 
save `t1'

//bring in the imputations

mi import wide, imputed (incquart = income_quart1 income_quart2 income_quart3 income_quart4 income_quart5 ltpov=imppov1 imppov2 imppov3 imppov4 imppov5) 

mi estimate: svy: regress hb incquart 
***mi estimate, cmdok: test hb incquart
mat tab[`r',`c'+6]= e(p_mi)
mat stars[`r',`c'+6]=(e(p_mi)<.05) + (e(p_mi)<.01)
local r = `r'+1 
mi estimate: svy: proportion incquart 
mat tab[`r',`c']= e(b_mi)[1,1]*100
mat tab[`r'+1,`c']= e(b_mi)[1,2]*100
mat tab[`r'+2,`c']= e(b_mi)[1,3]*100
mat tab[`r'+3,`c']= e(b_mi)[1,4]*100
mi estimate:svy, subpop(if hb ==0): proportion incquart
mat tab[`r',`c'+2]= e(b_mi)[1,1]*100
mat tab[`r'+1,`c'+2]= e(b_mi)[1,2]*100
mat tab[`r'+2,`c'+2]= e(b_mi)[1,3]*100
mat tab[`r'+3,`c'+2]= e(b_mi)[1,4]*100
mi estimate:svy, subpop(if  hb ==1): proportion incquart
mat tab[`r',`c'+4]= e(b_mi)[1,1]*100
mat tab[`r'+1,`c'+4]= e(b_mi)[1,2]*100
mat tab[`r'+2,`c'+4]= e(b_mi)[1,3]*100
mat tab[`r'+3,`c'+4]= e(b_mi)[1,4]*100

local r = `r'+4

*poverty imputation* 
mi estimate: svy: mean ltpov
mat tab[`r',`c']= e(b_mi)*100
mi estimate:svy, subpop(if hb ==0): mean ltpov
mat tab[`r',`c'+2]= e(b_mi)*100
mi estimate:svy, subpop(if hb ==1): mean ltpov
mat tab[`r',`c'+4]= e(b_mi)*100
mi estimate: svy: reg ltpov hb
mat tab[`r',`c'+6]=e(p_mi)
mat stars[`r',`c'+6]=(e(p_mi)<.05) + (e(p_mi)<.01)
mi extract 0 

***********************
local r = `pt1'+7
local c = 1 

forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy: mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
	local r=`r'+1		
}
	foreach x of local ivars`i' {
		svy: mean `x'
		local out = e(b)[1,1]*100
		sum `x'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}												 
		local r=`r'+1
}
	foreach x of local catvars`i' {
		*svy, subpop(if hb==`t'): mean `x'
		local r=`r'+1
		foreach z of local `x' {
		svy : mean `z'
		local out = e(b)[1,1]*100
		sum `z' 
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}
			local r=`r'+1
			}
}
}

local r=`pt1'+7
local c = `c'+2

foreach t in 0 1 {
forvalues i=2/8 {
	foreach x of local cvars`i' {
	svy, subpop(if hb==`t'): mean `x'
	mat tab[`r',`c']=e(b)
	estat sd 
	mat tab[`r',`c'+1]=r(sd)[1,1]
		if `t'==1 {
			svy: reg `x' hb
			*svy: reg `x' hb if inlist(hb,`t',0)
			test hb 
			mat tab[`r',`c'+2]=e(p)
			mat stars[`r',`c'+2]=(e(p)<.05) + (e(p)<.01)
		}
		local r=`r'+1		
}
	
	foreach x of local ivars`i' {
	svy, subpop(if hb==`t'): mean `x'
	local out = e(b)[1,1]*100
	sum `x' if hb==`t'
	if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
	mat tab [`r',`c'] = `out'
	}
	else{
	mat stars[`r',`c']=3
	}
		if `t'==1 {
		capture svy: tab `x' hb  
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]= e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
}
		local r=`r'+1
}
	foreach x of local catvars`i' {
		svy, subpop(if hb==`t'): mean `x'
		if `t'==1 {
		svy: tab `x' hb
		*svy: tab `x' hb if inlist(hb,`t',0)
		mat tab[`r',`c'+2]=e(p_Pear)
		mat stars[`r',`c'+2]=(e(p_Pear)<.05) + (e(p_Pear)<.01)
		}
		local r=`r'+1
		foreach z of local `x' {
		svy, subpop(if hb==`t'): mean `z'
		local out = e(b)[1,1]*100
		sum `z' if hb==`t'
		if r(mean)*r(N)>=11 & r(mean)*r(N)<=r(N)-11{
		mat tab [`r',`c'] = `out'
		}
		else{
		mat stars[`r',`c']=3
		}

			local r=`r'+1
			}
}
}

	local r=`pt1'+7
	local c=`c'+2
}	

mat rownames tab=  N "Estimated N" `part1'  "Income Quartile" "Bottom Income Quart" "2nd Income Quart" "3rd Income Quart" "Top Income Quart"  "Poverty Threshold" `part2'   

frmttable using "tab1_commun2018_`c(current_date)'.rtf", statmat(tab) title("Community Dwelling 2018 Cohort w/ Survey Weights") ctitles("" "Full Sample" "SD" "non-HB Sample" "SD" "HB Sample" "SD" "P-value") varlabels sdec(2,2,2,2) annotate(stars) asymbol(*,**,NR) note("Cohesion Categories: Agree A Lot vs Agree(Little)/Do Not Agree" "P-values for homebound relative to non-homebound group" "Missing ADL & IADL is categorized as No ADL/IADL") replace

restore


H="2018 Logit model "
*2018 Logit Tables w/o Merging NSOC 

cd "${output}"
use "${intpath}\temp_commun_dwell_2018_no_nsoc.dta", clear
set seed 100 
sort spid wave 

svyset spid [pw=anfinwgt], strata(varstrat)

***poverty
gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)
label var ltpov "Poverty Threshold"
forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh  if !missing(poverty_thresh)
}

tempfile t1
save `t1'

//bring in the imputations
mi import wide, imputed(ltpov=imppov1 imppov2 imppov3 imppov4 imppov5)
*(15 values of imputed variable ltpov in m>0 updated to match values in m=0)

****Current Logit Model**********
preserve
outreg, clear 
local origvars age prob_dem i.race3 female educ_hs_ind adl_dep iadl_dep rcfres i.comorbid metro_ind ltpov hrs_help_2cat sr_phq2_depressed low_quart_overall_ltss

***outreg of logit models 
mi estimate, or:svy: logit hb `origvars' 
mi estimate, post 

outreg using "2018_Logit_Commun_Dwell_`c(current_date)'.rtf", replace stats(e_b e_ci p) varlabels title(" 2018 Community Dwelling & Concurrently HB Logit Model ") note("OR is displayed. Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers.")

*60 missing both hseduc & race, 9 missing in only educ & 10 missing  only race. 

restore

*Among those with incident dementia, people who are Hispanic have ## times the odds of being homebound compared to those who are not Hispanic 
*Among those who are incident dementia and Black, people with 5+ comorbidities have ## times the odds of being homebound compared to those with less than 2 comorbidities  



H="stcox"
/*
Updated by CY 
Date Updated: 3/16/2021 
*stcox to see who survives/remains in community, getting %s 
*/
****************


cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
outreg, clear
***below is KM & Competing Risk Models that use multiple imputation for Poverty Variable***
set seed 100 
sort spid wave


gen allfail = fail!=0

*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

keep if incid ==1

local demovars1 age i.race3 female educ_hs_ind  rcfres i.comorbid sr_phq2_depressed adl_dep hrs_help_2cat

stset  yrs_to_fail  [pw=anfinwgt], failure(allfail==1) 
sts graph

*run serset use, clear in the stata command window!
*doesn't work from do file 
list
stop




H="Cumulative Incid. Function "
/*
Updated by CY 
Date Updated: 4/20/2021 
*cif curves 
*/
****************
cd "${output}"
use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear
outreg, clear
***below is KM & Competing Risk Models that use multiple imputation for Poverty Variable***
set seed 100 
sort spid wave


*************get correct weights for 2011 cohort 
replace anfinwgt = an2011wgt if wave >=5 & wave <.
svyset spid [pw=anfinwgt], strata(varstrat)

keep if incid ==1

***poverty & income imputation set up 
//generate whatever variable you want to be the income variable, with missingness where imputed, using average income and poverty line (set ltpov to missing if income is imputed)

*gen incquart = income_quart if imputed_inc1==aveincome 

*gen ltpov=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)| missing(imputed_inc1)

/*forvalues i=1/5 {
               gen imppov`i'=imputed_inc`i'<=poverty_thresh if !missing(poverty_thresh)
}
*/

gen lowincquart = .
label var lowincquart "Lowest Income Quartile"
forvalues i = 1/5 {
	gen low_inc`i'=income_quart`i'==1 
}

tempfile t1 
save `t1'

//bring in the imputations
mi import wide, imputed(lowincquart = low_inc1 low_inc2 low_inc3 low_inc4 low_inc5)
mi stset  yrs_to_fail  [pw=anfinwgt], failure(fail==1) 

local demovars1 age i.race3 female educ_hs_ind  rcfres i.comorbid sr_phq2_depressed adl_dep lowincquart hrs_help_2cat

mi estimate, post hr: stcrreg `demovars1', compete(fail==2 3) 
outreg using "incidem_wtd_compet_risks_`c(current_date)'.rtf", replace varlabels stats(e_b e_ci) title(Hazards Model for Being Homebound) note("Referent race is non-Hispanic White & Other. Referent comorbidity is <2 comorbidities ")

*forest plot
estimates store vars 
label var age "Age"
coefplot vars, eform xline(1) xtitle(Sub Hazards Ratios) name(forestplot, replace)  note("Referent Race: White & Others. Referent Comorbidities: <2 Comorbidities. Referent Num Helpers: No Helpers.", size(vsmall) span)

mi unset
*stset  yrs_to_fail [pw=anfinw], failure(fail==1)  

**race variable model only**
stcrreg i.race3, compete(fail=2 3)
stcurve,  cif name(race_only, replace)

**model with all vars**
local demovars1 age i.race3 female educ_hs_ind  rcfres i.comorbid sr_phq2_depressed adl_dep lowincquart hrs_help_2cat
forvalues j =1/5{
tempfile adj`j'
replace lowincquart=income_quart`j'==1  
stcrreg `demovars1', compete(fail==2 3)   
stcurve, cif outfile(`adj`j'') xtitle("Analysis Time") 
}

clear
forvalues j=1/5 {
	append using `adj`j''
}

collapse ci1, by(_t)
twoway line ci1 _t, ytitle("Cumulative Incidence") xtitle("Analysis Time (years)")  name(cif_dem_hb, replace) xlabel(1(1)7)



H="Changelog"
********************Change Log******************** 
Updates:
4/20/21
------
add forestplot 

3/3/21
------
use categorical comorbidities count for competing risk 
2/19/20
-------
cumulative incidence functions, imputed income quartiles 

2/8/21
-------
survival analysis, competing risks and cox model  

12/14/20
-------
update tables & analysis & drafts with ADL dependency (any ADL help) isntead of ADL difficulty. 

11/16/20
-------
decided to use w/ lowest overall ltss rank as reference group, update draft with new numbers and tables 

11/9/20
-------
Cannot email LTSS percents, except in logit model!! Complimentary disclosure! Logit models to show are overall ranks (lowest & highest), ok to incl. overall quarts in table 1, update draft with new numbers 

10/27/20
-------
use 939 sample b/c the two removed are incident but missing prior status in prior ivws. update manuscript with this. (spid==10007831|spid ==10010346) 

adding LTSS var (Evan & confirm geographic data), email from Jenny on 10/23, new comparison group using 2018 community dwelling sample (new table 1 & logit model, adding prob dem to this logit model), edits to paper  

8/31/20
--------
Remove NR variables from table 1. keep the comorbidities categories (<2, 2-4, 5+) in the logit model but will need to justify it. 

8/17/20
--------
KO spoke w/ JR-most likely not including outcomes to this project. add social isolation to table 1 & take out IADL from logit, in case follow up time is needed in future: Average follow up time is 1.8 waves. 
tab followup_dem if incid ==1
remove depression from comorbidities count, use 40 hours of help as dichotomous, dichot ADL & IADL, changed chart 


8/10/20
---------
Simplify bar chart: use all 4 HB categories at incident dementia (split up SHB) & remove N1 from visual- mention in discussion that it is beyond scope of paper. Use a binary ADL & IADL of 0 vs 1+ to table 1, Take out IADL from logit models b/c losing 25 observations.  Dichotomize 40hrs + help and add to logit model & check if it is correlated to pd help indicator. remove paid help indicator. take out depressino from comorbidities count b/c adding depression itself into the models, Hold off on discussion of race tables (maybe for supplementary) but right now, too small of a sample size for Hispanic population. 


8/3/20
---------
use incid dem for Markov model? - Scrap since it runs on full dataset now,  consider comparison groups for NSOC sample(NSOC for other serious illnesses?) - concern for small sample sizes, reorganize Tables 
if looking at SP's characteristics of ppl who have caregivers, better to use NSOC eligible population, not NSOC completed. Current SP (91ppl) table on completed NSOCS cannot be used as sample population estimate 

7/29/20
----------
Redefine homebound to simplest version: HB Status at Incident Dementia Wave. (not HB Status at Incident Dementia Wave or at N1), will redo & send out new tables. Check for missingness & add new column for % missing, (of incident dementia sample) for internal use.  Reorganize Table 1 by demographics/community/clinical function after comparing old & new tables to id signif changes, For help variable - identify if paid help or not & indicate in methods section & at bottom of table. Create var to look at N1 for all incid dem sample, and another var to look at N1 only among those HB at Incid Dem. Present HB status in pie chart or bar chart, maybe bar chart w/ HB Stat @ N1, T0, P1. Make note of - in discussion that 50% of res care moved in last 5 yrs 

Among 1287 community dwelling individuals without dementia identified in 2011 cohort followed for 7 years (2-8 waves) -we identified 941 newly identified probable dementia cases. - based on flow 

7/27/20
----------
NSOC Table by race: Sample Size is too small & deleted table after presenting at KO mtg. To create a corresponding SP table for the 139 NSOC ivws -incl. pd cg (email file path b/c #s might be small). Add vars from Jenny's geronologist re. strain. (time til/ relative to strain). Add respite var to NSOC table. Create visual for people's HB status, among Incid Dementia sample. Crosstab ppl who moved in last 5 years & res care. Check for missingness from vars( vars from logit models & table 1 - address signif missingness. Lit Search for onset/incident dementia in NHATS.
 
7/20/20 
-----------
details in email sent out (7/20) - added ivw proxy to NHATS SP Tables, created Caregiver Table 1 for caregivers concurrent w/ incident dementia sample (dropped recently deceased beneficiaries), created Table 1 & Bivariate Table Stratified by Race. To create a table by Caregiver Race(need to merge in from RAW NOSC 2015) 

7/7/20
-----------
sent new table & logit models to KO & JR, Add: among those who are non-hb, how many become hb in next wave, How many moved within the last 5 years of incident dementia, and how many moved to assisted living? (categorical, relative to not moving in past 5 yrs); check stratify by race, not multivariate! 
???For moved in last 5 years, do we want to include those who moved the same year as incident dementia??? (currently included) 


6/29/20 
-----------
Analysis 1, Table 1: changes from KO email on 6/29/20 (add new vars to Table 1- envrtl measures, social cohesion, types of house, etc), add caregiving strain variables 
Analysis 1, Logit Model: remove living alone from logit model, Stratify analyses by race:  Hispanic, white, black - for description section,
Analysis 2: KO & Jenny to discuss abt Caregiving before/after incident dementia diagnosis (pd care, care hours, etc) 
touch base w/ Evan & Naomi to check her incident cancer & NHATS on 7/9/20

6/22/20
------------
create flowchart of SPIDS & CGs before/concur/after incident dementia wave

6/15/20
-------------
use corrected NHATS income var dataset(from MH) & add incidementia full 2011 cohort to table 1. At time of dementia, caregiving, hbstatus, comorbidities, adls. Use weighted variables. Explore family systems & support (might be different by race) Take a look at NSOC (cg ivws-pd/unpd) @ incid dementia wave (cg: yrs 1,5,7) 

6/1/20 CY
-------------
from NHATS technical paper, use indivs who entered at 2011 only. add survey weights for 2011, correct poverty threshold % and add income quartiles, Hrs of assistance to Table 1 (6/10/20) 

5/26/20 CY
---------
use new metro indicator & update with poverty indicator & new income variable(correct missingness), check multicollinearity, carry forward poverty thresh for indiv in missing incid dementia sample. For % of poverty level: take % poverty level and make discrete. Divid everything by poverty level & everything less than/equal to 1 is below poverty level. (ie. if poverty level is 10,000 and person makes 60,000, person is 600% poverty level). Poverty & income is correlated, so just use poverty var. mi import for multip imputations for poverty. 

5/18/20 CY
------------
KO Mtg: use 3 Category of ADL Counts, with no ADL as reference group in logit models instead of Help 1+ ADL. Consider adding severe dementia into model but unsure how it would be interpreted.. 
email from KO 5/21 & 5/22 - use continuous ADL instead of categorical, lives alone, comorbidities 
Vars with Missing Observations: 19 missing race, 18 missing Education, 7 missing ADL counts 

5/11/20 CY
------------
@KO Mtg: ADL had highest OR (>4+), decide to look at ADL and severe dementia. Does functional impairment lead to HB? use Jenny's severe dementia categories or existing ADL categories. 
Dementia Cats: No dem, poss dem, or prob dem
How many have severe dementia @ incid dementia? Not severe Dementia & not hb? Severe Dem & hb?
ADLn1 correlated w/ ADL impairments  

5/7/20 CY
------------
Logit Models & best model fits for demographics 
when all demog vars are incl in the model, being in bottom income group is best model (lowest aic)
*commented portion of this table was done to determine which model was better to use first. to incl "finhlpfam section8 govtasst home_disorder_clutter" or not to. AIC and BIC was better in model without those vars & thus excluded from Model. 
Living arrangement vs Married>(both had same results in model)>livearrang selected b/c most unmarried were in "LiveAlone or Live w/ Others", most married "Lived w/ Partners or lived with partners +Others"
Combined White w/ Other Race b/c other race had small numbers 
*Chosen Demographic Model: logit incicat age i.race3 i.livearrang rcfres bottomincome female  educ_hs_ind srh_fp shb_n1 adl_imp_n1 adl_impair & (n_helpers/ind_paid_helper/ind_help40hrs)

4/24/20 EBL
-------------
Table: demographic and caregiving characteristics of concurrently hb & indep (2 categories) and hb@n1, concurr hb & not hb (3 cats) 

4/10/20 CY
------------ 
Incident dementia & homebound status before/concurrent/after incident dementia wave 

4/3/20 CY
------------
Sample derivations of incident dementia

Old Vars No Longer Needed
-----------------------
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8
label var income_adj "Income, 2018$"

*get incr/decr/same of ADL counts from previous wave 
*0 "Same" 1 "increase/more ADLs" 2 "decrease/less ADLs"
sort spid wave 
by spid: gen adl_change = 0 if adl_diff_index == adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 1 if adl_diff_index > adl_diff_index[_n-1] & wave-1==wave[_n-1]
by spid: replace adl_change  = 2 if adl_diff_index < adl_diff_index[_n-1] & wave-1==wave[_n-1]

gen adl_same_count=adl_change==0
gen adl_incr_count=adl_change==1
gen adl_decr_count=adl_change==2

label var adl_same_count "ADL count Same as Prior Wave"
label var adl_incr_count "ADL count Increased from Prior Wave"
label var adl_decr_count "ADL count Decreased from Prior Wave"


*in top quartile of income 
gen topincome = income_quart==4
gen bottomincome = income_quart==1
label var bottomincome "In Bottom Income Quartile"


*create severe dementia var 
capture drop a1
egen a1= rowtotal(toil_jenny dres_jenny bath_jenny meds_jenny bank_jenny)
capture drop severe
gen severe=1 if a1==5

*gen sev_dem=0
*replace sev_dem=1 if severe==1 & prob_dem==1

*severe dementia & hb status 
gen sev_dem_hb = sev_dem==1 & hb==1
gen sev_dem0_hb0 = sev_dem==0 & hb==0 
gen sev_dem1_hb0 = sev_dem==1 & hb==0 
gen sev_dem0_hb1 = sev_dem==0 & hb==1
label var sev_dem "Severe Dementia"
label var sev_dem_hb "Severe Dementia & HB"
label var sev_dem0_hb0 "No Severe Dementia & Not HB"
label var sev_dem1_hb0 "Severe Dementia & Not HB"
label var sev_dem0_hb1 "No Severe Dementia & HB"

*create 3 categories of counts of adls 
gen adl_3cat_counts = 0 if adl_index==0
replace adl_3cat_counts = 1 if adl_index >=1 & adl_index <4
replace adl_3cat_counts = 2 if adl_index >=4 & adl_index <.
label def adl_3cat_counts 0 "No ADL Counts" 1 "1-3 ADL Counts" 2 "4-6 ADL Counts"
label values adl_3cat_counts adl_3cat_counts
tab adl_3cat if incid ==1

*indicators for counts of adls 
gen ind_no_adl_counts=adl_3cat==0 
label var ind_no_adl_counts "No ADL Counts"
gen ind_one_adl_counts=adl_3cat==1
label var ind_one_adl_counts "1-3 ADL Counts"
gen ind_four_adl_counts=adl_3cat==2
label var ind_four_adl_counts "4-6 ADL Counts"

* don't need poverty indicators below b/c have ltpov var
*gen poverty indicator for ppl income is less than poverty threshold 
/*
gen poverty_ind= poverty_thresh >= aveincome & poverty_thresh!=.
replace poverty_ind =. if poverty_thres==.
tab poverty_ind
label var poverty_ind "Poverty Indicator"

*poverty percent 
gen pov_perc = aveincome/poverty_thres if poverty_thresh !=. //if hhm==1
gen ind_pov_perc = pov_perc<=1
*/

H="Dementia Status after Incident "
/*
Updated by CY 
Date Updated: 3/6/2021 
*Get Dementia trajectory for the incident dementia population. Stay w/ incident dementia/no prob_dem
*/
****************

use "${intpath}\temp_incid_dementia_no_nsoc.dta", clear 
keep if wave>=firstdem

by spid: gen rows=_N
by spid: egen demsum = total(prob_dem)

gen srconfirmed= sr_dementia_ever==1 
label var srconfirmed "ever self reported dementia (11111)"

gen good = rows ==demsum & sr_dementia_ever !=1
tab good if firstdem==wave 
label var good "dementia all waves (11111) & no self report"
*75.61% of people have ongoing dementia after incidence (11111etc)
*25% have no prob dementia at some point 


gen bad = demsum==1 & rows >=2 
tab bad if firstdem==wave 
*12.25% of ppl have no dementia after their incident wave 
label var bad "no dementia after incid(10000)"

gen ok = 1 if firstdem ==wave
replace ok = 2 if prob_dem==1 & wave ==firstdem+1 & spid ==spid[_n-1] & firstdem[_n-1]==wave[_n-1]

by spid: egen fine = max(ok)
replace fine = 0 if fine !=2
replace fine = 1 if fine ==2 & good==0 & bad ==0 & srconfirmed==0
replace fine = 0 if fine !=1
label var fine "Incid & dem @ nxt wave, DK dem stat after (11---) "
tab fine if firstdem ==wave
*% of 2: 36 ppl (3.83%) have two consecutive waves of prob_dem. (has dementia in wave after incident dementa), regardless of what happens after those two waves 

gen d101=1 if firstdem==wave 
replace d101 = 2 if prob_dem==0 & wave ==firstdem+1 & spid ==spid[_n-1] & firstdem[_n-1]==wave[_n-1]
replace d101 = 3 if prob_dem==1 & wave ==firstdem+2 & spid ==spid[_n-2] & firstdem[_n-2]==wave[_n-2]

by spid: egen sk101 = max(d101)
replace sk101 = 0 if sk101 !=3
replace sk101 =1 if sk101 ==3 & fine ==0 & good==0 & bad ==0 & srconfirmed==0
replace sk101 = 0 if sk101 !=1
label var sk101 "No dem wave btwn 2 dem waves, DK dem stat after (101--)"

tab sk101 if firstdem==wave 
*% of sk101, 48 ppl, 5.11% of people have one skipped probable dementia wave. (101: incidem wave 2, no probdem wave 3, probdem at wave 4 )

gen mix=1 if firstdem==wave 
replace mix = 2 if prob_dem==0 & wave ==firstdem+1 & spid ==spid[_n-1] & firstdem[_n-1]==wave[_n-1]
replace mix= 3 if prob_dem==0 & wave ==firstdem+2 & spid ==spid[_n-2] & firstdem[_n-2]==wave[_n-2]

by spid: egen mixbad = max(mix)
replace mixbad = 0 if mixbad !=3 
replace mixbad =1 if mixbad==3 & fine ==0 & good==0 & bad ==0 & sk101==0 & srconfirmed==0
replace mixbad = 0 if mixbad !=1
tab mixbad if firstdem==wave 
label var mixbad "2 waves after incid are no dem, DK dem stat after (100--)"

*% of mixbad, 30 ppl, 3.19% of people have incident dementia, and the following 2 waves are not probable dementia, regardless of what happens in the following waves. 100, following wave doesn't matter: 1001, 1000, 1000001 etc) 

local list srconfirmed good fine sk101 mixbad bad
local rn : word count `list' 1

mat tab = J(`rn',2,.)
local r = 1 
local c = 1

sum sr_dementia_ever 

foreach x of local list {
sum `x' if firstdem==wave
mat tab[`r',`c']= r(N)*r(mean)
mat tab[`r',`c'+1] = r(mean) *100
local r = `r'+1
}

gen n = 1 
sum n if firstdem ==wave 
mat tab[`r',`c']= r(N)*r(mean)
mat tab[`r',`c'+1] = r(mean) *100

mat rownames tab = `list' "Total"
mat list tab

frmttable, statmat(tab) ctitles("" "n" "%") varlabels title("Dementia Status after Incident Wave") note("dementia status after incident dementia." "DK: don't know" "Ex in parantheses are for 5 waves""1: wave w/ dementia" "0: wave w/ dementia" "-:dem status varies(0 or 1) at that wave, but not as above " )

*Exhaustive list of all the concatenations of probable dementia or not, after incident dementia 

gen s0 = "I" if firstdem == wave 

forvalues i = 1/6 {
gen s`i' = "D" if prob_dem==1 & wave ==firstdem+`i'
replace s`i' = "N" if prob_dem==0 & wave==firstdem+`i'
}

gsort spid -wave 
forvalues i = 1/6{
by spid: carryforward s`i', replace
}


gen demstat = s0+s1+s2+s3+s4+s5+s6 if firstdem ==wave

sort spid wave 
by spid: carryforward demstat, replace
drop s0-s6
tab demstat if firstdem==wave


*Time to Death among those who don't have probable dementia after incidence

preserve 
keep if bad ==1 
tab rows bad if firstdem==wave
*looking at how many waves until death (10xxx)

mat tab = J(7,1,.)
local r = 1 
local c = 1

forvalues i =2/7 {
sum bad if firstdem==wave & row==`i'
mat tab[`r',`c']= r(N)
local r = `r'+1
}

sum n if firstdem ==wave 
mat tab[`r',`c']= r(N)

local versions 10x 100x 1000x 10000x 100000x 1000000x 
mat rownames tab = `versions' "Total"
mat list tab

frmttable, statmat(tab) ctitles("" "n") varlabels title("Time to Death among those who don't have probable dementia after incidence") note("1: wave w/ dementia" "0: wave w/ dementia" "x: died at wave")
restore 

*Concatentation of possible dementia among those who don't have probable dementia after incident dementia 
gen t0 = "I" if wave==firstdem 

forvalues i=1/6{
gen t`i' = "P" if dem_3_cat==2 & wave==firstdem+`i'
replace t`i' = "N" if dem_3_cat==3 & wave==firstdem+`i'
}

gsort spid -wave 
forvalues i = 1/6{
by spid: carryforward t`i', replace
}

*keep if firstdem ==wave
gen possdem = t0+t1+t2+t3+t4+t5+t6 if firstdem ==wave

sort spid wave 
by spid: carryforward possdem, replace
drop t0-t6
tab possdem if firstdem ==wave & bad ==1

***All dementia status concatenations, incl prob, possible, nodem 
/*
*D: probable dementia 
*P: possible dementia 
*N: no dementia 
*/
gen a0 = "I" if wave==firstdem 

forvalues i=1/6{
gen a`i' = "D" if dem_3_cat==1 & wave==firstdem+`i'
replace a`i' = "P" if dem_3_cat ==2 & wave==firstdem+`i'
replace a`i' = "N" if dem_3_cat ==3 & wave==firstdem+`i'
}

gsort spid -wave 
forvalues i = 1/6{
by spid: carryforward a`i', replace
}

*keep if firstdem ==wave
gen allstat = a0+a1+a2+a3+a4+a5+a6 if firstdem ==wave

sort spid wave 
by spid: carryforward allstat, replace
drop a0-a6
tab allstat if firstdem ==wave 



