= V4 Outline MultiLine NoSorting TabWidth=30

H="First Heading"
/* 
********************HEADING******************** 

Project Name: Homebound Trajectories

Date Started: 12/4/2019

Primary Investigator: Katherine Ornstein
Funding Source:

Created by: MH

Primary Analyst: MH
Secondary Analyst: EBL

Datasets Used: NHATS

Simple Outline: Using NHATS data to further homebound R01. Using homebound and income idea, we look at what happens after the incident homebound stay. 


*/
 
//STATA
// Global Macros use $ symbol to be called. 

//Intermediate Data Path
//global intpath "E:\nhats\data\Projects\..."

// Final Data Path
global datapath "D:\NHATS\Shared\base_data\NHATS cleaned"

//Log files path
global logpath "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"


H="Homebound decision matrix"
/*

Created by: MH
Date Created: 12/19/2019

Updated by:
Date Updated:

Description: Inital data setup for homebound trajectories we are following people 
homebound status. 



**************************************************
*/
local date = subinstr("$S_DATE"," ","_",.) 
local name ko_hb_traj_`date'
di "`name'"

capture log close 
clear all

set more off
version 12
set linesize 80


cd ${logpath}
log using `name'.smcl, text replace

********

use "${datapath}\sp_round_1_8.dta" if lml==0, clear

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015



//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

bys spid wave: egen tot_hlp_hrs=sum(tot_hrswk_help_i) 


sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres

gen homebound_semi=0 if !missing(homebound_cat) & !nhres
replace homebound_semi=1 if inlist(homebound_cat, 2, 3) & !nhres

gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1 
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 
label values status status
label var status "Status this wave"

//checking to make sure everyone has a status at wave 1
sort spid wave
by spid: gen start=1 if wave==1 & status!=.
by spid: carryforward start, replace

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

drop if mstat==1


sort spid wave
by spid: egen lw=max(wave)
label var lw "Last Time observed"

sort spid wave
gen status_nw=1 if spid==spid[_n+1] & wave+1==wave[_n+1] & sp_ivw[_n+1]==1 & !missing(homebound[_n+1])
replace status_nw=2 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==1
replace status_nw=3 if spid==spid[_n+1] & wave+1==wave[_n+1] & inlist(homebound_cat[_n+1],2,3)
replace status_nw=4 if spid==spid[_n+1] & wave+1==wave[_n+1] & nhres[_n+1]==1
replace status_nw=5 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==1 & lw==wave
replace status_nw=6 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==0 & lw==wave
label define status_nw 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH Resident" 5 "Died" 6 "LFU"
label values status_nw status_nw
label var status_nw "Status next wave"

sort spid wave
by spid: egen hb_min=min(wave) if homebound==1
gen inchb=0
replace inchb=1 if hb_min==wave 

by spid: egen ever_hb=max(hb)

//Looking at the wave right after incident homebound.
gen wave_after_inchb=0
by spid: replace wave_after_inchb=1 if spid[_n+1]==spid & wave[_n+1]==wave+1 & inchb==1
//this really tells if hb in this wave

gen next_wave_com=0
replace next_wave_com=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_hb=0
replace next_wave_hb=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]==1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_semi=0
replace next_wave_semi=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]==1

gen next_wave_nhres=0
replace next_wave_nhres=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==1 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_lfu=0
replace next_wave_lfu=1 if inchb==1 & wave_after_inchb==0 & died_12==0 & spid!=spid[_n+1]

gen wave_after=0
replace wave_after=1 if wave_after_inchb==1

//wave_after_inchb1 is the correct one
gen wave_after_inchb1=0
replace wave_after_inchb1=1 if spid==spid[_n-1] & wave_after_inchb[_n-1]==1 & inchb[_n-1]==1

foreach x in next_wave_com next_wave_hb next_wave_semi next_wave_nhres next_wave_lfu{
tab wave_after_inchb `x'
}


gen a=1 if wave_after_inchb1==1 & independent==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid

tab wave_after_inchb1 help_go_out if next_wave_com[_n-1]==1

gen diff_help_out=0
replace diff_help_out=1 if hasdifficulty==1 | needshelp==1

sort spid wave
gen hb_still=0
replace hb_still=1 if hb_min[_n-1]==hb_min & spid[_n-1]==spid & hb_min!=.

tab wave_after_inchb next_wave_com
tab needshelp if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab hasdifficulty if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab help_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid,m
tab independent if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m

tab freq_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1, m


tab surgery if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1
tab rehab if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab device_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab ind_imp_goout if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_helpers=.
sort spid wave
by spid: replace hb_helpers=n_helpers[_n+1]-n_helpers

tab hb_helpers if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_hours=.
sort spid wave
by spid: replace hb_hours=tot_hlp_hrs[_n+1]-tot_hlp_hrs

tab hb_hours if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

xtset spid wave

tab status status_nw if wave==1, row nofreq 
tab status status_nw if wave==2, row

tab status status_nw if wave==2 & spid[_n-1]==spid & status[_n-1]==2, row

xttrans status if wave==1 | wave==2 , freq


sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace
drop time
sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 

gen hb1=1 if homebound==1 & wave==1

sort spid wave


tab status_nw [aw=anfinw] if time==1 & wave==3

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==2 & wave==3 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}


log close
translate `name'.smcl `name'.pdf
exit



H="Decision Tree matrix"
/*

Created by: MH
Date Created: 12/19/2019

Updated by:
Date Updated:

Description: Inital data setup for homebound trajectories we are following people 
homebound status. 



**************************************************
*/
local date = subinstr("$S_DATE"," ","_",.) 
local name ko_hb_traj_`date'
di "`name'"

capture log close 
clear all

set more off
version 12
set linesize 80


cd ${logpath}
log using `name'.smcl, text replace

********

use "${datapath}\sp_round_1_8.dta" if lml==0, clear

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015



//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

bys spid wave: egen tot_hlp_hrs=sum(tot_hrswk_help_i) 


sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres

gen homebound_semi=0 if !missing(homebound_cat) & !nhres
replace homebound_semi=1 if inlist(homebound_cat, 2, 3) & !nhres

gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1 
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 
label values status status
label var status "Status this wave"

//checking to make sure everyone has a status at wave 1
sort spid wave
by spid: gen start=1 if wave==1 & status!=.
by spid: carryforward start, replace

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

drop if mstat==1


sort spid wave
by spid: egen lw=max(wave)
label var lw "Last Time observed"

sort spid wave
gen status_nw=1 if spid==spid[_n+1] & wave+1==wave[_n+1] & sp_ivw[_n+1]==1 & !missing(homebound[_n+1])
replace status_nw=2 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==1
replace status_nw=3 if spid==spid[_n+1] & wave+1==wave[_n+1] & inlist(homebound_cat[_n+1],2,3)
replace status_nw=4 if spid==spid[_n+1] & wave+1==wave[_n+1] & nhres[_n+1]==1
replace status_nw=5 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==1 & lw==wave
replace status_nw=6 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==0 & lw==wave
label define status_nw 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH Resident" 5 "Died" 6 "LFU"
label values status_nw status_nw
label var status_nw "Status next wave"

sort spid wave
by spid: egen hb_min=min(wave) if homebound==1
gen inchb=0
replace inchb=1 if hb_min==wave 

by spid: egen ever_hb=max(hb)

//Looking at the wave right after incident homebound.
gen wave_after_inchb=0
by spid: replace wave_after_inchb=1 if spid[_n+1]==spid & wave[_n+1]==wave+1 & inchb==1
//this really tells if hb in this wave

gen next_wave_com=0
replace next_wave_com=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_hb=0
replace next_wave_hb=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]==1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_semi=0
replace next_wave_semi=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==0 & died_12==0 & homebound_semi[_n+1]==1

gen next_wave_nhres=0
replace next_wave_nhres=1 if wave_after_inchb==1 & spid==spid[_n+1] & homebound[_n+1]!=1 & nhres[_n+1]==1 & died_12==0 & homebound_semi[_n+1]!=1

gen next_wave_lfu=0
replace next_wave_lfu=1 if inchb==1 & wave_after_inchb==0 & died_12==0 & spid!=spid[_n+1]

gen wave_after=0
replace wave_after=1 if wave_after_inchb==1

//wave_after_inchb1 is the correct one
gen wave_after_inchb1=0
replace wave_after_inchb1=1 if spid==spid[_n-1] & wave_after_inchb[_n-1]==1 & inchb[_n-1]==1

foreach x in next_wave_com next_wave_hb next_wave_semi next_wave_nhres next_wave_lfu{
tab wave_after_inchb `x'
}


gen a=1 if wave_after_inchb1==1 & independent==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid

tab wave_after_inchb1 help_go_out if next_wave_com[_n-1]==1

gen diff_help_out=0
replace diff_help_out=1 if hasdifficulty==1 | needshelp==1

sort spid wave
gen hb_still=0
replace hb_still=1 if hb_min[_n-1]==hb_min & spid[_n-1]==spid & hb_min!=.

tab wave_after_inchb next_wave_com
tab needshelp if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab hasdifficulty if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m
tab help_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid,m
tab independent if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid, m

tab freq_go_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1, m


tab surgery if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1
tab rehab if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab device_out if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

tab ind_imp_goout if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_helpers=.
sort spid wave
by spid: replace hb_helpers=n_helpers[_n+1]-n_helpers

tab hb_helpers if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

gen hb_hours=.
sort spid wave
by spid: replace hb_hours=tot_hlp_hrs[_n+1]-tot_hlp_hrs

tab hb_hours if wave_after_inchb1==1 & next_wave_com[_n-1]==1 & spid[_n-1]==spid & independent==1

xtset spid wave

tab status status_nw if wave==1, row nofreq 
tab status status_nw if wave==2, row

tab status status_nw if wave==2 & spid[_n-1]==spid & status[_n-1]==2, row

xttrans status if wave==1 | wave==2 , freq


sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace
drop time
sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 

gen hb1=1 if homebound==1 & wave==1

sort spid wave


tab status_nw [aw=anfinw] if time==1 & wave==3

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==2 & wave==3 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==3 & wave==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==1 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==3 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==4 & wave==5 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==1 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==2 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==5 & wave==6 & status_nw[_n-4]==4 & status_nw[_n-3]==4 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==1 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}

forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==2 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==1 & status_nw[_n-3]==3 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==1 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==2 & status_nw[_n-2]==4 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==2 & status_nw[_n-3]==3 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==1 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==1 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==2 & status_nw[_n-2]==3 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}
forvalues i=1/6{
tab status_nw [aw=anfinw] if time==6 & wave==7 & status_nw[_n-5]==3 & status_nw[_n-4]==3 & status_nw[_n-3]==3 & status_nw[_n-2]==2 & status_nw[_n-1]==`i'
}






log close
translate `name'.smcl `name'.pdf
exit



H="Follow wave 2 incident hb"
//Part 1

clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2

gen nothbw1=.
replace nothbw1=1 if wave==1 & status!=2
sort spid wave
by spid: carryforward nothbw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if nothbw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.



sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 


sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

keep if wave==2

/*
stset lw [pw=anfinw], failure(f_stat==1) id(spid)

sts graph, note(fail=community dwelling)

stset lw [pw=anfinw], failure(f_stat==2) id(spid)

sts graph, note(fail=semi-homebound)

stset lw [pw=anfinw], failure(f_stat==3) id(spid)

sts graph, note(fail=nhres)

stset lw [pw=anfinw], failure(f_stat==4) id(spid)

sts graph, note(fail=death)

stset lw [pw=anfinw], failure(f_stat==1 2 3 4) id(spid)

sts graph, note(fail=all)
*/

stset lw [pw=anfinw], failure(f_stat==1) id(spid)
sts gen s2=s
stset lw [pw=anfinw], failure(f_stat==4) id(spid)
sts gen s3=s
stset lw [pw=anfinw], failure(f_stat==3) id(spid)
sts gen s4=s 
sts graph 

stset lw [pw=anfinw], failure(f_stat==2) id(spid)
sts gen s5=s

sts graph, addplot((line s2 lw, sort c(J) legend( order( 1 "Semi-Homebound" 2 "Community" 3 "Died" 4 "NH"))) (line s3 lw, sort c(J)) (line s4 lw, sort c(J)))


stset lw [pw=anfinw], failure(f_stat==1 2 3 4) id(spid)

sts graph, addplot((line s2 lw, sort c(J) legend( order( 1 "All" 2 "Community" 3 "Died" 4 "NH" 5 "Semi-Homebound"))) (line s3 lw, sort c(J)) (line s4 lw, sort c(J)) (line s5 lw, sort c(J)))



stset lw [pw=anfinw], failure(f_stat==4) id(spid)

local vars `age' ib4.income_quart /*fin_strain anydebt govtasst finhlpfam meals_wheels */ ///
female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem `cond' adl_diff_ind srh_fp sr_cond_cat2 sr_cond_cat3 ///
ind_paid_helper metro_ind northeast midwest south

stset lw [pw=anfinw], failure(f_stat==4) id(spid)

 stcox age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south i.income_quart
 
 
 
 
 
 /*
 
drop a
gen sample_full=.
replace sample_full=1 if sample==1 & status==2

drop if sample_full==.



replace adl_diff_ind=1 if adl_impair==1
label var adl_diff_ind "ADL difficulty or impairment"

tab status nwstatus if wave==1, m




sort spid wave
/*gen northeast=region==1
gen midwest=region==2
gen south=region==3
gen west=region==4
label var northe "Northeast"
label var midw "Midwest"
label var south "South"
label var west "West"*/
gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}


tab wave nwstat if wave<=4, row
tab nwsta status if wave==1 

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}
/*label define income_quart 1 "1st Income Quartile (Low)" 2 "2nd Income Quartile" ///
3 "3rd Income Quartile" 4 "4th Income Quartile (Highest)"
label values income_quart income_quart*/



gen prob_dementia=dem_3==1 if !missing(dem_3)
label var prob_dementia "Probable dementia"

by spid, sort: gen persontime=_N
replace persontime=firsthb if firsthb<persontime
replace persontime=firstnh if firstnh<persontime
label var persontime "Waves contributing information"
gen anydebt=creditdebt==1 | medpayno==1 if !missing(creditdebt) | !missing(medpayn)
label var anydebt "Credit card or medical debt"



sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace

sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 






//important to define the last wave in community 
sort spid wave
by spid: egen lw=max(wave)
replace lw=lw-1
label var lw "Last Time in the Community"




H="follow wave 2 incident home limited"
//Part 1
//Incident home-limited including semi-homebound


clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_hb_trajectories\output\output"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=1 if inlist(homebound_cat, 1,2,3) & !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound_cat)
replace status=2 if inlist(homebound_cat, 1,2,3)
replace status=3 if nhres==1
label define status 1 "Community, not HB" 2 "Home limited" 3 "NH resident" 4 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2

gen nothbw1=.
replace nothbw1=1 if wave==1 & status!=2
sort spid wave
by spid: carryforward nothbw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if nothbw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.



sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evernh=0 if firstcom<firstnh
replace evercom=0 if firstnh<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=4 if inlist(nwstatus,61)
replace nwstatus=6 if inlist(nwstatus,62,86)
replace nwstatus=7 if nwstatus>7
replace nwstatus=6 if died_12==1 & nwstatus==7
label define nwstatus 1 "Community, not home limited" 2 "Home limited, not incident" ///
3 "Incident home limited" 4 "NH Resident, not incident" ///
5 "Incident NH" 6 "Died" 7 "LFU"
label values nwstatus nwstatus
replace nwstatus=1 if inccom==1
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstat=4 if nhne==1
replace nwstat=5 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==6
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==7 & wave!=8
by spid: carryforward everlfu, replace 


sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 6,7) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if nwstatus==6 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==7 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

keep if wave==2

/*
stset lw [pw=anfinw], failure(f_stat==1) id(spid)

sts graph, note(fail=community dwelling)

stset lw [pw=anfinw], failure(f_stat==2) id(spid)

sts graph, note(fail=semi-homebound)

stset lw [pw=anfinw], failure(f_stat==3) id(spid)

sts graph, note(fail=nhres)

stset lw [pw=anfinw], failure(f_stat==4) id(spid)

sts graph, note(fail=death)

stset lw [pw=anfinw], failure(f_stat==1 2 3 4) id(spid)

sts graph, note(fail=all)
*/
 
gen sample_full=.
replace sample_full=1 if sample==1 & status==2

drop if sample_full==.



replace adl_diff_ind=1 if adl_impair==1
label var adl_diff_ind "ADL difficulty or impairment"

tab status nwstatus if wave==1, m




sort spid wave
/*gen northeast=region==1
gen midwest=region==2
gen south=region==3
gen west=region==4
label var northe "Northeast"
label var midw "Midwest"
label var south "South"
label var west "West"*/
gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}


tab wave nwstat if wave<=4, row
tab nwsta status if wave==2 

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}
/*label define income_quart 1 "1st Income Quartile (Low)" 2 "2nd Income Quartile" ///
3 "3rd Income Quartile" 4 "4th Income Quartile (Highest)"
label values income_quart income_quart*/



gen prob_dementia=dem_3==1 if !missing(dem_3)
label var prob_dementia "Probable dementia"

by spid, sort: gen persontime=_N
replace persontime=firsthb if firsthb<persontime
replace persontime=firstnh if firstnh<persontime
label var persontime "Waves contributing information"
gen anydebt=creditdebt==1 | medpayno==1 if !missing(creditdebt) | !missing(medpayn)
label var anydebt "Credit card or medical debt"



sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace

capture drop time
sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 



//NH
stset lw [pw=anfinw], failure(f_stat==2) id(spid)
sts gen s4=s 

//died
stset lw [pw=anfinw], failure(f_stat==3) id(spid)
sts gen s3=s 

//community
stset lw [pw=anfinw], failure(f_stat==1) id(spid)
sts gen s2=s

sts graph, addplot((line s4 lw, sort c(J) legend( order( 1 "Community" 2 "NH" 3 "Died"))) (line s3 lw, sort c(J)) )


stset lw [pw=anfinw], failure(f_stat==1 2 3) id(spid)

sts graph, addplot((line s2 lw, sort c(J) legend( order( 1 "All" 2 "Community" 3 "Died" 4 "NH" ))) (line s3 lw, sort c(J)) (line s4 lw, sort c(J)))


stset lw [pw=anfinw], failure(f_stat==1) id(spid)
sts graph if f_stat==1, note(failure=community dwelling)

stset lw [pw=anfinw], failure(f_stat==2) id(spid)
sts graph if f_stat==2, note(failure=NH)

stset lw [pw=anfinw], failure(f_stat==3) id(spid)
sts graph if f_stat==3, note(failure=died)

//community
stset lw [pw=anfinw], failure(f_stat==1) id(spid)

local vars age ib4.income_quart /*fin_strain anydebt govtasst finhlpfam meals_wheels */ ///
female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem `cond' adl_diff_ind srh_fp sr_cond_cat2 sr_cond_cat3 ///
ind_paid_helper metro_ind northeast midwest south


stcox age female black hisp married educ_hs_ind ib4.income_quart
outreg using home_limited, replace stats(e_b p e_ci) varlabels note(Wave 2 weights used) ctitles("" "HB Subhazard Ratio (1)" )

stcox age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart
outreg using home_limited, replace stats(e_b p e_ci) varlabels note(Wave 2 weights used) ctitles("" "HB Subhazard Ratio (2)" ) merge

stcox `vars'
outreg using home_limited, replace stats(e_b p e_ci) varlabels note(Wave 2 weights used) ctitles("" "HB Subhazard Ratio (3)" ) merge

//competing risks

stset lw [pw=anfinw], failure(f_stat==1) id(spid)

local vars age ib4.income_quart /*fin_strain anydebt govtasst finhlpfam meals_wheels */ ///
female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp sr_cond_cat2 sr_cond_cat3 ///
ind_paid_helper metro_ind northeast midwest south


stcrreg age female black hisp married educ_hs_ind ib4.income_quart, compete(f_stat=2 3)
outreg using home_limited_comp, replace stats(e_b p e_ci) varlabels note(Wave 2 weights used) ctitles("" "HB Subhazard Ratio (1)" ) 

stcrreg age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart, compete(f_stat=2 3)
outreg using home_limited_comp, replace stats(e_b p e_ci) varlabels note(Wave 2 weights used) ctitles("" "HB Subhazard Ratio (2)" ) merge

stcrreg `vars', compete(f_stat=2 3)
outreg using home_limited_comp, replace stats(e_b p e_ci) varlabels note(Wave 2 weights used) ctitles("" "HB Subhazard Ratio (3)" ) merge

foreach x=1/3{
	sum lw if f_stat==`i'
}

stcurve, cif







//died
stset lw [pw=anfinw], failure(f_stat==3) id(spid)

local vars `age' ib4.income_quart /*fin_strain anydebt govtasst finhlpfam meals_wheels */ ///
female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem `cond' adl_diff_ind srh_fp sr_cond_cat2 sr_cond_cat3 ///
ind_paid_helper metro_ind northeast midwest south

stcox age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart

stcox `vars'


//nh
stset lw [pw=anfinw], failure(f_stat==2) id(spid)
 
stcox age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south i.income_quart
 


//important to define the last wave in community 
sort spid wave
by spid: egen lw=max(wave)
replace lw=lw-1
label var lw "Last Time in the Community"




H="1c. wave 2 inc shb"
//Part 1
//Incident home-limited including semi-homebound
// Not home limited in round 1 and 

clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_hb_trajectories\output\output"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015

//VARIABLE CREATION/CLEANUP

gen demw1=0 if wave==1
replace demw1=1 if wave==1 & prob_dem==1
sort spid wave
by spid: carryforward demw1, replace
label var demw1 "Dementia Wave 1"

gen demw2=0 if wave==2 
replace demw2=1 if wave==2 & prob_dem==1 & demw1==0
by spid: carryforward demw2, replace
label var demw2 "Dementia Wave 2"

gen demw3=0 if wave==3
replace demw3=1 if wave==3 & prob_dem==1 & demw1==0 & demw2==0
label var demw3 "Dementia Wave 3"
gsort spid -wave 
by spid: carryforward demw3, replace

gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen shb2=0
replace shb2=1 if inrange(homebound_cat,2,3) & wave==2

gen comw1=.
replace comw1=1 if wave==1 & status==1
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & shb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.

sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 


sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

keep if wave==2

svy: tab nwstatus





///prior work 
/*
sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evernh=0 if firstcom<firstnh
replace evercom=0 if firstnh<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=4 if inlist(nwstatus,61)
replace nwstatus=6 if inlist(nwstatus,62,86)
replace nwstatus=7 if nwstatus>7
replace nwstatus=6 if died_12==1 & nwstatus==7
label define nwstatus 1 "Community, not home limited" 2 "Home limited, not incident" ///
3 "Incident home limited" 4 "NH Resident, not incident" ///
5 "Incident NH" 6 "Died" 7 "LFU"
label values nwstatus nwstatus
replace nwstatus=1 if inccom==1
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstat=4 if nhne==1
replace nwstat=5 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==6
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==7 & wave!=8
by spid: carryforward everlfu, replace 

tab nwstatus if wave==2

svy, subpop(if wave==2): tab nwstatus

H="1c. wave 6 inc shb"
//Part 1
//Incident home-limited including semi-homebound
// Not home limited in round 1 and 

clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_hb_trajectories\output\output"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
//gen orig_weight=anfinw
//replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
//drop if yearsample==2015

keep if wave>4
replace wave=wave-4
//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen shb2=0
replace shb2=1 if inrange(homebound_cat,2,3) & wave==2

gen comw1=.
replace comw1=1 if wave==1 & status==1
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & shb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.

sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 

drop r1status r2status r3status r4status

rename (r5status r6status r7status r8status) (r1status r2status r3status r4status)

gen nwstatus=.
forvalues i=1/3 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 


sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

keep if wave==2

svy: tab nwstatus



H="1c. wave 2 inc hb"
//Part 1

clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

keep if wave==2


svy: tab nwstatus



sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

keep if wave==2

/*
stset lw [pw=anfinw], failure(f_stat==1) id(spid)

sts graph, note(fail=community dwelling)

stset lw [pw=anfinw], failure(f_stat==2) id(spid)

sts graph, note(fail=semi-homebound)

stset lw [pw=anfinw], failure(f_stat==3) id(spid)

sts graph, note(fail=nhres)

stset lw [pw=anfinw], failure(f_stat==4) id(spid)

sts graph, note(fail=death)

stset lw [pw=anfinw], failure(f_stat==1 2 3 4) id(spid)

sts graph, note(fail=all)
*/

stset lw [pw=anfinw], failure(f_stat==1) id(spid)
sts gen s2=s
stset lw [pw=anfinw], failure(f_stat==4) id(spid)
sts gen s3=s
stset lw [pw=anfinw], failure(f_stat==3) id(spid)
sts gen s4=s 
sts graph 

stset lw [pw=anfinw], failure(f_stat==2) id(spid)
sts gen s5=s

sts graph, addplot((line s2 lw, sort c(J) legend( order( 1 "Semi-Homebound" 2 "Community" 3 "Died" 4 "NH"))) (line s3 lw, sort c(J)) (line s4 lw, sort c(J)))


stset lw [pw=anfinw], failure(f_stat==1 2 3 4) id(spid)

sts graph, addplot((line s2 lw, sort c(J) legend( order( 1 "All" 2 "Community" 3 "Died" 4 "NH" 5 "Semi-Homebound"))) (line s3 lw, sort c(J)) (line s4 lw, sort c(J)) (line s5 lw, sort c(J)))



stset lw [pw=anfinw], failure(f_stat==4) id(spid)

local vars `age' ib4.income_quart /*fin_strain anydebt govtasst finhlpfam meals_wheels */ ///
female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem `cond' adl_diff_ind srh_fp sr_cond_cat2 sr_cond_cat3 ///
ind_paid_helper metro_ind northeast midwest south

stset lw [pw=anfinw], failure(f_stat==4) id(spid)

 stcox age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south i.income_quart
 
 
 
 
 
 /*
 
drop a
gen sample_full=.
replace sample_full=1 if sample==1 & status==2

drop if sample_full==.



replace adl_diff_ind=1 if adl_impair==1
label var adl_diff_ind "ADL difficulty or impairment"

tab status nwstatus if wave==1, m




sort spid wave
/*gen northeast=region==1
gen midwest=region==2
gen south=region==3
gen west=region==4
label var northe "Northeast"
label var midw "Midwest"
label var south "South"
label var west "West"*/
gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}


tab wave nwstat if wave<=4, row
tab nwsta status if wave==1 

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}
/*label define income_quart 1 "1st Income Quartile (Low)" 2 "2nd Income Quartile" ///
3 "3rd Income Quartile" 4 "4th Income Quartile (Highest)"
label values income_quart income_quart*/



gen prob_dementia=dem_3==1 if !missing(dem_3)
label var prob_dementia "Probable dementia"

by spid, sort: gen persontime=_N
replace persontime=firsthb if firsthb<persontime
replace persontime=firstnh if firstnh<persontime
label var persontime "Waves contributing information"
gen anydebt=creditdebt==1 | medpayno==1 if !missing(creditdebt) | !missing(medpayn)
label var anydebt "Credit card or medical debt"



sort spid wave
gen inchb_after=1 if inchb==1 
by spid: carryforward inchb_after, replace

sort spid inchb_after wave
by spid inchb_after: gen time=_n if inchb_after==1 






//important to define the last wave in community 
sort spid wave
by spid: egen lw=max(wave)
replace lw=lw-1
label var lw "Last Time in the Community"




H="1c. wave 6 inc hb"
//Part 1

clear all
set more off
capture log close


cd "D:\NHATS\Projects\homebound\ko_homebound_income\output\logs"
use "D:\NHATS\Shared\base_data\NHATS cleaned\sp_round_1_8.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
/*gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015
*/

keep if wave>4
replace wave=wave-4
//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
drop r1status r2status r3status r4status

rename (r5status r6status r7status r8status) (r1status r2status r3status r4status)

gen nwstatus=.
forvalues i=1/3 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace died_12=0 if nwstatus<=7
label var died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

keep if wave==2

tab yearsample
svy: tab nwstatus



H="*************"


H="1c. wave 2 inc homelimited"
//Part 1
//Incident home-limited including semi-homebound
// Not home limited in round 1 and 

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear




//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015

gen wave_orig=wave

//VARIABLE CREATION/CLEANUP

gen demw1=0 if wave==1
replace demw1=1 if wave==1 & prob_dem==1
sort spid wave
by spid: carryforward demw1, replace
label var demw1 "Dementia Wave 1"

gen demw2=0 if wave==2 
replace demw2=1 if wave==2 & prob_dem==1 & demw1==0
by spid: carryforward demw2, replace
label var demw2 "Dementia Wave 2"

gen demw3=0 if wave==3
replace demw3=1 if wave==3 & prob_dem==1 & demw1==0 & demw2==0
label var demw3 "Dementia Wave 3"
gsort spid -wave 
by spid: carryforward demw3, replace

gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 

//home limited sample keeping
gen shb2=0
replace shb2=1 if inlist(homebound_cat,1,2,3) & wave==2

gen comw1=.
replace comw1=1 if wave==1 & status==1
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & shb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.

sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH
sort spid wave
by spid: drop if firstnh<wave
//by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
//replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.

sort spid wave
by spid: egen death_date=max(nhats_death_date)
format death_date %td


sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)


capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
gsort spid -wave
by spid: carryforward everlfu, replace 


bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus,9) & inlist(status,2,3)

by spid: egen fix=max(lw)
replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
//replace f_stat=2 if lw==wave & status==3
replace f_stat=2 if lw==wave & status==4
replace f_stat=3 if nwstatus==8 & lw==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

gen date=1
gen ivw_date=mdy(ivw_month,date, ivw_year)
format %td ivw_date

gen death2ivw=death_date-ivw_date if wave_orig==2
replace lw=round(death2ivw/365.25,0.1) if f_stat==3


keep if wave==2

svy: tab nwstatus



H="1c. wave 6 inc homelimited"
//Part 1
//Incident home-limited including semi-homebound
// Not home limited in round 1 and 

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
//gen orig_weight=anfinw
//replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
//drop if yearsample==2015

keep if wave>4
replace wave=wave-4
gen wave_orig=wave

//VARIABLE CREATION/CLEANUP

gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 

//home limited sample keeping
gen shb2=0
replace shb2=1 if inlist(homebound_cat,1,2,3) & wave==2

gen comw1=.
replace comw1=1 if wave==1 & status==1
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & shb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.

sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3


//Dropping waves after first community/NH
sort spid wave
by spid: drop if firstnh<wave
//by spid: drop if firstshb<wave
by spid: drop if firstcom<wave


//ever* var needs to be changed because later waves are dropped. 
//replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 
//finding next wave status 

drop r1status r2status r3status r4status

rename (r5status r6status r7status r8status) (r1status r2status r3status r4status)

//finding next wave status 
gen nwstatus=.
forvalues i=1/3 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Community, not homebound" 2 "Homebound, not incident" ///
3 "Incident homebound" 4 "Semi-Homebound, not incident" 5 "Incident Semi-Homebound" 6 "NH Resident, not incident" ///
7 "Incident NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"


//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.

sort spid wave
by spid: egen death_date=max(nhats_death_date)
format death_date %td


sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation

capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
gsort spid -wave
by spid: carryforward everlfu, replace 


bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus,9) & inlist(status,2,3)

by spid: egen fix=max(lw)
replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
//replace f_stat=2 if lw==wave & status==3
replace f_stat=2 if lw==wave & status==4
replace f_stat=3 if nwstatus==8 & lw==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

replace lw=lw-2

gen date=1
gen ivw_date=mdy(ivw_month,date, ivw_year)
format %td ivw_date

gen death2ivw=death_date-ivw_date if wave_orig==2
replace lw=round(death2ivw/365.25,0.1) if f_stat==3


keep if wave==2

svy: tab nwstatus



H="1c. wave 2 inc hb"
/*Off server code
NHATS_died_12 var was used here. 
wave 6 and keep only if homebound in wave 6
*/



//Part 1

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear



//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}

sort spid wave
by spid: gen prev_dem=prob_dem[_n-1]
by spid: gen next_dem=prob_dem[_n+1]

label var prev_dem "Previous wave dementia"
label var next_dem "Next wave dementia"

gen wave_orig=wave


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 

gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 8 we don't 
// know if they died based off NHATS data.

sort spid wave
by spid: egen death_date=max(nhats_death_date)
format death_date %td


sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if nwstatus==9 & status==2

gen f_stat=.
replace f_stat=1 if lw==wave & inlist(status,1,3)
replace f_stat=2 if lw==wave & status==4
replace f_stat=3 if nwstatus==8 & lw==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

by spid: egen fix=max(lw)

replace lw=fix 
drop fix
replace lw=lw-2

gen date=1
gen ivw_date=mdy(ivw_month,date, ivw_year)
format %td ivw_date

gen death2ivw=death_date-ivw_date if wave==2
replace lw=round(death2ivw/365.25,0.1) if f_stat==3

keep if wave==2

replace death_date=. if nwstatus!=8


tab lw
sum lw



preserve 
drop if nwstatus==9

gen comm=nwstatus==1
gen hb=nwstatus==2
gen shb=nwstatus==5
gen nh=nwstatus==7
gen died=nwstatus==8

foreach x in comm hb shb nh died{
mean `x' [aw=anfinw]
}

save "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

H="1. wave 6 inc hb"
/*Off server code
NHATS_died_12 var was used here. 
wave 6 and keep only if homebound in wave 6
*/



//Part 1

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear



//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}

sort spid wave
by spid: gen prev_dem=prob_dem[_n-1]
by spid: gen next_dem=prob_dem[_n+1]

label var prev_dem "Previous wave dementia"
label var next_dem "Next wave dementia"

gen wave_orig=wave

keep if wave>4
replace wave=wave-4
//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
drop r1status r2status r3status r4status

rename (r5status r6status r7status r8status) (r1status r2status r3status r4status)

gen nwstatus=.
forvalues i=1/3 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 8 we don't 
// know if they died based off NHATS data.

sort spid wave
by spid: egen death_date=max(nhats_death_date)
format death_date %td


sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if nwstatus==9 & status==2

gen f_stat=.
replace f_stat=1 if lw==wave & inlist(status,1,3)
replace f_stat=2 if lw==wave & status==4
replace f_stat=3 if nwstatus==8 & lw==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

by spid: egen fix=max(lw)

replace lw=fix 
drop fix
replace lw=lw-2

gen date=1
gen ivw_date=mdy(ivw_month,date, ivw_year)
format %td ivw_date

gen death2ivw=death_date-ivw_date if wave_orig==6
replace lw=round(death2ivw/365.25,0.1) if f_stat==3

keep if wave==2

replace death_date=. if nwstatus!=8

gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}



preserve 
drop if nwstatus==9

gen comm=nwstatus==1
gen hb=nwstatus==2
gen shb=nwstatus==5
gen nh=nwstatus==7
gen died=nwstatus==8

foreach x in comm hb shb nh died{
mean `x' [aw=anfinw]
}

save "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta", replace



H="wave 2 and wave 6 together"
/*analysis when we want to increase sample size for logit model. 
we remove duplicate individuals, but still keep people from 2011 cohort in 2015
441 sample size
*/

use wave2.dta, replace
append using wave6.dta

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6


H="incident homebound anytime"
/*

Created by: MH
Date Created: 12/19/2019

Updated by:
Date Updated:

Description: Inital data setup for homebound trajectories we are following people 
homebound status. 



**************************************************
*/
local date = subinstr("$S_DATE"," ","_",.) 
local name ko_hb_traj_`date'
di "`name'"

capture log close 
clear all

set more off

set linesize 80


cd ${logpath}
log using `name'.smcl, text replace

********

use "${datapath}\sp_round_1_8.dta" if lml==0, clear

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015



//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

bys spid wave: egen tot_hlp_hrs=sum(tot_hrswk_help_i) 


sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres

gen homebound_semi=0 if !missing(homebound_cat) & !nhres
replace homebound_semi=1 if inlist(homebound_cat, 2, 3) & !nhres

gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1 
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 
label values status status
label var status "Status this wave"

//checking to make sure everyone has a status at wave 1
sort spid wave
by spid: gen start=1 if wave==1 & status!=.
by spid: carryforward start, replace

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

drop if mstat==1


sort spid wave
by spid: egen lw=max(wave)
label var lw "Last Time observed"


sort spid wave
gen status_nw=1 if spid==spid[_n+1] & wave+1==wave[_n+1] & sp_ivw[_n+1]==1 & !missing(homebound[_n+1])
replace status_nw=2 if spid==spid[_n+1] & wave+1==wave[_n+1] & homebound_cat[_n+1]==1
replace status_nw=3 if spid==spid[_n+1] & wave+1==wave[_n+1] & inlist(homebound_cat[_n+1],2,3)
replace status_nw=4 if spid==spid[_n+1] & wave+1==wave[_n+1] & nhres[_n+1]==1
replace status_nw=5 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==1 & lw==wave
replace status_nw=6 if spid!=spid[_n+1] & wave+1!=wave[_n+1] & died_12==0 & lw==wave
label define status_nw 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH Resident" 5 "Died" 6 "LFU"
label values status_nw status_nw
label var status_nw "Status next wave"

sort spid wave
by spid: egen hb_min=min(wave) if homebound==1
gen inchb=0
replace inchb=1 if hb_min==wave 

by spid: egen ever_hb=max(hb)

gen inchb2=1 if inchb==1 & wave!=1
// 859 people who are incident homebound wave 2 and after. 

gen inchb3=1 if inchb2==1
sort spid wave
bys spid: carryforward inchb3 , replace

keep if inchb3==1

by spid: egen minw=min(wave) if status!=2

keep if wave<=minw

sort spid wave
by spid: gen n=_n

sort spid wave
by spid: egen lw_test=max(n)
replace lw_test=lw_test-1
replace lw_test=lw_test+1 if status_nw==5

by spid: egen lw_final=max(lw_test)


sort spid wave
by spid: keep if _n==1






H="table 1 wave 2--incident hb in wave 2"
//Part 1

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

keep if wave==2

svy: tab nwstatus if nwstatus!=9

gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}

//table 1

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"


local cvars1 age
local cvars2  income_adj
local ivars1 female white black hisp other_race married 

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
 forvalues i=1/9 {
gen group`i'=nwstatus==`i'
}
 
local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' `coutcomes' `coutcomes' `ioutcomes' 1 1
di `rn'
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
foreach i in 1 2 5 7 8 9 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			qui sum `x' if group`i'==1 & _merge==3  [aw=anfin]
			mat tab1[`r',`c']=r(mean)
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if _merge==3 & (group`i'==1 | group2==1)): reg `x' group`i'
				test group`i'
				mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05) 
}
			local r=`r'+1
}
		foreach x of local ivars`round' {
			qui sum `x' if group`i'==1 & wave==2  [aw=anfin]
			mat tab1[`r',`c']=r(mean)*100
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if status==2 & wave==2  & (group`i'==1 | group2==1)): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
}
	local r=`r'+1

	
	foreach x of local coutcomes {
		qui sum `x' if group`i'==1,d
		mat tab1[`r',`c']=r(mean)
		if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if _merge==3 & (group`i'==1 | group2==1)): reg `x' group`i'
				test group`i'
			mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05)
}
		local r=`r'+1
*		if "`x'"=="tot_paid_by_mc_12m_wi_n0" {
			qui sum `x' if group`i'==1,d
			mat tab1[`r',`c']=r(p50)
			local r=`r'+1
*}
}
	foreach x of local ioutcomes {
		qui sum `x' if group`i'==1
		mat tab1[`r',`c']=r(mean)*100
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if status==2 & wave==2  & group`i'==1 | group2==1): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
	qui sum n if group`i'==1 & wave==2  [aw=anfin]
	
	mat tab1[`r',`c']=r(N)
	mat tab1[`r'+1,`c']=r(sum)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2.rtf, replace statmat(tab1) ///
 title("Sample Characteristics by next wave status") ///
 ctitles("" "Community" "HB" "Inc SHB" "Inc NH" ///
 "Died" "LFU") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 NHATS Homebound sample, by next-wave status")
 

restore

H="table 1 wave 6--incident hb in wave 6"
/*Off server code
NHATS_died_12 var was used here. 
wave 6 and keep only if homebound in wave 6
*/



//Part 1

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear



//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
/*gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015*/


keep if wave>4
replace wave=wave-4
//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 
drop r1status r2status r3status r4status

rename (r5status r6status r7status r8status) (r1status r2status r3status r4status)

gen nwstatus=.
forvalues i=1/3 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

replace lw=lw-2

keep if wave==2



svy: tab nwstatus if nwstatus!=9



gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}

//table 1

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"


local cvars1 age
local cvars2  income_adj
local ivars1 female white black hisp other_race married 

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
 forvalues i=1/9 {
gen group`i'=nwstatus==`i'
}
 
local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' `coutcomes' `coutcomes' `ioutcomes' 1 1
di `rn'
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
foreach i in 1 2 5 7 8 9 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			qui sum `x' if group`i'==1 & _merge==3  [aw=anfin]
			mat tab1[`r',`c']=r(mean)
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if _merge==3 & (group`i'==1 | group2==1)): reg `x' group`i'
				test group`i'
				mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05) 
}
			local r=`r'+1
}
		foreach x of local ivars`round' {
			qui sum `x' if group`i'==1 & wave==2  [aw=anfin]
			mat tab1[`r',`c']=r(mean)*100
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if status==2 & wave==2  & (group`i'==1 | group2==1)): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
}
	local r=`r'+1

	
	foreach x of local coutcomes {
		qui sum `x' if group`i'==1,d
		mat tab1[`r',`c']=r(mean)
		if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if _merge==3 & (group`i'==1 | group2==1)): reg `x' group`i'
				test group`i'
			mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05)
}
		local r=`r'+1
*		if "`x'"=="tot_paid_by_mc_12m_wi_n0" {
			qui sum `x' if group`i'==1,d
			mat tab1[`r',`c']=r(p50)
			local r=`r'+1
*}
}
	foreach x of local ioutcomes {
		qui sum `x' if group`i'==1
		mat tab1[`r',`c']=r(mean)*100
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if status==2 & wave==2  & group`i'==1 | group2==1): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
	qui sum n if group`i'==1 & wave==2  [aw=anfin]
	
	mat tab1[`r',`c']=r(N)
	mat tab1[`r'+1,`c']=r(sum)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_6.rtf, replace statmat(tab1) ///
 title("Sample Characteristics by next wave status") ///
 ctitles("" "Community" "HB" "Inc SHB" "Inc NH" ///
 "Died" "LFU") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 6 NHATS Homebound sample, by next-wave status")
 


H="Change log"


********************Change Log******************** 



Updates:
01/30/2020 MH
------------
Creating a home limited varaible, code, graphs, version. 

01/16/2020 MH
------------
Overlaying KM curves. 

01/13/2020 MH
------------
Adding in code to follow people who were incident homebound in wave 2 and then running KM curves. 

01/06/2020 MH
------------
Following tracjectories of people who are Incident HB.

12/17/2019 MH
------------
Adding in semi-homebound and creating tables for what happens after incident homebound. 

12/5/2019 MH
------------
Working on trajectories and creating varaibles to see what happens to a person after their incident homebound wave. 



*/

H="mlogit --wave 2"
/*Off server code
NHATS_died_12 var was used here. 
wave 2 and keep only if homebound in wave 2
*/



//Part 1

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear



//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//income quartile definiton
sum income_adj
forvalues i=1/4 {
gen inccat`i'=income_quart==`i'
local lab : label income_quart `=`i''
label var inccat`i' "Income Quartile: `lab'"
}

sort spid wave
by spid: gen prev_dem=prob_dem[_n-1]
by spid: gen next_dem=prob_dem[_n+1]

label var prev_dem "Previous wave dementia"
label var next_dem "Next wave dementia"

gen wave_orig=wave


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

//finding next wave status 

gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 8 we don't 
// know if they died based off NHATS data.

sort spid wave
by spid: egen death_date=max(nhats_death_date)
format death_date %td


sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if nwstatus==9 & status==2

gen f_stat=.
replace f_stat=1 if lw==wave & inlist(status,1,3)
replace f_stat=2 if lw==wave & status==4
replace f_stat=3 if nwstatus==8 & lw==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

by spid: egen fix=max(lw)

replace lw=fix 
drop fix
replace lw=lw-2

gen date=1
gen ivw_date=mdy(ivw_month,date, ivw_year)
format %td ivw_date

gen death2ivw=death_date-ivw_date if wave==2
replace lw=round(death2ivw/365.25,0.1) if f_stat==3

keep if wave==2

replace death_date=. if nwstatus!=8


tab lw
sum lw



///////////////MI mlogit



merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"

mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) rrr
outreg using hb_mlogit.rtf,  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels



mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome , b(0) rrr
outreg using hb_mlogit.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation") varlabels merge


keep if sample==1


tab income_quart, gen(income_quart)

mdesc outcome if sample==1
pwcorr outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south income_quart1 income_quart2 income_quart3 income_quart4 cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, obs

misstable sum outcome, gen(miss_)
tab1 miss_outcome
logit miss_outcome black hisp educ_hs_ind income_quart2 ownhome

foreach var of varlist age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south income_quart1 income_quart2 income_quart3 income_quart4 cohesion ownhome meals_wheels ind_gt20hrs_wk_inf{
ttest `var', by(miss_outcome)
}
//prob_dem only var signif within 10%

mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, rrr base(0)


//only 2 outcomes

preserve
drop if outcome==2
pwcorr outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south income_quart1 income_quart2 income_quart3 income_quart4 cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, obs

logit outcome black hisp educ_hs_ind i.income_quart ownhome ind_gt20hrs_wk_inf adl_diff_ind prob_dem 

logit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, or

lroc

restore


mi set wide

mi misstable patterns outcome

mi register imputed outcome

tab outcome, m


logit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart ind_gt20hrs_wk_inf
lroc


mi impute logit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome meals_wheels ind_gt20hrs_wk_inf if outcome!=2, add(10) rseed(55) force




mi estimate, post : mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) 

outreg, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels


mi estimate, post: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome, base(0)

outreg using hb_mlogit.rtf,  addtable merge stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels

foreach x in female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south cohesion ownhome meals_wheels ind_gt20hrs_wk_inf {
tab `x' _1_outcome, m
}

H="mlogit working--wave 6"
/*Off server code
NHATS_died_12 var was used here. 
wave 6 and keep only if homebound in wave 6
*/



//mlogit

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"

mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) rrr
outreg using hb_mlogit.rtf,  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels



mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome , b(0) rrr
outreg using hb_mlogit.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation") varlabels merge


mlogit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem , b(0) rrr
outreg using hb_mlogit_new.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation") varlabels 

mlogitroc outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem

keep if sample==1


tab income_quart, gen(income_quart)

mdesc outcome if sample==1
pwcorr outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south income_quart1 income_quart2 income_quart3 income_quart4 cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, obs

misstable sum outcome, gen(miss_)
tab1 miss_outcome
logit miss_outcome black hisp educ_hs_ind income_quart2 ownhome

foreach var of varlist age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south income_quart1 income_quart2 income_quart3 income_quart4 cohesion ownhome meals_wheels ind_gt20hrs_wk_inf{
ttest `var', by(miss_outcome)
}
//prob_dem only var signif within 10%

mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, rrr base(0)


//only 2 outcomes

preserve
drop if outcome==2
pwcorr outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south income_quart1 income_quart2 income_quart3 income_quart4 cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, obs

logit outcome black hisp educ_hs_ind i.income_quart ownhome ind_gt20hrs_wk_inf adl_diff_ind prob_dem 

logit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome meals_wheels ind_gt20hrs_wk_inf, or

lroc

restore


mi set wide

mi misstable patterns outcome

mi register imputed outcome

tab outcome, m


logit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart ind_gt20hrs_wk_inf
lroc


mi impute logit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome meals_wheels ind_gt20hrs_wk_inf if outcome!=2, add(10) rseed(55) force




mi estimate, post : mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) 

outreg, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels


mi estimate, post: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome, base(0)

outreg using hb_mlogit.rtf,  addtable merge stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels

foreach x in female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south cohesion ownhome meals_wheels ind_gt20hrs_wk_inf {
tab `x' _1_outcome, m
}


H="univariate, lasso"
///Need to create a univariate model
gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9


gen tot_hrswk_40=0 if tot_hrswk_help_i<40 & !missing(tot_hrswk_help_i)
replace tot_hrswk_40=1 if tot_hrswk_help_i>=40
label var tot_hrswk_40 "40 + hours helped by any helper/week"



local cvars age income_adj tot_hrswk_help_i
local ivars female white black hisp married proxy_ivw educ_hs_ind inccat1 inccat2 inccat3 inccat4 medicaid medigap livealone noone_talk ind_noone ind_paid_helper tot_hrswk_40 srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help adl_impair iadl_impair sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west mealskip nopayhous nopayutil nopaymed creditdebt medpaynotcash finhlpfam meals_wheels govtasst cohesion ownhome

local rn : word count `cvars' `ivars'

mat tab=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1


foreach x in `cvars'{
mlogit outcome `x', rrr b(0)
mat cvar=r(table)[1,3]
mat pval=r(table)[4,3]
mat cvar2=r(table)[1,5]
mat pval2=r(table)[4,5]
mat tab[`r',`c']=cvar[1,1]
mat stars[`r',`c']=(pval[1,1]<.01) + (pval[1,1]<.05)  
mat tab[`r',`c'+1]=pval[1,1]
mat tab[`r',`c'+2]=cvar2[1,1]
mat stars[`r',`c'+2]=(pval2[1,1]<.01) + (pval2[1,1]<.05)
mat tab[`r',`c'+3]=pval2[1,1]
local r=`r'+1
}

foreach x in `ivars'{
mlogit outcome i.`x', rrr b(0)
mat rtable=r(table)
mat ivar=rtable["b", "1:1.`x'"]
mat pval=rtable["pvalue", "1:1.`x'"]
mat ivar2=rtable["b", "2:1.`x'"]
mat pval2=rtable["pvalue", "2:1.`x'"]
mat tab[`r',`c']=ivar[1,1]
mat stars[`r',`c']=(pval[1,1]<.01) + (pval[1,1]<.05)  
mat tab[`r',`c'+1]=pval[1,1]
mat tab[`r',`c'+2]=ivar2[1,1]
mat stars[`r',`c'+2]=(pval2[1,1]<.01) + (pval2[1,1]<.05)
mat tab[`r',`c'+3]=pval2[1,1]
local r=`r'+1
}

mat rownames tab= `cvars' `ivars'
mat list tab
mat list stars

frmttable using unadjusted.rtf, statmat(tab) ///
 title("Unadjusted Multinomial Logistic Models") ///
 ctitles("" "Com. vs. HB" "P-value" "NH/Died vs. HB" "P-value") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels replace note("All models are univariate multinomial logistic models" "Odds Ratios are reported.")

 
 
//lasso model

gen outcome1=0 if outcome==0
replace outcome1=1 if outcome==1

gen outcome2=0 if outcome==0
replace outcome2=1 if outcome==2
 
local cvars age income_adj tot_hrswk_help_i
local ivars female white black hisp married proxy_ivw educ_hs_ind inccat1 inccat2 inccat3 inccat4 medicaid medigap livealone noone_talk ind_noone ind_paid_helper tot_hrswk_40 srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help adl_ins_help adl_bed_help adl_impair iadl_impair sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west mealskip nopayhous nopayutil nopaymed creditdebt medpaynotcash finhlpfam meals_wheels govtasst cohesion ownhome

 set seed 1234
lasso logit outcome1 `cvars' `ivars'
lassocoef, display(coef, standardized)

set seed 1234
lasso logit outcome2 `cvars' `ivars'
lassocoef, display(coef, standardized)

preserve
drop if outcome1==.
lasso logit outcome1 `cvars' `ivars'
lassocoef, display(coef, standardized)
restore

preserve
drop if outcome2==.
lasso logit outcome2 `cvars' `ivars'
lassocoef, display(coef, standardized)
restore




/////////////


local cvars age 
local ivars female white black hisp educ_hs_ind inccat1 srh_fp adl_impair prob_dem  

set seed 1234 
lasso logit outcome1 `cvars' `ivars'
lassocoef, display(coef, standardized)

set seed 1234
lasso logit outcome2 `cvars' `ivars'
lassocoef, display(coef, standardized)


gen adl_impair0=adl_index==0
gen adl_impair1=inlist(adl_index,1,2)
gen adl_impair2=inlist(adl_index,3,4,5,6)


H="homebound new var"

forvalues w=1/8{
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\raw_data\round_`w'\round_`w'\NHATS_Round_`w'_SP_File.dta", clear

keep spid mo`w'outyrgo
rename mo`w'outyrgo outyrgo
gen wave=`w'

tempfile r`w'
save `r`w''
}

forvalues w=1/7{
append using `r`w''
}

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

tsset spid wave

tab outyrgo homebound
sort spid wave
gen lag_homebound=homebound[_n-1] if spid==spid[_n-1] & wave-1==wave[_n-1]

gen lag_freq_go_out=freq_go_out[_n-1] if spid==spid[_n-1] & wave-1==wave[_n-1]

//Leave more often than a year ago
tab lag_homebound homebound if outyrgo==1

//Leave less often than a year ago
tab lag_homebound homebound if outyrgo==2

//Leave about the same a year ago
tab lag_homebound homebound if outyrgo==3


label values lag_freq_go_out freq_go_out 
//Leave more often than a year ago
tab lag_freq_go_out freq_go_out if outyrgo==1

//Leave less often than a year ago
tab lag_freq_go_out freq_go_out if outyrgo==2

//Leave about the same a year ago
tab lag_freq_go_out freq_go_out if outyrgo==3

H="wave 2 and 6 combine table 1"
/*analysis when we want to increase sample size for logit model. 
we remove duplicate individuals, but still keep people from 2011 cohort in 2015
508 sample size
*/

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

gen os=1

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

tab _merge


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"
//table 1

local cvars1 age
local cvars2  income_adj
local ivars1 female white black hisp other_race married educ_hs_ind

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
 forvalues i=1/9 {
gen group`i'=nwstatus==`i'
}
 
local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' `coutcomes' `coutcomes' `ioutcomes' 1 1
di `rn'
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
foreach i in 1 2 5 7 8 9 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			qui sum `x' if group`i'==1 & _merge==3  [aw=anfin]
			mat tab1[`r',`c']=r(mean)
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if _merge==3 & (group`i'==1 | group2==1)): reg `x' group`i'
				test group`i'
				mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05) 
}
			local r=`r'+1
}
		foreach x of local ivars`round' {
			qui sum `x' if group`i'==1 & wave==2  [aw=anfin]
			mat tab1[`r',`c']=r(mean)*100
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if status==2 & wave==2  & (group`i'==1 | group2==1)): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
}
	local r=`r'+1

	
	foreach x of local coutcomes {
		qui sum `x' if group`i'==1,d
		mat tab1[`r',`c']=r(mean)
		if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if _merge==3 & (group`i'==1 | group2==1)): reg `x' group`i'
				test group`i'
			mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05)
}
		local r=`r'+1
*		if "`x'"=="tot_paid_by_mc_12m_wi_n0" {
			qui sum `x' if group`i'==1,d
			mat tab1[`r',`c']=r(p50)
			local r=`r'+1
*}
}
	foreach x of local ioutcomes {
		qui sum `x' if group`i'==1
		mat tab1[`r',`c']=r(mean)*100
			if inlist("`i'","1","5","7","8","9") {
				svy, subpop(if status==2 & wave==2  & group`i'==1 | group2==1): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
	qui sum n if group`i'==1 & wave==2  [aw=anfin]
	
	mat tab1[`r',`c']=r(N)
	mat tab1[`r'+1,`c']=r(sum)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2_6.rtf, replace statmat(tab1) ///
 title("Sample Characteristics by next wave status") ///
 ctitles("" "Community" "HB" "Inc SHB" "Inc NH" ///
 "Died" "LFU") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 and 6 NHATS Homebound sample, by next-wave status")
 

restore

H="wave 2 and 6 combine"
/*analysis when we want to increase sample size for logit model. 
we remove duplicate individuals, but still keep people from 2011 cohort in 2015
508 sample size
*/

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

gen os=1

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

tab _merge


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"

svyset 
//regular mlogit model -- hb_mlogit_wave2_6

mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) rrr
outreg using hb_mlogit_wave2_6.rtf,  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6" ) varlabels

mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome , b(0) rrr
outreg using hb_mlogit_wave2_6.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable

mlogit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem , b(0) rrr
outreg using hb_mlogit_wave2_6.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable


// survey ---hb_mlogit_wave2_6_wgt

svy: mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) rrr
outreg using hb_mlogit_wave2_6_wgt.rtf,  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Weighted Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6" ) varlabels

svy: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome , b(0) rrr
outreg using hb_mlogit_wave2_6_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Weighted Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable

svy: mlogit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem , b(0) rrr
outreg using hb_mlogit_wave2_6_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Weighted Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable


//multiple imputation
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9



mi set wide

mi misstable patterns outcome

mi register imputed outcome

tab outcome, m

//MI regular mlogit model -- hb_mlogit_2_6_mi

mi impute logit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem if outcome!=2, add(10) rseed(55) force


mi estimate, post : mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart, b(0) 

outreg using hb_mlogit_2_6_mi.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels replace


mi estimate, post: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome, b(0)

outreg using hb_mlogit_2_6_mi.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


mi estimate, post: mlogit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem, base(0)

outreg using hb_mlogit_2_6_mi.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


///weighting MI -- hb_mlogit_2_6_mi_wgt

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

gen os=1

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

tab _merge


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"

svyset 

keep if os==1

mi set wide

mi misstable patterns outcome

mi register imputed outcome

tab outcome, m



mi impute logit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem if outcome!=2 [pw=anfinw], add(10) rseed(55) force


mi estimate, post : mlogit outcome age female black hisp married educ_hs_ind ib4.income_quart [pw=anfinw], b(0) 

outreg using hb_mlogit_2_6_mi_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels replace


mi estimate, post: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south ib4.income_quart cohesion ownhome[pw=anfinw], b(0)

outreg using hb_mlogit_2_6_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


mi estimate, post: mlogit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem [pw=anfinw], base(0)

outreg using hb_mlogit_2_6_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 





H="new mi"
/*analysis when we want to increase sample size for logit model. 
we remove duplicate individuals, but still keep people from 2011 cohort in 2015
508 sample size
*/

cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"

import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow case(lower) clear

gen wave=.
forvalues w=1/8{
replace wave=`w' if year==201`w'
}

drop if wave==.

tempfile poverty_thresh
save "`poverty_thresh'", replace


use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear


merge m:1 wave hhm using "`poverty_thresh'"

sort wave hhm
by wave: carryforward poverty_thresh if hhm>9 & hhm!=., replace 
drop if _merge==2
drop _merge

gen poverty=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)

forvalues i=1/5 {
gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

gen os=1

merge 1:1 spid wave using "`t1'"

svyset


mi import wide, imputed(poverty=imppov1 imppov2 imppov3 imppov4 imppov5) clear

mi svyset 

mi estimate: svy, subpop(if os & nwstatus==1): mean poverty

//replace varstrat=1

//mi estimate: svy, subpop(os): mlogit outcome poverty female educ_hs_ind, b(0)

label var poverty "In Poverty"

tab _merge


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"

svyset 
//regular mlogit model -- hb_mlogit_wave2_6

mlogit outcome age female black hisp married educ_hs_ind poverty, b(0) rrr
outreg using hb_mlogit_wave2_6.rtf,  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6" ) varlabels

mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south poverty cohesion ownhome , b(0) rrr
outreg using hb_mlogit_wave2_6.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable

mlogit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem , b(0) rrr
outreg using hb_mlogit_wave2_6.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable


// survey ---hb_mlogit_wave2_6_wgt

svy: mlogit outcome age female black hisp married educ_hs_ind poverty, b(0) rrr
outreg using hb_mlogit_wave2_6_wgt.rtf,  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Weighted Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6" ) varlabels

svy: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south poverty cohesion ownhome , b(0) rrr
outreg using hb_mlogit_wave2_6_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Weighted Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable

svy: mlogit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem , b(0) rrr
outreg using hb_mlogit_wave2_6_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Weighted Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" \ "No Multiple Imputation" \ "Sample combining wave 2 and wave 6") varlabels addtable


//multiple imputation

cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"

import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow case(lower) clear

gen wave=.
forvalues w=1/8{
replace wave=`w' if year==201`w'
}

drop if wave==.

tempfile poverty_thresh
save "`poverty_thresh'", replace


use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear


merge m:1 wave hhm using "`poverty_thresh'"

sort wave hhm
by wave: carryforward poverty_thresh if hhm>9 & hhm!=., replace 
drop if _merge==2
drop _merge

gen poverty=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)

forvalues i=1/5 {
gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

tempfile t1
save `t1'

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

gen os=1

merge 1:1 spid wave using "`t1'"

svyset


mi import wide, imputed(poverty=imppov1 imppov2 imppov3 imppov4 imppov5) clear

mi svyset 

mi estimate: svy, subpop(if os & nwstatus==1): mean poverty

//replace varstrat=1

//mi estimate: svy, subpop(os): mlogit outcome poverty female educ_hs_ind, b(0)

label var poverty "In Poverty"

tab _merge

//MI regular mlogit model -- hb_mlogit_2_6_mi

mi impute logit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem if outcome!=2, add(10) rseed(55) force


mi estimate, post : mlogit outcome age female black hisp married educ_hs_ind poverty, b(0) 

outreg using hb_mlogit_2_6_mi.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels replace


mi estimate, post: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south poverty cohesion ownhome, b(0)

outreg using hb_mlogit_2_6_mi.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


mi estimate, post: mlogit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem, base(0)

outreg using hb_mlogit_2_6_mi.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


///weighting MI -- hb_mlogit_2_6_mi_wgt
import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow case(lower) clear

gen wave_orig=.
forvalues w=1/8{
replace wave_orig=`w' if year==201`w'
}

drop if wave_orig==.

tempfile poverty_thresh
save "`poverty_thresh'", replace

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

append using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta"

merge m:1 wave_orig hhm using "`poverty_thresh'"

sort wave_orig hhm
by wave_orig: carryforward poverty_thresh if hhm>9 & hhm!=., replace 
drop if _merge==2
drop _merge

gen poverty=.
replace poverty=0 if aveincome>poverty_thresh & !missing(poverty_thresh)
replace poverty=1 if aveincome<=poverty_thresh & !missing(poverty_thresh)

label var poverty "In Poverty"

duplicates tag spid, gen(a)
tab a wave_orig

drop if a==1 & wave_orig==6

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

gen os=1

merge 1:1 spid wave using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta"

tab _merge


label var adl_diff_ind "Indicator of any ADL difficulty reported (missing coded as zero)"

svyset 

keep if os==1

mi set wide

mi misstable patterns outcome

mi register imputed outcome

tab outcome, m



mi impute logit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem if outcome!=2 [pw=anfinw], add(10) rseed(55) force


mi estimate, post : mlogit outcome age female black hisp married educ_hs_ind poverty [pw=anfinw], b(0) 

outreg using hb_mlogit_2_6_mi_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels replace


mi estimate, post: mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south poverty cohesion ownhome[pw=anfinw], b(0)

outreg using hb_mlogit_2_6_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


mi estimate, post: mlogit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem [pw=anfinw], base(0)

outreg using hb_mlogit_2_6_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 





H="xWave 2 analysis with mi "


use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace

mi estimate, post : svy, subpop(if os==1): mlogit outcome age female black hisp married educ_hs_ind poverty , b(0) 

outreg using hb_mlogit_2_mi_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Table 1: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels replace


mi estimate, post : svy, subpop(if os==1): mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south poverty cohesion ownhome, b(0)

outreg using hb_mlogit_2_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 2: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


mi estimate, post : svy, subpop(if os==1): mlogit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem, base(0)

outreg using hb_mlogit_2_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 





H="xSankey"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if year==2011, clear

replace anfinwgt=an2011wgt if wave>=5


replace homebound_cat=. if lml==1 | nhres==1
forvalues i=2/8 {
               by spid: replace prob_dem=. if wave==`i' & prob_dem[_n-1]==.
}
by spid: egen firsthb=min(cond(homebound_cat==1),wave,.)
tab firsthb
tab firsthb wave
drop if missing(firsthb)
gen status=1 if homebound_cat==4
replace status=2 if inlist(homebound_cat,2,3)
replace status=3 if inlist(homebound_cat,1)
replace status=4 if nhres==1
replace status=5 if sp_status==4

gen hb2=0
replace hb2=1 if status==3 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==2)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.



by spid: gen nwstat=status[_n+1]
replace nwstat=5 if missing(nwstat) & nhats_died_12==1
forvalues i=2/8 {
               replace nwstat=5 if r`i'status==86 & wave==`i'-1
               replace nwstat=4 if r`i'status==64 & wave==`i'-1 & nhres==1

}

by spid: replace nwstat=nwstat[_n+1] if nwstat[_n+1]==status & missing(nwstat)
by spid: replace nwstat=status if missing(nwstat) & !missing(nwstat[_n+1])
replace nwstat=6 if missing(nwstat)
label define nwstat 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "LFU" 7 "Censored"
label values nwstat nwstat
replace nwstat=7 if wave==8
drop if wave<firsthb
drop if firsthb==year-2010 | firsthb==8
sort spid wave 
by spid: gen t=_n
label values status nwstat



sort spid wave
by spid: replace anfinw=anfinw[_n-1] if status==5
by spid: replace anfinw=anfinw[_n-1] if status==4 & !anfinw
by spid: replace anfinw=anfinw[_n-1] if !anfinw & rcfres==1

//old
/*
preserve
tab t
drop if lml==1
replace nwstat=6 if status==4 & nwstat<3
tab status nwstat if nwstat<6, row nokey
tab status nwstat if nwstat<6 & t==1, row nokey
tab status nwstat if nwstat<6 & t>1, row nokey


keep spid nwstat t
reshape wide nwstat, i(spid) j(t)
gen nwstat0=3
label define nwstat0 3 "Incident HB"
label values nwstat0 nwstat0
forvalues i=1/7 {
               replace nwstat`i'=nwstat`=`i'-1' if inlist(nwstat`=`i'-1',5/*,7*/)
               *replace nwstat`i'=nwstat`=`i'-1' if missing(nwstat`i') & inlist(nwstat`=`i'-1',5,6,7)
}
restore
*/


//merge m:1 spid using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2_1.dta", keepusing(spid) keep(matched) nogen  


keep if firsthb==2
keep spid anfinwgt nwstat t
expand 2
sort spid t
by spid: replace t=0 if _n==1
duplicates drop
replace nwstat=0 if t==0
label define nwstat 0 "Incident HB", modify
rename nwstat status
label var status "Status at current wave"
label var t "Time from incident homebound"
sort spid t
by spid: replace status=5 if status[_n-1]==5

forvalues i=1/7 {
expand 2
sort spid t
by spid: replace t=t+1 if _n==_N
duplicates drop
}
drop if t>7


/*local n=0
local fdenom=10000
forvalues t=2/2 {
               qui sum status if t==`t' & status<6
               if `t'>1 local fdenom=r(N)
               forvalues n1=0/4 {
                              qui sum prevstat if t==`t' & prevstat==`n1' & status<6
                              local denom=r(N)
                              di "t=`t', n1=`n1', denom=`denom'
                              forvalues i=1/5 {
                                             qui sum status if t==`t' & prevstat==`n1' & status==`i'
                                             local numer=r(N)
                                             di `numer'
                                             qui replace stat`t'=`i' if inrange(_n,`n'+1,`n'+round((`numer'/`denom')*`fdenom')) & `denom'>0
                                             if `denom'>0 local n=`n'+round((`numer'/`denom')*`fdenom') 
                                             di "n=`n'"
}
                              qui replace stat`t'=5 if missing(stat`t') & _n<=round(`fdenom'/`denom') & `denom'>0
                              qui replace stat`t'=5 if missing(stat`t') & `denom'==0
                              if `denom'>0 local n=round(`fdenom'/`denom') 
                              di "n=`n'"
                              qui replace stat`t'=. if _n>1000
}
               local n=0
               label define stat`t' 0 "Incident HB" 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "LFU" 7 "Censored", modify
               label values stat`t' stat`t'
}*/
replace status=. if status>=6
levelsof status, local(levels)
foreach l of local levels {
               gen status`l'=status==`l'
}

sort spid t 
by spid: gen prevstat=status[_n-1]
drop if status==6

gen n=_n
gen stat0=0 if _n<=1000
label define stat0 0 "100% Incident HB"
label values stat0 stat0
local n=0

forvalues t=1/6 {
               sort stat`=`t'-1'
                              gen stat`t'=.
               label define stat`t' 0 "Incident HB" 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "LFU" 7 "Censored", modify
               label values stat`t' stat`t'
               qui sum status if t==`t' 
               local denom=r(N)
               forvalues n1=0/5 {
                              qui sum status if prevstat==`n1' & t==`t' & status<6 [aw=anfinw]
                              qui sum stat`=`t'-1' if stat`=`t'-1'==`n1'  [aw=anfinw]

                              local d2=r(N)
                              if `d2'==. local d2=0
                                                            di "t=`t', n1=`n1', denom=`denom', d2=`d2'"

                              forvalues i=5(-1)1 {
                                             qui sum status`i' if prevstat==`n1' & t==`t' & status<6 [aw=anfinw]
                                             local m=r(mean)
                                             if `d2'>0 {
                                             di "range is `=`n'+1' to  `=`n'+round(`m'*`d2')'"
                                             replace stat`t'=`i' if inrange(_n,`n'+1,`n'+round(r(mean)*`d2'))
                                             local n=`n'+round(r(mean)*`d2')
}
                                             di "n=`n'"

                                             
}
}
               replace stat`t'=5 if stat`=`t'-1'==5
               replace stat`t'=. if _n>1000
               replace stat`t'=5 if missing(stat`t') & _n<=1000
               local n=0
}


replace stat6=5 if missing(stat6) & _n<=1000
replace stat1=5 if missing(stat1) & _n<=1000

keep spid anfinwgt stat* 
drop statu*                        anfinw
keep if _n<1001


forvalues i=1/6 {
               forvalues j=1/5 {
                              qui sum stat`i' if stat`i'==`j' //[aw=anfinw]
                              local pct`j'=round((r(N)/1000)*100)
}
               label define stat`i' 0 "Incident HB" 1 "(1) `pct1'% Independent" 2 "(2) `pct2'% Semi-HB" 3 "(3) `pct3'% HB" 4 "(4) `pct4'% NH" 5 "(5) `pct5'% Dead" 6 "LFU" 7 "Censored", modify
}              






H="sankey new"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear

replace nhats_died_12=1 if spid==spid[_n+1] & lml_ivw[_n+1]==1
gen lml_ivw_nw=lml_ivw[_n+1] if spid==spid[_n+1]

drop if lml_ivw_yes==1

set seed 45

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Dead"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
/*
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<2
by spid: drop if firstshb<2
by spid: drop if firstcom<2

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 
*/

by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3

forvalues w=2/7{
replace nhats_died_12=1 if r`=`w'+1'status==86 & wave==`w'
}

//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat 
tab status if wave==3
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & homebound[_n+1]!=. & spid==spid[_n+1]
replace nwstatus=4 if inlist(nwstatus,61)
replace nwstatus=5 if inlist(nwstatus,62,86)
replace nwstatus=6 if nwstatus>4
replace nwstatus=5 if nhats_died_12==1 & nwstatus==6
label define nwstatus 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "(6) LFU" 7 "Censored"
label values nwstatus nwstatus
replace nwstatus=3 if hbne==1
replace nwstatus=2 if shbne==1
replace nwstat=4 if nhne==1

label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=4
label var nhats_died_12 "Died prior to next wave"

//generating everdied
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==5 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==6 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

expand 2 if nwstatus==5, gen(ded)

replace status=5 if ded==1
replace wave=wave+1 if ded==1
sort spid wave ded
by spid: gen t=_n 



sort spid wave
by spid: replace anfinw=anfinw[_n-1] if status==4 & !anfinw
by spid: replace anfinw=anfinw[_n-1] if !anfinw & rcfres==1

//old
/*
preserve
tab t
drop if lml==1
replace nwstat=6 if status==4 & nwstat<3
tab status nwstat if nwstat<6, row nokey
tab status nwstat if nwstat<6 & t==1, row nokey
tab status nwstat if nwstat<6 & t>1, row nokey


keep spid nwstat t
reshape wide nwstat, i(spid) j(t)
gen nwstat0=3
label define nwstat0 3 "Incident HB"
label values nwstat0 nwstat0
forvalues i=1/7 {
               replace nwstat`i'=nwstat`=`i'-1' if inlist(nwstat`=`i'-1',5/*,7*/)
               *replace nwstat`i'=nwstat`=`i'-1' if missing(nwstat`i') & inlist(nwstat`=`i'-1',5,6,7)
}
restore
*/


//merge m:1 spid using "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2_1.dta", keepusing(spid) keep(matched) nogen  



//keep if firsthb==2

//including LFU group
capture drop a
//Q4. Of those who were semi-HB in 2013, what % were HB in 2014? Of those who were independent in 2013, what % were HB in 2014?
sort spid t
gen a=0 if t==2 & status==3 
replace a=1 if t==2 & status==3 & t[_n+1]==3 & status[_n+1]==2 
sum a [aw=anfinw]

//Excluding LFU group
capture drop a
//Q4. Of those who were semi-HB in 2013, what % were HB in 2014? Of those who were independent in 2013, what % were HB in 2014?
sort spid t
gen a=0 if t==2 & status==3 & nwstatus!=6
replace a=1 if t==2 & status==3 & t[_n+1]==3 & status[_n+1]==2 & nwstatus!=6
sum a [aw=anfinw]


tab status, nolabel

gen b=0 if t==2 & status==1
replace b=1 if t==2 & status==1 & spid== spid[_n+1] & status[_n+1]==2
sum b [aw=anfinw]

preserve
//Q5. percentage died when status is semi-hb
keep if wave==3 
drop if status==5
svy: tab status everdied if everlfu!=1, col
svy: tab status everdied if everlfu!=1, row
svy: tab status everdied if everlfu!=1
restore

keep spid anfinwgt nwstat t varunit varstrat
expand 2
sort spid t
by spid: replace t=0 if _n==1
duplicates drop
//
replace nwstat=0 if t==0 
label define nwstat 0 "Incident HB", modify
rename nwstat status
label var status "Status at current wave"
label var t "Time from incident homebound"
sort spid t
by spid: replace status=5 if status[_n-1]==5

forvalues i=1/7 {
expand 2
sort spid t
by spid: replace t=t+1 if _n==_N
duplicates drop
}
drop if t>7

// until here everyone has 8 waves of including wave 2. Waves 2-9

/*local n=0
local fdenom=10000
forvalues t=2/2 {
               qui sum status if t==`t' & status<6
               if `t'>1 local fdenom=r(N)
               forvalues n1=0/4 {
                              qui sum prevstat if t==`t' & prevstat==`n1' & status<6
                              local denom=r(N)
                              di "t=`t', n1=`n1', denom=`denom'
                              forvalues i=1/5 {
                                             qui sum status if t==`t' & prevstat==`n1' & status==`i'
                                             local numer=r(N)
                                             di `numer'
                                             qui replace stat`t'=`i' if inrange(_n,`n'+1,`n'+round((`numer'/`denom')*`fdenom')) & `denom'>0
                                             if `denom'>0 local n=`n'+round((`numer'/`denom')*`fdenom') 
                                             di "n=`n'"
}
                              qui replace stat`t'=5 if missing(stat`t') & _n<=round(`fdenom'/`denom') & `denom'>0
                              qui replace stat`t'=5 if missing(stat`t') & `denom'==0
                              if `denom'>0 local n=round(`fdenom'/`denom') 
                              di "n=`n'"
                              qui replace stat`t'=. if _n>1000
}
               local n=0
               label define stat`t' 0 "Incident HB" 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "LFU" 7 "Censored", modify
               label values stat`t' stat`t'
}*/
//replace status=. if status>=6
levelsof status, local(levels)
foreach l of local levels {
               gen status`l'=status==`l'
}

sort spid t 
by spid: gen prevstat=status[_n-1]
//drop if status==6

gen n=_n
gen stat0=0 if _n<=10000
label define stat0 0 "100% Incident HB"
label values stat0 stat0
local n=0


tab t status //gives status and time table 


mat tab=J(8,7,.)
local r=1
local c=1
forvalues i=0/6 { 
forvalues w=0/7{
sum n if status==`i' & t==`w'
mat tab[`r',`c']=r(N)
local r=`r'+1
}
local c=`c'+1
local r=1
}

mat rownames tab= "Time 0" "Time 1" "Time 2" "Time 3" "Time 4" "Time 5" "Time 6" "Time 7"
mat colnames tab="Incident Homebound" "Independent" "Semi-homebound" " Homebound" "Nursing Home" "Dead" "Lost to Follow-up"

mat list tab

frmttable using sankey_table.rtf, replace statmat(tab) title("Status by Time from Incident Homebound")sdec(0) varlabels note("267 people in each time period." "Time 0 is the Wave 2 incident homebound individuals." )


mat tab=J(8,7,.)
local r=1
local c=1
forvalues i=0/6 { 
forvalues w=0/7{
sum n [aw=anfinw] if status==`i' & t==`w'
mat tab[`r',`c']=r(N)
local r=`r'+1
}
local c=`c'+1
local r=1
}

mat rownames tab= "Time 0" "Time 1" "Time 2" "Time 3" "Time 4" "Time 5" "Time 6" "Time 7"
mat colnames tab="Incident Homebound" "Independent" "Semi-homebound" " Homebound" "Nursing Home" "Dead" "Lost to Follow-up"

mat list tab

frmttable using sankey_table.rtf, replace statmat(tab) title("Status by Time from Incident Homebound")sdec(0) varlabels note("267 people in each time period." "Time 0 is the Wave 2 incident homebound individuals." )

svy: tab status if t==1 & status<6

drop if status==6

//set obs 10000




//replace stat0=0 if _n<=10000
local n=0
forvalues t=1/6 {
               sort stat`=`t'-1'
                              gen stat`t'=.
               label define stat`t' 0 "Incident HB" 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "(6) LFU" 7 "Censored", modify
               label values stat`t' stat`t'
               qui sum status if t==`t' 
               local denom=r(N)
               forvalues n1=0/5 {
                              qui sum status if prevstat==`n1' & t==`t' & status<6 [aw=anfinw]
                              qui sum stat`=`t'-1' if stat`=`t'-1'==`n1'  [aw=anfinw]

                              local d2=r(N)
                              if `d2'==. local d2=0
                                                            di "t=`t', n1=`n1', denom=`denom', d2=`d2'"

                              forvalues i=5(-1)1 {
                                             qui sum status`i' if prevstat==`n1' & t==`t' [aw=anfinw]
                                             local m=r(mean)
                                             if `d2'>0 {
                                             di "range is `=`n'+1' to  `=`n'+round(`m'*`d2')'"
                                             replace stat`t'=`i' if inrange(_n,`n'+1,`n'+round(r(mean)*`d2'))
                                             local n=`n'+round(r(mean)*`d2')
}
                                             di "n=`n'"

                                             
}
}
               replace stat`t'=5 if stat`=`t'-1'==5
			   //replace stat`t'=6 if stat`=`t'-1'==6
               replace stat`t'=. if _n>10000
              replace stat`t'=5 if missing(stat`t') & _n<=10000
               local n=0
}




replace stat6=5 if missing(stat6) & _n<=10000
replace stat1=5 if missing(stat1) & _n<=10000

tab stat1

svy: tab status if t==1 & status<6
tab status if t==1 & status<6
svy: tab status if t==2 & status<6	
tab status if t==2 & status<6

keep spid anfinwgt stat* 
drop statu*                        anfinw
keep if _n<10001




forvalues i=1/6 {
               forvalues j=1/5 {
							  qui sum stat`i' if stat`i'==`j' //[aw=anfinw]
                              local pct`j'=round((r(N)/1673)*100, 0.01)
}
               label define stat`i' 0 "Incident HB" 1 "(1) `pct1'% Independent" 2 "(2) `pct2'% Semi-HB" 3 "(3) `pct3'% HB" 4 "(4) `pct4'% NH" 5 "(5) `pct5'% Dead" 6 "(6) `pct6'% LFU" 7 "Censored", modify
}              

sum stat1 if stat1==1
sum stat2

tab stat1
tab stat2
tab stat3
tab stat4
tab stat5
label define stat5 3 "(3) 9.03% HB", modify 
tab stat5
tab stat6
label define stat6 5 "(5) 67.54% Dead", modify
tab stat6



H="xwave 6 table 1 with mi"
//Part 1

clear all
set more off
capture log close


cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"


import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow case(lower) clear

gen wave=.
forvalues w=1/8{
replace wave=`w' if year==201`w'
}

drop if wave==.

tempfile poverty_thresh
save "`poverty_thresh'", replace

use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear

merge m:1 wave hhm using "`poverty_thresh'"

sort wave hhm
by wave: carryforward poverty_thresh if hhm>9 & hhm!=., replace 
drop if _merge==2
drop _merge

gen poverty=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)


forvalues i=1/5 {
gen imppov`i'=imputed_inc`i'<=poverty_thresh 
}

keep if wave>4
replace wave=wave-4

mi import wide, imputed(poverty=imppov1 imppov2 imppov3 imppov4 imppov5) clear

rename (_*_poverty) (poverty_*)
tempfile t1
save `t1'



use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if lml==0, clear


//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw

keep if wave>4
replace wave=wave-4


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave
by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3
gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3

//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 

drop r1status r2status r3status r4status
rename (r5status r6status r7status r8status) (r1status r2status r3status r4status)

//finding next wave status 
gen nwstatus=.
forvalues i=1/3 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=4
by spid: carryforward everlfu, replace 

sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

keep if wave==2

gen os=1 

svy: tab nwstatus if nwstatus!=9

gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}


tab income_quart, gen(inccat)

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

mi set wide

mi misstable patterns outcome

mi register imputed outcome

tab outcome, m

//MI regular mlogit model -- hb_mlogit_2_6_mi

mi impute logit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem if outcome!=2, add(10) rseed(55) force

rename (_*_outcome) (outcome_*)
//table 1

merge 1:1 spid wave using "`t1'"

mi unset

mi import wide, imputed(poverty=poverty_1 poverty_2 poverty_3 poverty_4 poverty_5 outcome=outcome_1 outcome_2 outcome_3 outcome_4 outcome_5) clear 

mi svyset 

label var poverty "In Poverty"

 
save "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta", replace


///here--working on getting table 1 for wave 2 using mi.
/*
local cvars1 age
local cvars2  income_adj
local ivars1 female white black hisp other_race married poverty

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
 forvalues i=1/9 {
gen group`i'=nwstatus==`i'
}
	

local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' `coutcomes' `coutcomes' `ioutcomes' 1 1
di `rn'
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
foreach i in 1 2 5 7 8 9 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			mi estimate: svy, subpop(if os & group`i'==1): mean `x'
			mat tab1[`r',`c']=e(b_mi)
			if inlist("`i'","1","5","7","8","9") {
				mi estimate: svy, subpop(if os==1 & (group`i'==1 | group2==1)): reg `x' group`i'
				mi test group`i'
				mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05) 
}
			local r=`r'+1
}
		foreach x of local ivars`round' {
			mi estimate: svy, subpop(if os & group`i'==1): mean `x' 
			mat tab1[`r',`c']=e(b_mi)*100
			if inlist("`i'","1","5","7","8","9") {
				mi estimate, cmdok: svy, subpop(if status==2 & wave==2  & (group`i'==1 | group2==1)): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
}
	local r=`r'+1

	mi estimate: svy, subpop(if os & group`i'==1): mean n 
	
	mat tab1[`r',`c']=e(N_sub)
	mat tab1[`r'+1,`c']=e(N_subpop_mi)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2.rtf, replace statmat(tab1) ///
 title("Sample Characteristics by next wave status") ///
 ctitles("" "Community" "HB" "Inc SHB" "Inc NH" ///
 "Died" "LFU") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 NHATS Homebound sample, by next-wave status" )
 
*/
 
 
 
 
local cvars1 age
local cvars2  income_adj
local ivars1 female white black hisp other_race married poverty

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
	

local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' 1 1
di `rn'
mat tab1=J(`rn',3,.)
mat stars=J(`rn',3,0)
local r=1
local c=1
foreach i in 0 1 2 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean `x'
			mat tab1[`r',`c']=e(b_mi)
			if inlist("`i'","1","2") {
				mi estimate, esampvaryok: svy, subpop(if os==1 & (outcome==`i' | outcome==0)): reg `x' outcome 
				mi test outcome 
				mat stars[`r',`c']=(e(p_mi)<.01) + (e(p_mi)<.05)
}
			local r=`r'+1
}

		foreach x of local ivars`round' {
			capture mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean `x' 
			mat tab1[`r',`c']=e(b_mi)*100
			if inlist("`i'","1","2") {
				capture mi estimate, esampvaryok: svy, subpop(if os==1 & (outcome==`i' | outcome==0)): logit `x' outcome 
				mat stars[`r',`c']=(e(p_mi)<.01) + (e(p_mi)<.05)
} 
			local r=`r'+1
}
}
	local r=`r'+1

	mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean n 
	
	mat tab1[`r',`c']=e(N_sub_mi)
	mat tab1[`r'+1,`c']=e(N_subpop_mi)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_6.rtf, replace statmat(tab1) ///
 title("Sample Characteristics by next wave status") ///
 ctitles("" "HB" "Community" "Inc NH/Died") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 6 NHATS Homebound sample, by next-wave status" "Imputation for Poverty and Outcome ")
 

H="xwave 6 analysis with mi"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave6.dta", replace

mi estimate, post : svy, subpop(if os==1): mlogit outcome age female black hisp married educ_hs_ind , b(0) 

outreg using hb_mlogit_6_mi_wgt.rtf, stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") eq_merge title("Table 1: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels replace


mi estimate, post : svy, subpop(if os==1): mlogit outcome age female black hisp married ind_noone educ_hs_ind  ///
medicaid prob_dem adl_diff_ind srh_fp ///
ind_paid_helper metro_ind northeast midwest south poverty cohesion ownhome, b(0)

outreg using hb_mlogit_6_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 2: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 


mi estimate, post : svy, subpop(if os==1): mlogit outcome age female white educ_hs_ind poverty srh_fp adl_impair prob_dem, base(0)

outreg using hb_mlogit_6_mi_wgt.rtf,  addtable  stats(e_b e_ci p) ctitles("" "Com. vs. HB" "NH/Died vs. HB") replace eq_merge title("Table 3: Multiple Imputation Adjusted Next Wave Status Multinomial Model") note("Displaying RRRs" \ "Outcomes are comparing next wave status" ) varlabels 




H="Wave 2 Table 1 with mi"
//Part 1

clear all
set more off
capture log close
set seed 55

cd "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output"


import excel "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\data\poverty_thresh.xlsx", sheet("Sheet1") firstrow case(lower) clear

gen wave=.
forvalues w=1/8{
replace wave=`w' if year==201`w'
}

drop if wave==.

tempfile poverty_thresh
save "`poverty_thresh'", replace


use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only_NEW.dta", clear


merge m:1 wave hhm using "`poverty_thresh'"

sort wave hhm
by wave: carryforward poverty_thresh if hhm>9 & hhm!=., replace 
drop if _merge==2
drop _merge

gen poverty=(aveincome/poverty_thresh)<=1 if round(aveincome)==round(imputed_inc1)

forvalues i=1/5 {
gen imppov`i'=imputed_inc`i'<=poverty_thresh
}

sort spid wave
mi import wide, imputed(poverty=imppov1 imppov2 imppov3 imppov4 imppov5) clear

rename (_*_poverty) (poverty_*)
tempfile t1
save `t1'


use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta", clear

replace nhats_died_12=1 if spid==spid[_n+1] & lml_ivw[_n+1]==1
gen lml_ivw_nw=lml_ivw[_n+1] if spid==spid[_n+1]

drop if lml_ivw_yes==1

set seed 45

//cpi inflation
gen income_adj=0
replace income_adj= (251.107/224.939)*aveincome if wave==1
replace income_adj= (251.107/229.594)*aveincome if wave==2
replace income_adj= (251.107/232.957)*aveincome if wave==3
replace income_adj= (251.107/236.736)*aveincome if wave==4
replace income_adj= (251.107/237.017)*aveincome if wave==5
replace income_adj= (251.107/240.007)*aveincome if wave==6
replace income_adj= (251.107/245.120)*aveincome if wave==7
replace income_adj=aveincome if wave==8

//replacing analytic weights to use only weights for origianl cohort. 
//only using original cohort (decision made based off of prior analysis with replenishment cohort. 
gen orig_weight=anfinw
replace anfinw=an2011wgt if (year==2011 & wave==5) | (year==2011 & wave==6) | (year==2011 & wave==7) | (year==2011 & wave==8)
drop if yearsample==2015


//VARIABLE CREATION/CLEANUP
gen ind_noone=n_social==0
label var ind_noone "SR nobody in social network"

sort spid wave
by spid: egen firstdem=min(cond(prob_dem==1,wave,.))

xtset spid wave
replace homebound_cat=. if nhres==1
gen homebound=homebound==1 if !missing(homebound) & !nhres
gen status=1 if sp_ivw==1 & !missing(homebound)
replace status=2 if homebound==1
replace status=3 if inlist(homebound_cat,2,3)
replace status=4 if nhres==1
label define status 1 "Community, not HB" 2 "Homebound" 3 "Semi-Homebound" 4 "NH resident" 5 "Community, previously HB or NH resident"
label values status status
label var status "Status this wave"

//checking individuals who have a missing status. 
by spid: gen mstat=1 if status==.
by spid: carryforward mstat, replace

//checking individuals who have missing wave and flagging them.
capture drop misw
by spid: gen misw=1 if wave[_n-1]!=wave-1 & wave!=1
capture drop misw1
gen misw1=misw
by spid: carryforward misw1, replace


//Dropping individuals with a missing status or a missing wave.
drop if mstat==1 
drop if misw1==1 


gen hb2=0
replace hb2=1 if status==2 & wave==2
by spid: carryforward hb2, replace

gen comw1=.
replace comw1=1 if wave==1 & (status==1 | status==3)
sort spid wave
by spid: carryforward comw1, replace

//incident hb in wave 2 
gen sample=.
replace sample=1 if comw1==1 & hb2==1 & wave==2
sort spid wave
by spid: carryforward sample, replace 

drop if sample==.


by spid: gen hbnextwave=homebound[_n+1] //flag next wave being homebound
by spid: gen nhnextwave=nhres[_n+1] //flag next wave being NH
by spid: gen comnextwave=status[_n+1]==1
by spid: gen shbnextwave=status[_n+1]==3

forvalues w=2/7{
replace nhats_died_12=1 if r`=`w'+1'status==86 & wave==`w'
}

sort spid wave
gen comw=wave if status==1
gen hbw=wave if homebound==1 //homebound at what wave
gen nhw=wave if nhres==1 // NH at what wave
gen shbw=wave if inlist(homebound_cat,2,3)
by spid, sort: egen firsthb=min(hbw) //first homebound wave for an individual
by spid, sort: egen firstnh=min(nhw) //first NH wave for an individual
by spid, sort: egen firstshb=min(shbw)
by spid, sort: egen firstcom=min(comw)


gen everhb=!missing(firsthb) //if an individual was ever homebound
gen evernh=!missing(firstnh) //if an individual was ever NH
gen evershb=!missing(firstshb)
gen evercom=!missing(firstcom)
label var everhb "Ever HB"
label var evernh "Ever NH"
label var evershb "Ever SHB"
label var evercom "Ever Com"
*drop if firsthb==1 | missing(homebou)
sort spid wave

gen inchbnextwave=firsthb==wave+1 & homebound==0 //flag incident homebound next wave
gen incnhnextwave=firstnh==wave+1 & nhres==0 //flag incident NH next wave
gen inccomnextwave=firstcom==wave+1 & status!=1
gen incshbnextwave=firstshb==wave+1 & status!=3



//Dropping waves after first community/NH/SHB
sort spid wave
by spid: drop if firstnh<wave
by spid: drop if firstshb<wave
by spid: drop if firstcom<wave

//ever* var needs to be changed because later waves are dropped. 
replace evershb=0 if firstshb>firstnh & firstshb>firstcom
replace evernh=0 if firstshb<firstnh & firstcom<firstnh
replace evercom=0 if firstshb<firstcom & firstshb<firstcom 


//finding next wave status 
gen nwstatus=.
forvalues i=1/7 {
replace nwstatus=r`=`i'+1'status if wave==`i'
}
tab nwstat
tab r2status
replace nwstatus=1 if inlist(nwstatus,60,63) & !missing(hbne)
replace nwstatus=6 if inlist(nwstatus,61)
replace nwstatus=8 if inlist(nwstatus,62,86)
replace nwstatus=9 if nwstatus>7
replace nwstatus=8 if nhats_died_12==1 & nwstatus==9
label define nwstatus 1 "Comm" 2 "HB" ///
3 "Inc HB" 4 "SHB, no inc" 5 "Inc SHB" 6 "NH, not inc" ///
7 "Inc NH" 8 "Died" 9 "LFU"
label values nwstatus nwstatus
replace nwstatus=2 if hbne==1
replace nwstatus=3 if inchb==1
replace nwstatus=4 if shbne==1
replace nwstatus=5 if incshbne==1
replace nwstat=6 if nhne==1
replace nwstat=7 if incnhne==1
label var nwstat "Status next wave"
replace nhats_died_12=0 if nwstatus<=7
label var nhats_died_12 "Died prior to next wave"

//generating everdied, but since we don't follow people after wave 6 we don't 
// know if they died based off NHATS data.
sort spid wave
capture drop everdied
gen everdied=1 if nwstatus==8 
gsort spid -wave
by spid: carryforward everdied, replace 
replace everdied=0 if missing(everdied)

//same as above explanation
capture drop everlfu
gen everlfu=1 if nwstatus==9 & wave!=8
by spid: carryforward everlfu, replace 

sort spid wave

gen a=1 if wave+1!=wave[_n+1] & spid==spid[_n+1]

sort spid wave
by spid: gen time=_n 

bys spid: egen lw=max(wave)

replace lw=lw+1 if inlist(nwstatus, 8,9) & status==2

by spid: egen fix=max(lw)

replace lw=fix 

drop fix

tab lw status

gen f_stat=.
replace f_stat=1 if lw==wave & status==1
replace f_stat=2 if lw==wave & status==3
replace f_stat=3 if lw==wave & status==4
replace f_stat=4 if nwstatus==8 & lw-1==wave & status==2
replace f_stat=0 if nwstatus==9 & lw-1==wave & status==2

gsort spid -wave

by spid: carryforward f_stat, replace

keep if wave==2
label var f_stat "Final Status"
label define f_stat 0 "LFU" 1 "Community" 2 "Semi-Homebound" 3 "NH Resident" 4 "Died" 
label values f_stat f_stat

replace lw=lw-2
bys f_stat: sum lw

tab nwstatus, gen(nwstatus)

gen os=1 

svy: tab nwstatus if nwstatus!=9

gen sr_cond_cat=1 if sr_numcond<2
replace sr_cond_cat=2 if inrange(sr_numcond,2,4)
replace sr_cond_cat=3 if inrange(sr_numcond,5,15)
label define sr_cond_cat 1 "0-1 SR condition" 2 "2-4 SR conditions" 3 "5+ SR conditions"
label values sr_cond_cat sr_cond_cat
tab sr_cond_cat, gen(sr_cond_cat)
forvalues i=1/3 {
local lab: label sr_cond_cat `i'
label var sr_cond_cat`i' "`lab'"
}

gen ind_helper=ind_no_helper==0
label var ind_helper "Indicator Helpers reported"

tab income_quart, gen(inccat)

gen outcome=0 if nwstatus==2
replace outcome=1 if nwstatus==1 | nwstatus==5
replace outcome=2 if nwstatus==7 | nwstatus==8
replace outcome=. if nwstatus==9

lab define outcome 0 "HB" 1 "Community" 2 "NH/Died"
lab values outcome outcome 


mi set wide


mi misstable patterns outcome

mi register imputed outcome

tab outcome, m

//MI regular mlogit model -- hb_mlogit_2_6_mi
sort spid wave

mi impute logit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem if outcome!=2, add(5) rseed(55) force

logit outcome age female white educ_hs_ind inccat1 srh_fp adl_impair prob_dem if outcome!=2, or
outreg using logit_model.rtf, stats(e_b e_ci p) replace title(Logit model for outcome imputation) note("Unweighted logit model used on HB and Community outcomes only. An outcome of 0 is being homebound, an outcome of 1 is being in the community in their next wave. Bottom income quartile is binary.") varlabels


rename (_*_outcome) (outcome_*)
//table 1

merge 1:1 spid wave using "`t1'"

mi unset
sort spid wave

mi import wide, imputed(poverty=poverty_1 poverty_2 poverty_3 poverty_4 poverty_5 outcome=outcome_1 outcome_2 outcome_3 outcome_4 outcome_5) clear 

//mi extract 0, clear

mi svyset 


label var poverty "In Poverty"

//
tab adl_index  if n_helpers==0
replace n_helpers=. if adl_index==0 & iadl_index==0



save "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2.dta", replace
preserve
keep if os==1
save "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\Ornstein_R01_homebound\hb_trajectories\output\wave2_1.dta", replace
restore


///here--working on getting table 1 for wave 2 using mi.
/*
local cvars1 age
local cvars2  income_adj
local ivars1 female white black hisp other_race married poverty

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
 forvalues i=1/9 {
gen group`i'=nwstatus==`i'
}
	

local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' `coutcomes' `coutcomes' `ioutcomes' 1 1
di `rn'
mat tab1=J(`rn',6,.)
mat stars=J(`rn',6,0)
local r=1
local c=1
foreach i in 1 2 5 7 8 9 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			mi estimate: svy, subpop(if os & group`i'==1): mean `x'
			mat tab1[`r',`c']=e(b_mi)
			if inlist("`i'","1","5","7","8","9") {
				mi estimate: svy, subpop(if os==1 & (group`i'==1 | group2==1)): reg `x' group`i'
				mi test group`i'
				mat stars[`r',`c']=(r(p)<.01) + (r(p)<.05) 
}
			local r=`r'+1
}
		foreach x of local ivars`round' {
			mi estimate: svy, subpop(if os & group`i'==1): mean `x' 
			mat tab1[`r',`c']=e(b_mi)*100
			if inlist("`i'","1","5","7","8","9") {
				mi estimate, cmdok: svy, subpop(if status==2 & wave==2  & (group`i'==1 | group2==1)): tab `x' group`i' 
				mat stars[`r',`c']=(e(p_Pear)<.01) + (e(p_Pear)<.05)
}
			local r=`r'+1
}
}
	local r=`r'+1

	mi estimate: svy, subpop(if os & group`i'==1): mean n 
	
	mat tab1[`r',`c']=e(N_sub)
	mat tab1[`r'+1,`c']=e(N_subpop_mi)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2.rtf, replace statmat(tab1) ///
 title("Sample Characteristics by next wave status") ///
 ctitles("" "Community" "HB" "Inc SHB" "Inc NH" ///
 "Died" "LFU") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 NHATS Homebound sample, by next-wave status" )
 
*/
 
 mi estimate, esampvaryok: svy, subpop(if os==1): proportion  outcome
 

 
 label var nwstatus1 "Community"
 label var nwstatus2 "Homebound"
 label var nwstatus3 "Semi-Homebound"
 label var nwstatus4 "Nursing Home"
 label var nwstatus5 "Died"
 label var nwstatus6 "LFU"
 
 
local cvars1 age
local cvars2  income_adj n_helpers
local ivars1 female white black hisp other_race married poverty

local ivars2 proxy  ///
medicaid medigap srh_fp ind_help adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent metro_ind northeast midwest south west nwstatus1 nwstatus2 nwstatus3 nwstatus4 nwstatus5 nwstatus6  /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/


//preserve
gen n=1
	

local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' 1 1
di `rn'
mat tab1=J(`rn',1,.)
mat stars=J(`rn',1,0)
local r=1
local c=1

foreach round in 1 2 {
		foreach x of local cvars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1): mean `x'
			mat tab1[`r',`c']=e(b_mi)
			local r=`r'+1
	
}
			

		foreach x of local ivars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1): mean `x' 
			mat tab1[`r',`c']=e(b_mi)*100
			local r=`r'+1
} 
			
}
	local r=`r'+1
	
	mi estimate, esampvaryok: svy, subpop(if os==1): mean n 
	
	mat tab1[`r',`c']=e(N_sub_mi)
	mat tab1[`r'+1,`c']=e(N_subpop_mi)
	local r=1


foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2.rtf, replace statmat(tab1) ///
 title("Table1: Sample Characteristics for Incident Homebound at Wave 2") ///
 ctitles("" "Homebound" ) ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 NHATS Homebound sample" "Imputation for Poverty only")
 
preserve 

drop outcome_* outcome_*_ _*_outcome 

local cvars1 age
local cvars2  income_adj n_helpers
local ivars1 female white black hisp other_race married poverty

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent srh_fp sr_phq2_depressed sr_gad2_anxiety metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/ 
 
 
 local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' 1 1
di `rn'
mat tab1=J(`rn',3,.)
mat stars=J(`rn',3,0)
local r=1
local c=1
foreach i in 0 1 2 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean `x'
			mat tab1[`r',`c']=e(b_mi)
			if inlist("`i'","1","2") {
				mi estimate, esampvaryok: svy, subpop(if os==1 & (outcome==`i' | outcome==0)): reg `x' outcome 
				mi test outcome 
				mat stars[`r',`c']=(e(p_mi)<.01) + (e(p_mi)<.05)
}
			local r=`r'+1
}

		foreach x of local ivars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean `x' 
			mat tab1[`r',`c']=e(b_mi)*100
			if inlist("`i'","1","2") {
				capture mi estimate, esampvaryok: svy, subpop(if os==1 & (outcome==`i' | outcome==0)): logit `x' outcome 
				mat stars[`r',`c']=(e(p_mi)<.01) + (e(p_mi)<.05)
} 
			local r=`r'+1
}
}
	local r=`r'+1

	mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean n 
	
	mat tab1[`r',`c']=e(N_sub_mi)
	mat tab1[`r'+1,`c']=e(N_subpop_mi)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2.rtf, replace statmat(tab1) ///
 title("Table 2: Sample Characteristics by next wave status (No outcome imputation)") ///
 ctitles("" "HB" "Community" "Inc NH/Died") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 NHATS Homebound sample, by next-wave status" "Imputation for Poverty" "Most have helpers, thus we don't see stars" "LFU group not included") addtable  
 
 
 restore 

local cvars1 age
local cvars2  income_adj n_helpers
local ivars1 female white black hisp other_race married poverty

local ivars2 proxy  ///
medicaid medigap srh_fp adl_eat_help adl_bath_help adl_toil_help adl_dres_help ///
adl_ins_help adl_bed_help adl_impair iadl_impair ///
sr_cond_cat1 sr_cond_cat2 sr_cond_cat3 sr_ami_ever sr_stroke_ever sr_cancer_ever sr_hip_ever sr_heart_dis_ever ///
sr_htn_ever sr_ra_ever sr_osteoprs_ever sr_diabetes_ever sr_lung_dis_ever ///
prob_dem dem_2_cat adl_diff_ind adl_independent sr_phq2_depressed sr_gad2_anxiety metro_ind northeast midwest south west /*///
fin_strain mealskip nopayhous nopayutil nopaymed anydebt creditdebt medpaynotcash finhlpfam meals_wheels govtasst*/ 
 
 
 local rn : word count 1 `cvars1' `cvars2' `ivars1' `ivars2' 1 1
di `rn'
mat tab1=J(`rn',3,.)
mat stars=J(`rn',3,0)
local r=1
local c=1
foreach i in 0 1 2 {
	foreach round in 1 2 {
		foreach x of local cvars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean `x'
			mat tab1[`r',`c']=e(b_mi)
			if inlist("`i'","1","2") {
				mi estimate, esampvaryok: svy, subpop(if os==1 & (outcome==`i' | outcome==0)): reg `x' outcome 
				mi test outcome 
				mat stars[`r',`c']=(e(p_mi)<.01) + (e(p_mi)<.05)
}
			local r=`r'+1
}

		foreach x of local ivars`round' {
			mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean `x' 
			mat tab1[`r',`c']=e(b_mi)*100
			if inlist("`i'","1","2") {
				capture mi estimate, esampvaryok: svy, subpop(if os==1 & (outcome==`i' | outcome==0)): logit `x' outcome 
				mat stars[`r',`c']=(e(p_mi)<.01) + (e(p_mi)<.05)
} 
			local r=`r'+1
}
}
	local r=`r'+1
	
	mi estimate, esampvaryok: prop outcome if os==1
	if inlist("`i'", "0"){
	mat n=e(b_mi)[1,1] 
	}
	if inlist("`i'", "1"){
	mat n=e(b_mi)[1,2] 
	}
	if inlist("`i'", "2"){
	mat n=e(b_mi)[1,3] 
	}
	
	mat tab1[`r',`c']=n*e(N_mi)
	
	mi estimate, esampvaryok: svy, subpop(if os==1 & outcome==`i'): mean n
	mat tab1[`r'+1,`c']=e(N_subpop_mi)
	local r=1
	local c=`c'+1
}

foreach x in `coutcomes' {
local rnames `rnames' "`x'" "Median"
}

mat rownames tab1=`cvars1' `ivars1' `cvars2' `ivars2' "_" N "Estimate"

frmttable using table_1_wave_2.rtf, replace statmat(tab1) ///
 title("Table 3: Sample Characteristics by next wave status") ///
 ctitles("" "HB" "Community" "Inc NH/Died") ///
 sdec(2) annotate(stars) asymbol(*,**) ///
 varlabels note("Waves 2 NHATS Homebound sample, by next-wave status" "Imputation for Poverty and Outcome" "Most have helpers, thus we don't see stars") addtable 
 

bys f_stat: sum lw
sum lw if f_stat==1, ci



H="new sankey new"
use "J:\Geriatrics\PCare\HRS Projects\Data & Project-based (reference docs, etc)\NHATS\base_data\sp_round_1_8_public_sens_only.dta" if year==2011, clear

set seed 15
replace anfinwgt=an2011wgt if wave>=5


replace homebound_cat=. if lml==1 | nhres==1

by spid: egen firsthb=min(cond(homebound_cat==1 & inrange(homebound_cat[_n-1],2,4),wave,.))
tab firsthb
tab firsthb wave
drop if missing(firsthb)
gen status=1 if homebound_cat==4
replace status=2 if inlist(homebound_cat,2,3)
replace status=3 if inlist(homebound_cat,1)
replace status=4 if nhres==1
replace status=5 if sp_status==4


//incident hb in wave 2 
sort spid wave
keep if firsthb==2

by spid: replace status=status[_n-1] if missing(status) & !missing(status[_n+1])

by spid: gen nwstat=status[_n+1]
replace nwstat=5 if missing(nwstat) & nhats_died_12==1
forvalues i=2/8 {
               replace nwstat=5 if inlist(r`i'status,62,86) & wave==`i'-1
               replace nwstat=4 if r`i'status==64 & wave==`i'-1 & nhres==1

}


sort spid wave


replace nwstat=6 if missing(nwstat)
label define nwstat 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "LFU" 7 "Censored"
label values nwstat nwstat
replace nwstat=7 if wave==8
drop if wave<firsthb
drop if firsthb==year-2010 | firsthb==8
sort spid wave 
by spid: gen t=_n
label values status nwstat


//fill in with current status if only missing one wave
sort spid t
by spid: replace nwstat=nwstat[_n-1] if nwstat==6 & nwstat[_n+1]<6 & nwstat[_n-1]<6

//drop all who are missing more than one wave
by spid: drop if nwstat[_n-1]>4 & t>1
by spid: drop if nwstat[_n-1]>4 & t>1
by spid: drop if nwstat[_n-1]>4 & t>1
by spid: drop if nwstat[_n-1]>4 & t>1
by spid: drop if nwstat[_n-1]>4 & t>1
by spid: drop if nwstat[_n-1]>4 & t>1

//bring forward the weights for NH residents
by spid: replace anfinw=anfinw[_n-1] if !anfinw | missing(anfinw)
by spid: replace status=4 if missing(status) & nwstat[_n-1]==4

keep spid anfinwgt nwstat t
expand 2
sort spid t
by spid: replace t=0 if _n==1
duplicates drop
replace nwstat=0 if t==0
label define nwstat 0 "Incident HB", modify
rename nwstat status
label var status "Status at current wave"
label var t "Time from incident homebound"
sort spid t


forvalues i=1/7 {
expand 2
sort spid t
by spid: replace t=t+1 if _n==_N
duplicates drop
}

drop if t>7


replace status=. if status>=6
levelsof status, local(levels)
foreach l of local levels {
               gen status`l'=status==`l' if status<6
}

sort spid t 

by spid: gen prevstat=status[_n-1]
drop if status>5
set obs 100000
gen n=_n
gen stat0=0 if _n<=100000
label define stat0 0 "100% Incident HB"
label values stat0 stat0
local n=0






forvalues t=1/6 {
	sort stat`=`t'-1'
	gen stat`t'=.
	label define stat`t' 0 "Incident HB" 1 "(1) Independent" 2 "(2) Semi-HB" 3 "(3) HB" 4 "(4) NH" 5 "(5) Dead" 6 "LFU" 7 "Censored", modify
	label values stat`t' stat`t'
	forvalues i=0/4 {
		sum stat`=`t'-1' if stat`=`t'-1'==`i'
		local denom=r(N)
		forvalues j=1/5 {
			sum status`j' if prevstat==`i' & t==`t' [aw=anfinw]
			local num=r(mean)
			if `denom'!=0 {
				replace stat`t'=`j' if stat`=`t'-1'==`i' & inrange(_n,`n'+1,round(`n'+`num'*`denom'))
				local n=`n'+round(`num'*`denom')
				di `n'
				tab stat`t'
}
}
}
	if `t'>1 {
		replace stat`t'=stat`=`t'-1' if missing(stat`t')
}
	else if `t'==1 & missing(stat`t') {
		replace stat`t'==3
}
	local n=0
	
}
			



forvalues i=1/6 {
                  forvalues j=1/5 {
                                  sum stat`i' if stat`i'==`j' 
                                                             scalar pct`j'=round((r(N)/100000)*100,0.1)
                                         if `i'==5 di pct`j'
                                                  local pct`j'=pct`j'
 } 
                                      if `i'==5 di `pct`j''
  
                  label define stat`i' 0 "Incident HB" 1 "(1) `=pct1'% Independent" 2 "(2) `=pct2'% Semi-HB" 3 "(3) `=pct3'% HB" 4  "(4) `=pct4'% NH" 5 "(5) `=pct5'% Dead" 6 "LFU" 7 "Censored", modify
  //note--this needs to be changed if the code changes at all
 if `i'==3 & round(pct5)==41 label define stat`i' 5 "(5) 41.4% Dead", modify
if `i'==4 & round(pct5)==51 label define stat`i' 5 "(5) 50.9% Dead", modify
 if `i'==5 & round(pct3)==9 label define stat`i' 3 "(3) 9.3% HB", modify
if `i'==5 & round(pct4)==5 label define stat`i' 4 "(4) 5.3% NH", modify
}   



keep stat*
drop status*









